<?xml version="1.0" encoding="UTF-8"?>
<test-data
    xmlns="http://pmd.sourceforge.net/rule-tests"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/rule-tests http://pmd.sourceforge.net/rule-tests_1_0_0.xsd">

    <test-code>
        <description>Simple method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Mixed local and foreign method calls</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>8</expected-linenumbers>
        <code><![CDATA[
import java.util.*;
public class Foo {
    private List instanceVariableA;
    public void example(Bar b) {
        localMethod();
        this.localMethod();
        int localVariableC;
        b.getC().doIt();
        int localVariableD;
    }
    private void localMethod() {}
    private int instanceVariableB;
}
class C { void doIt() {} }
class Bar { C getC() {} }
        ]]></code>
    </test-code>

    <test-code>
        <description>Simple Method calls without chaining</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    public void example(Bar b) {
        C c = b.getC();
        c.doIt();
    }
}
class C { void doIt() {} }
class Bar { C getC() {} }
        ]]></code>
    </test-code>

    <test-code>
        <description>Simple Method calls with chaining</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    public void example(Bar b) {
        b.getC().doIt();
    }
}
class C { void doIt() {} }
class Bar { C getC() {} }
        ]]></code>
    </test-code>

    <test-code>
        <description>Simple Method calls with local created object</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void example() {
        C c = new C();
        c.doIt();
    }
}
class C { void doIt() {} }
        ]]></code>
    </test-code>

    <test-code>
        <description>Simple Method calls with local created object and other variable assignment</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void example() {
        String something;
        C c = new C();
        c.doIt();
        something = "no worries";
    }
}
class C { void doIt() {} }
        ]]></code>
    </test-code>

    <test-code>
        <description>Simple Method calls with local created object and variables</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void example() {
        int data = 5;
        C c = new C();
        c.doIt(data);
    }
}
class C { void doIt() {} }
        ]]></code>
    </test-code>

    <test-code>
        <description>Simple Method call on local created object within nesting local scopes</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;
import java.util.ArrayList;
public class Foo {
    public void example(int c) {
        List<Integer> result = new ArrayList<Integer>();
        if (c > 0) {
            for (int i = 0; i < c; i++) {
                result.add(i);
            }
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Example documentation</description>
        <expected-problems>2</expected-problems>
        <code><![CDATA[
public class Foo {
    /**
     * This example will result in two violation.
     */
    public void example(Bar b) {
        // this method call is ok, as b is a parameter of "example"
        C c = b.getC();

        // this method call is a violation, as we are using c, which we got from B.
        // We should ask b directly instead, e.g. "b.doItOnC();"
        c.doIt();

        // this is also a violation, just differently expressed as a method chain without temporary variables.
        b.getC().doIt();

        // that's a constructor call, not a method call.
        D d = new D();
        // this method call is ok, because we have create the new instance of D locally.
        d.doSomethingElse();
    }
}
class C { void doIt() {} }
class D { void doSomethingElse() {} }
class Bar { C getC() {} }
        ]]></code>
    </test-code>

    <test-code regressionTest="false">
        <description>Static methods</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class B {
    public static A a = new A();
}

public class A {
    public static void doStatic() {
    }
}

public class Foo {
    public void example() {
        A.doStatic(); // direct static - allowed
        B.a.doStatic(); // static chain - violation
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Exclude iterator and list elements</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>24</expected-linenumbers>
        <code><![CDATA[
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

public class Foo {
    public void example() {
        List<String> list = new ArrayList<String>();
        list.add("Tata");
        Iterator<String> it = list.iterator();
        while (it.hasNext()) {
                String s = it.next();
                System.out.println(s);
        }
        if (list != null && !list.isEmpty()) {
            for (String s : list) {
                if (!s.isEmpty()) {
                    System.out.println(s);
                }
            }
        }

        List<String> anotherList = calcList();
        for (String s : anotherList) {
            if (!s.isEmpty()) { // here
                System.out.println(s);
            }
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#999 false positives</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Test {
    //Thats no Violation in PMD:
    public boolean compare1(final String aString) {
        return aString.equals("S");
    }

    //Thats a Violation in PMD:
    public boolean compare2(final String aString) {
        return "A".equals(aString);              // < - - false positive
    }

    Factory myFactory;
    // no violation, because the object is not used
    public Object create() {
        Object o = myFactory.create();
        return o;
    }
}
class Factory { Object create() { return new Object(); }}
        ]]></code>
    </test-code>
    <test-code>
        <description>FP with builder</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Test {
    // no violation, should be an exception, as the builder pattern is used here
    public void toString() {
        StringBuilder buffer = new StringBuilder();
        buffer.append("string").append("string").append("string");
        return buffer.toString();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#999 false negatives</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Test {
    Factory myObjectCreator;
    // violation, because object is used
    public Object create2() {
        Object o = myObjectCreator.create();
        o.setName("my name");                    // < - - !!!
        return o;
    }
}
class Factory { Object create() { return new Object(); }}
        ]]></code>
    </test-code>

    <test-code regressionTest="false">
        <!-- todo to me this is not a false positive -->
        <description>#1245 False Positive for Law of Demeter</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.Connection;
public class Test {
    Factory connectionFactory;
    public void bar() {
        // Create a Connection
        final Connection connection = connectionFactory.createConnection();
        connection.start();
    }
}
class Factory { Connection createConnection() { return new Connection(); }}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1427 False Positive for Law of Demeter</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Test {
    public void bar() {
        // Builder pattern
        final Builder builder = Builder.newBuilder();
        builder.withFoo();
        final FooBuilder fooBuilder = FooBuilder.newBuilder();
        fooBuilder.withBar();
    }
}
class Builder {static Builder newBuilder() {}}
class FooBuilder {static FooBuilder newBuilder() {}}
        ]]></code>
    </test-code>

    <test-code>
        <description>#2010 False Positive for Law of Demeter</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Test {
    public void bar() {
        // Inner Builder pattern chained
        final Bar bar = Bar.newBuilder()
                .withFoo("foo")
                .build();
    }
}

class Bar {
    static BarBuilder newBuilder() { }
}
class BarBuilder {
    BarBuilder withFoo(String s) {}
    Bar build() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>[java] LawOfDemeter: False positive with 'this' pointer #2174</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package pmdtests;

public class Foo {
    private final int i;

    public Foo(int i) {
        this.i = i;
    }

    public void meth() {
        System.out.println(this.i);     // wrong violation: method chain calls
        System.out.println(super.i);    // wrong violation: method chain calls
        System.out.println(i);          // no violation
    }

    public void method(Foo this) {      // receiver param!!
        System.out.println(this.i);     // wrong violation: method chain calls
    }

    public void method(Foo this, String... args) {
        System.out.println(this.i);     // wrong violation: method chain calls
        for (String arg: args) {
            System.out.println(arg);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>[java] LawOfDemeter: False positive when casting to derived class #2189</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package pmdtests;

import java.util.List;
import java.util.concurrent.ForkJoinTask;

class TaskManager {

    private final List<ForkJoinTask<Integer>> tasks;

    public void cancelTasks(ForkJoinTask<Integer> cancelTask) {
        for (ForkJoinTask<Integer> task : tasks) {
            if (!task.equals(cancelTask)) {
                task.cancel(true);
                ((SearchNumberTask) task).writeCancelMessage(); // wrong violation: method chain calls
            }
        }
    }

    abstract static class SearchNumberTask extends ForkJoinTask<Integer> {
        abstract void writeCancelMessage();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>[java] LawOfDemeter: False positive with indexed array access #2181</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public final class Util {
    public static boolean check(String passwd, String hashed) {
        try {
            final String[] parts = hashed.split("\\$");

            if (parts.length != 5 || !parts[1].equals("s0")) {      // wrong violation - method chain calls
                throw new IllegalArgumentException("Invalid hashed value");
            }
        } catch (Exception e) { }
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>FP when iterating on iterator field</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Iterator;
import java.util.List;
public final class ControlEvent {
    List<ControlEvent> controlQueue;

    // Process all events currently stored in the control queue.
    private void processControlQueue() {
        synchronized (controlQueue) {
            Iterator<ControlEvent> iter = controlQueue.iterator();
            while (iter.hasNext()) {
                ControlEvent ev = iter.next();
                pollsetCtl(ev.fd(), 0);
                if (!ev.removeOnly()) {
                    ev.setError(pollsetCtl(ev.fd(), ev.events()));
                }
                iter.remove();
            }
            controlQueue.notifyAll();
        }
    }
    void setError(Object o) {}
    boolean removeOnly() {return false;}
    Object pollsetCtl(int a, int b) {return null;}
    int fd() {return 0;}
    int events() {return 0;}
}
        ]]></code>
    </test-code>
    <test-code>
        <description>FP when iterating on collection field</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Iterator;
import java.util.List;
public final class ControlEvent {
    List<ControlEvent> controlQueue;

    private void processControlQueue() {
        synchronized (controlQueue) {
            for (ControlEvent ev: controlQueue) {
                pollsetCtl(ev.fd(), 0);
                if (!ev.removeOnly()) {
                    ev.setError(pollsetCtl(ev.fd(), ev.events()));
                }
            }
            controlQueue.notifyAll();
        }
    }
    void setError(Object o) {}
    boolean removeOnly() {return false;}
    Object pollsetCtl(int a, int b) {return null;}
    int fd() {return 0;}
    int events() {return 0;}
}
        ]]></code>
    </test-code>
    <test-code>
        <description>FP when iterating on collection param</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Iterator;
import java.util.List;
public final class ControlEvent {

    private void processControlQueue(List<ControlEvent> controlQueue) {
        synchronized (controlQueue) {
            for (ControlEvent ev: controlQueue) {
                pollsetCtl(ev.fd(), 0);
            }
            controlQueue.notifyAll();
        }
    }
    void setError(Object o) {}
    boolean removeOnly() {return false;}
    Object pollsetCtl(int a, int b) {return null;}
    int fd() {return 0;}
    int events() {return 0;}
}
        ]]></code>
    </test-code>
    <test-code>
        <description>Stackoverflow with cyclic data flow</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            import java.nio.ByteBuffer;
            import java.util.Iterator;
            import java.util.List;
            import java.io.*;

            public final class Attribute {

                void writeAttributes(int ctype, Attribute.Holder h) throws IOException {
                    ByteBuffer buf, out, bufOut;
                    for (Attribute a : h.attributes) {
                        if (a.layout() == h.attributes) {
                            DataOutputStream savedOut = out;
                            out = savedOut;
                        } else {
                            out.write(a.bytes());
                        }
                    }
                }

                class Holder {

                    Object attributes;
                }

                int fd() { return 0; }

                int events() { return 0; }
            }
            ]]></code>
    </test-code>
</test-data>
