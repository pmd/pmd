<?xml version="1.0" encoding="UTF-8"?>
<test-data
    xmlns="http://pmd.sourceforge.net/rule-tests"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/rule-tests https://pmd.github.io/schema/rule-tests_1_1_0.xsd">

    <test-code>
        <description>private method called by public method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        foo();
    }
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>simple unused private method</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>simple unused annotated private method</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import net.sourceforge.pmd.lang.java.symbols.testdata.MethodAnnotation;
public class Foo {
    @MethodAnnotation
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>anonymous inner class calls private method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        new Runnable() {
            public void run() {
                foo();
            }
        };
    }
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>two private methods with same name but different parameters</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    private void foo() {}
    private void foo(String baz) {}
    public void bar() {
        foo();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>calling private method after instantiating new copy of myself</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void foo(String[] args) {}
    public static void main(String[] args) {
        Foo u = new Foo();
        u.foo(args);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>calling private method using 'this' modifier</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        this.foo();
    }
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>simple unused private static method</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    private static void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>readResolve/writeReplace/etc are OK</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void readResolve() {}
    private void writeReplace() {}
    private void readObject() {}
    private void writeObject() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Private methods called only by themselves, BUG 1038229</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    private void bar() {
        bar();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>private with same name as public, different method signature</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar(int x) {
        bar();
    }
    private void bar() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>False +, BUG 1114754</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
   public void methodFlagged(Object[] arrayObj) {
       for(int i=0; i<arrayObj.length; i++) {
           methodFlagged(arrayObj[i]);
       }
   }
   private void methodFlagged(Object a) {
       a.toString();
   }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>called from constructor</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public Foo() {
        bar();
    }
    private void bar() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>private method with same name but diff arg count than public method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void baz() {
        int x, y;
        baz(x, y);
    }
    private void baz(int x, int y) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>static private called from initializer</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    static { foo(); }
    private static void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>static private invoked in static context - i.e., Foo.hi()</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    static boolean BUZ = Foo.bar();
    private static boolean bar() { return true; }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>private method with same name as param</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    void bar(boolean buz) {
        buz();
    }
    private void buz() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>two methods, one private, one public, same name, same arg count, diff types</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void baz() {
        foo("hi");
    }
    private void foo(String y) {}
    public void foo(Integer y) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>two private methods, only one used, same name, same arg count, diff types</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>7</expected-linenumbers>
        <expected-messages>
            <message>Avoid unused private methods such as 'foo(Integer)'.</message>
        </expected-messages>
        <code><![CDATA[
public class Foo {
    public void baz() {
        foo(getBuz());
    }
    String getBuz() {return "";}
    private void foo(String y) {}
    private void foo(Integer y) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>private method same name as local</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void baz() {
        int x = x();
    }
    private int x() { return 42;}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>SuppressWarnings("unused") - simple unused private method</description>
        <expected-problems>0</expected-problems>
        <expected-suppressions>
            <suppressor line="3">@SuppressWarnings</suppressor>
        </expected-suppressions>
        <code><![CDATA[
public class Foo {
    @SuppressWarnings("unused")
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Calling method on instance of self</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private Foo fooField;

    public void bar() {
        Foo f = new Foo();
        f.fooField.buz();
    }
    private void buz() {}
}
        ]]></code>
    </test-code>

    <test-code disabled="true">
        <description>#46 False +: Unused private field: call to instance of self, received from another class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private Foo fooField;

    public void bar() {
        Biz.getFoo().buz();
    }

    private void buz() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Calling one arg varargs method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        buz("baz");
    }
    private void buz(String... s) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Calling two arg varargs method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        buz("baz");
    }
    private void buz(String s, String... args) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Reproducing bug #1955852: false positives for UnusedPrivateMethod and UnusedLocalField</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class PMDFalsePositiveTest {
    private <T> T doSomething(Object param){
        return (T) param;
    }

    public static void main(String[] args) {
        PMDFalsePositiveTest test = new PMDFalsePositiveTest();
        Object o = "Awesome!";
        String result = test.<String>doSomething(o);
        System.out.println(result);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>verify #1156 False failure with "Avoid unused private methods"</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void endTest(final String message, final Object... params) {
    }
    public static void main(String[] args) {
        Foo f = new Foo();
        f.endTest("", (Object[]) null);
        f.endTest(format, params);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1223 UnusedPrivateMethod: Java 8 method reference causing false positives</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private static Runnable staticMethod() {
        return () -> System.out.println("run");
    }
    private Runnable doLater() {
        return () -> System.out.println("later");
    }
    private Runnable doLater2() {
        return () -> System.out.println("later");
    }

    public static void main(String[] args) {
        Runnable r1 = Foo::staticMethod;
        Runnable r2 = new Foo()::doLater;
    }
    public void doNow() {
        Runnable r3 = this::doLater2;
        r3.run();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1226 False Positive: UnusedPrivateMethod overloading with varargs</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>9</expected-linenumbers>
        <code><![CDATA[
public class Foo {
    private String s;

    public Foo() {
        s = "Foobar";
    }

    //This method isn't flagged
    private void bar(int... n)
    {
    }

    //This method is flagged
    private void bar(String s)
    {
    }

    public void dummyMethod() {
        bar(s);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (1)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import my.Model;
public class ModelAndView {
    public ModelAndView viewEntry(Model model) {
        //call private method.  Flagged Method
        return view(model, VIEW);
    }

    /** THIS IS FLAGGED AS UNUSED **/
    private ModelAndView view(Model model, String view) {
        //add values to the model

        //return the correct view
        return new ModelAndView(view, "MVC_CONSTANTS.MODEL_KEY", model.asMap());
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (2)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import my.HttpServletRequest;
import my.HttpServletResponse;
import my.ServletException;
public class ModelAndView {
    public ModelAndView showLineGraph(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        //call private method  USAGE #1.  Method not flagged
        Object filter = getGraphInnateFilter(request);

        //LINE GRAPHIC LOGIC

        //write output to response stream and return
    }

    public ModelAndView showPieChart(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        //call private method  USAGE #2.  Method not flagged
        Object filter = getGraphInnateFilter(request);

        //PIE CHART LOGIC

        //write output to response stream and return
    }

    /** This method is NOT flagged as unused **/
    private Object getGraphInnateFilter(HttpServletRequest request) {
        Object filter = new Object();

        //call private method.  Flagged method
        setInnateFilterFields(filter, request);
        //perform logic

        //return
        return filter;
    }

    /** THIS IS FLAGGED AS UNUSED **/
    private void setInnateFilterFields(Object filter, HttpServletRequest request) {
        //add values to filter object
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (3)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import my.HttpServletRequest;
import my.Model;
public class ModelAndView {
    String VIEW = "foo";

    public ModelAndView viewEntry(Model model, HttpServletRequest request, int fy) {
        return view(model, VIEW, fy);
    }

    private ModelAndView view(Model model, String view, int fy) {
        //return the correct view
        return new ModelAndView(view, "MVC_CONSTANTS.MODEL_KEY", model.asMap());
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (4)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public Foo makeUI() {
        Foo box = new Foo();
        box.add(makePanel("aaa", box));
        return box;
    }
    private static Foo makePanel(String title, Foo c) { // this is wrongly triggered
        return c;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (5a)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import javax.servlet.http.HttpServletRequest;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.DashboardGraphInnateFilter;

public class Foo {

    public DashboardGraphInnateFilter getGraphInnateFilter(HttpServletRequest request) {
        setInnateFilterFields();
        return null;
    }

    private void setInnateFilterFields() { //Not flagged
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (5b)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import javax.servlet.http.HttpServletRequest;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.DashboardGraphInnateFilter;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.DashboardInnateFilter;

public class Foo {

    public DashboardGraphInnateFilter getGraphInnateFilter(HttpServletRequest request) {
        DashboardGraphInnateFilter filter = new DashboardGraphInnateFilter();
        setInnateFilterFields(filter, request);
        return filter;
    }

    private void setInnateFilterFields(DashboardInnateFilter filter, HttpServletRequest request) { //incorrectly flagged
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1233 UnusedPrivateMethod: False positive : method called on returned object.</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Locale;

public class Test {

    public static void main(String args[]) {
        Test t = new Test();
        t.baz();
    }

    // Here we call both foo() and bar()
    public void baz() {
        foo().toLowerCase(Locale.US);
        bar().toLowerCase();
    }

    private String foo() {
        return "Hello World";
    }

    private String bar() {
        return "Hello World";
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (6)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void double_class_1(Double d) {}
    private void double_class_2(Double d) {}
    private void double_class_3(Double d) {}
    private void double_class_4(Double d) {}
    private void double_class_5(Double d) {}
    private void double_class_6(Double d) {}
    private void double_class_7(Double d) {}
    private void double_class_8(Double d) {}
    private void double_class_9(Double d) {}
    private void double_class_10(Double d) {}
    private void double_class_11(Double d) {}
    private void double_class_12(Double d) {}
    private void double_type_1(double d) {}
    private void double_type_2(double d) {}
    private void double_type_3(double d) {}
    private void double_type_4(double d) {}
    private void double_type_5(double d) {}
    private void double_type_6(double d) {}
    private void double_type_7(double d) {}
    private void double_type_8(double d) {}
    private void double_type_9(double d) {}
    private void double_type_10(double d) {}
    private void double_type_11(double d) {}
    private void double_type_12(double d) {}

    private void float_class_1(Float f) {}
    private void float_class_2(Float f) {}
    private void float_class_3(Float f) {}
    private void float_class_4(Float f) {}
    private void float_class_5(Float f) {}
    private void float_class_6(Float f) {}
    private void float_class_7(Float f) {}
    private void float_class_8(Float f) {}
    private void float_class_9(Float f) {}
    private void float_class_10(Float f) {}
    private void float_class_11(Float f) {}
    private void float_type_1(float f) {}
    private void float_type_2(float f) {}
    private void float_type_3(float f) {}
    private void float_type_4(float f) {}
    private void float_type_5(float f) {}
    private void float_type_6(float f) {}
    private void float_type_7(float f) {}
    private void float_type_8(float f) {}
    private void float_type_9(float f) {}
    private void float_type_10(float f) {}
    private void float_type_11(float f) {}

    private void int_class_1(Integer i) {}
    private void int_class_2(Integer i) {}
    private void int_class_3(Integer i) {}
    private void int_class_4(Integer i) {}
    private void int_class_5(Integer i) {}
    private void int_class_6(Integer i) {}
    private void int_class_7(Integer i) {}
    private void int_class_8(Integer i) {}
    private void int_class_9(Integer i) {}
    private void int_class_10(Integer i) {}
    private void int_class_11(Integer i) {}
    private void int_class_12(Integer i) {}
    private void int_class_13(Integer i) {}
    private void int_class_14(Integer i) {}
    private void int_type_1(int i) {}
    private void int_type_2(int i) {}
    private void int_type_3(int i) {}
    private void int_type_4(int i) {}
    private void int_type_5(int i) {}
    private void int_type_6(int i) {}
    private void int_type_7(int i) {}
    private void int_type_8(int i) {}
    private void int_type_9(int i) {}
    private void int_type_10(int i) {}
    private void int_type_11(int i) {}
    private void int_type_12(int i) {}
    private void int_type_13(int i) {}
    private void int_type_14(int i) {}
    private void int_type_15(int i) {}
    private void long_class_1(Long l) {}
    private void long_class_2(Long l) {}
    private void long_class_3(Long l) {}
    private void long_class_4(Long l) {}
    private void long_class_5(Long l) {}
    private void long_class_6(Long l) {}
    private void long_class_7(Long l) {}
    private void long_class_8(Long l) {}
    private void long_type_1(long l) {}
    private void long_type_2(long l) {}
    private void long_type_3(long l) {}
    private void long_type_4(long l) {}
    private void long_type_5(long l) {}
    private void long_type_6(long l) {}
    private void long_type_7(long l) {}
    private void long_type_8(long l) {}
    private void byte_class(Byte i) {}
    private void byte_type(byte i) {}
    private void short_class(Short s) {}
    private void short_type(short s) {}
    private void char_class_1(Character c) {}
    private void char_class_2(Character c) {}
    private void char_class_3(Character c) {}
    private void char_class_4(Character c) {}
    private void char_class_5(Character c) {}
    private void char_type_1(char c) {}
    private void char_type_2(char c) {}
    private void char_type_3(char c) {}
    private void char_type_4(char c) {}
    private void char_type_5(char c) {}


    public void test() {
        double double_value = 2.0;
        Double Double_value = 2.0;
        float float_value = 2.0f;
        Float Float_value = 2.0f;
        int int_value = 1;
        Integer Int_value = 1;
        byte byte_value = 1;
        Byte Byte_value = 1;
        short short_value = 1;
        Short Short_value = 1;
        long long_value = 1L;
        Long Long_value = 1L;
        char char_value = 'a';
        Character Char_value = 'a';

        double_class_1(2.0);
        double_class_2(double_value);
        double_class_3(Double_value);
        double_class_4((double)2.0f);
        double_class_5((double)float_value);
        double_class_6((double)Float_value);
        double_class_7((double)1);
        double_class_8((double)int_value);
        double_class_9((double)Int_value);
        double_class_10((double)1L);
        double_class_11((double)long_value);
        double_class_12((double)Long_value);
        double_type_1(2.0);
        double_type_2(double_value);
        double_type_3(Double_value);
        double_type_4(2.0f);
        double_type_5(float_value);
        double_type_6(Float_value);
        double_type_7(1);
        double_type_8(int_value);
        double_type_9(Int_value);
        double_type_10(1L);
        double_type_11(long_value);
        double_type_12(Long_value);

        float_class_1(2.0f);
        float_class_2(float_value);
        float_class_3(Float_value);
        float_class_4((float)2.0);
        float_class_5((float)double_value);
        float_class_6((float)1);
        float_class_7((float)int_value);
        float_class_8((float)Int_value);
        float_class_9((float)1L);
        float_class_10((float)long_value);
        float_class_11((float)Long_value);
        float_type_1(2.0f);
        float_type_2(float_value);
        float_type_3(Float_value);
        float_type_4((float)2.0);
        float_type_5((float)double_value);
        float_type_6(1);
        float_type_7(int_value);
        float_type_8(Int_value);
        float_type_9(1L);
        float_type_10(long_value);
        float_type_11(Long_value);

        int_class_1(1);
        int_class_2(int_value);
        int_class_3(Int_value);
        int_class_4((int)1L);
        int_class_5((int)long_value);
        int_class_6((int)1.0);
        int_class_7((int)double_value);
        int_class_8((int)1.0f);
        int_class_9((int)float_value);
        int_class_10((int)short_value);
        int_class_11((int)Short_value);
        int_class_12((int)byte_value);
        int_class_13((int)char_value);
        int_class_14((int)Char_value);
        int_type_1(1);
        int_type_2(int_value);
        int_type_3(Int_value);
        int_type_4((int)1L);
        int_type_5((int)long_value);
        int_type_6((int)1.0);
        int_type_7((int)double_value);
        int_type_8((int)1.0f);
        int_type_9((int)float_value);
        int_type_10(short_value);
        int_type_11(Short_value);
        int_type_12(byte_value);
        int_type_13(Byte_value);
        int_type_14(char_value);
        int_type_15(Char_value);

        long_class_1(1L);
        long_class_2(long_value);
        long_class_3(Long_value);
        long_class_4((long)1);
        long_class_5((long)int_value);
        long_class_6((long)Int_value);
        long_class_7((long)char_value);
        long_class_8((long)Char_value);
        long_type_1(1L);
        long_type_2(long_value);
        long_type_3(Long_value);
        long_type_4(1);
        long_type_5(int_value);
        long_type_6(Int_value);
        long_type_7(char_value);
        long_type_8(Char_value);

        byte_class((byte)1);
        byte_type(Byte_value);
        short_class((short)1);
        short_type(Short_value);

        char_class_1('a');
        char_class_2(char_value);
        char_class_3(Char_value);
        char_class_4((char)1);
        char_class_5((char)int_value);
        char_type_1('a');
        char_type_2(char_value);
        char_type_3(Char_value);
        char_type_4((char)1);
        char_type_5((char)int_value);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (7)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
class JTree {
    JTree getRoot() {return this;}
}
class TreeNode extends JTree {}

public class Box {
    interface Action { void perform(); }

    void add(Action a) {}

    private final JTree tree = new JTree();
    public void makeUI() {
        Box box = new Box();
        box.add(new Action() {
            @Override public void perform() {
                TreeNode root = (TreeNode) tree.getRoot();
                visitAll(tree, true); // line 14
            }
        });
    }
    private static void visitAll(JTree tree, boolean expand) { }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1234 Unused private methods still giving false positives in 5.1.3 snapshot</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;
import java.util.Map;
public class Foo {
    interface IListObject {}
    Map<Integer, List<IListObject>> bliCodeCache;
    public List<IListObject> getBliCodeByFiscalYear(int fiscalYear) {
       List<IListObject> records = bliCodeCache.get(fiscalYear);
        if (records == null) {
            records = this.selectBLICodeByFiscalYear(fiscalYear);
            bliCodeCache.put(fiscalYear, records);
        }
        return records;
    }

    /**
     * Get a list of All BLI Code for given fiscal year.
     * @param fy the selected FY
     * @return an List of BLI Codes
     */
    private List<IListObject> selectBLICodeByFiscalYear(int fy) {
        return null;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1156 False failure with "Avoid unused private methods" (part 2)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        int i = 1;
        String s = getBoolString(i > 0);
    }
    private String getBoolString(boolean b) {
        return b ? "TRUE" : "FALSE";
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1251 UnusedPrivateMethod false positives for boxing &amp; unboxing arguments</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethodFalsePositives {

    // UnusedPrivateMethod false positive
    private void prvUnboxing(final int i)     {}
    public  void pubUnboxing(final Integer i) {prvUnboxing(i);}

    // UnusedPrivateMethod false positive
    private void prvBoxing(final Integer i) {}
    public  void pubBoxing(final int i)     {prvBoxing(i);}

    // Correctly does not generate a warning
    private void prvPrimitive(final int i) {}
    public  void pubPrimitive(final int i) {prvPrimitive(i);}

    // Correctly does not generate a warning
    private void prvObject(final Integer i) {}
    public  void pubObject(final Integer i) {prvObject(i);}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1249 Regression: UnusedPrivateMethod from 5.0.5 to 5.1.2</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package de.friedenhagen.pmd_private;

import java.net.URI;

import org.junit.runner.Description;

/**
 * Holder object for the id in the {@link TestLink} annotation. By defining only a private constructor in this abstract
 * class and having both extending classes as inner classes, we assure nobody is able to create other extending classes.
 *
 * @param <T>
 *            of the id, either {@link Long} for internal or {@link String} for external IDs.
 *
 * @author Mirko Friedenhagen
 */
abstract class TestLinkId<T> {

    /** id of the test. */
    private final T id;

    /**
     * Private to make sure we only have {@link ExternalTestLinkId} and {@link InternalTestLinkId} as subclasses.
     *
     * @param id
     *            of the test.
     */
    private TestLinkId(final T id) {
        this.id = id;
    }

    /**
     * @return the id.
     */
    public T getId() {
        return id;
    }

    /**
     * Returns a String representation of the type of the current TestLink ID.
     *
     * @return type of the ID.
     */
    public abstract String getType();

    /** {@inheritDoc} */
    @Override
    public String toString() {
        return String.format("%s='%s'", getType(), getId());
    }

    /**
     * An external Testlink ID.
     */
    public static class ExternalTestLinkId extends TestLinkId<String> {

        /**
         * @param id
         *            of the testcase
         */
        public ExternalTestLinkId(String id) {
            super(id);
        }

        /** {@inheritDoc} */
        @Override
        public String getType() {
            return "external_id";
        }
    }

    /**
     * An internal Testlink ID.
     */
    public static class InternalTestLinkId extends TestLinkId<Long> {

        /**
         * @param id
         *            of the testcase
         */
        public InternalTestLinkId(final Long id) {
            super(id);
        }

        /** {@inheritDoc} */
        @Override
        public String getType() {
            return "id";
        }
    }
}

/**
 * Resolves links to the Testlink instance.
 *
 * @author Mirko Friedenhagen
 */
public class TestLinkUriResolver {

    /** baseUri of the Testlink instance. */
    private final URI baseUri;

    /**
     * The constructor normalizes the URI by adding a trailing slash when it is missing.
     *
     * @param baseUri
     *            without <tt>index.php</tt>, eg <tt>http://testlink.sourceforge.net/demo/</tt>.
     */
    TestLinkUriResolver(URI baseUri) {
        final String asciiUri = baseUri.toASCIIString();
        if (asciiUri.endsWith("/")) {
            this.baseUri = baseUri;
        } else {
            this.baseUri = URI.create(asciiUri + "/");
        }
    }

    /**
     * http://testlink.sourceforge.net/demo/lib/testcases/tcPrint.php?testcase_id=2750.
     *
     * @param internalTestLinkId
     *            id of the testcase
     * @return an URI pointing to the printview of the last version of the testcase description.
     */
    private URI fromTestLinkId(final TestLinkId.InternalTestLinkId internalTestLinkId) {
        return baseUri.resolve(String.format("lib/testcases/tcPrint.php?testcase_id=%s", internalTestLinkId.getId()));
    }

    /**
     * http://testlink.sourceforge.net/demo/lib/testcases/archiveData.php?targetTestCase=SM-1&edit=testcase&allowedit=0.
     *
     * @param externalTestLinkId
     *            id of the testcase
     * @return an URI pointing to the printview of the last version of the testcase description.
     */
    private URI fromTestLinkId(final TestLinkId.ExternalTestLinkId externalTestLinkId) {
        return baseUri
                .resolve(String.format("lib/testcases/archiveData.php?targetTestCase=%s&edit=testcase&allowedit=0",
                        externalTestLinkId.getId()));
    }

    /**
     * Returns a link to the last version of the testcase description.
     *
     * http://testlink.sourceforge.net/demo/lib/testcases/tcPrint.php?testcase_id=2750
     * http://testlink.sourceforge.net/demo/lib/testcases/archiveData.php?targetTestCase=SM-1&edit=testcase&allowedit=0
     *
     * @param testLinkId
     *            of the test case.
     * @return an URI pointing to the last version of the testcase description.
     */
    URI fromTestLinkId(final TestLinkId<?> testLinkId) {
        // As this class is package protected we may safely assume there only two kinds of TestLinkIds.
        if (testLinkId instanceof TestLinkId.InternalTestLinkId) {
            return fromTestLinkId((TestLinkId.InternalTestLinkId) testLinkId);
        } else {
            return fromTestLinkId((TestLinkId.ExternalTestLinkId) testLinkId);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class TestPrivate<T> {
    protected Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final Object bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 2</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;

public class TestPrivate<T extends List> {
    protected Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final List bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 3</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;

public class TestPrivate {
    protected <T extends List> Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final List bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 4</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.AbstractMap;
import java.util.Map;

public class TestPrivate {
    public <T extends Map<?,?>, X extends Map<?,?>>  void createLedgerAndChangeHistory(T oldObject, X updatedObject, boolean isChildLedgerEntry) {

        if (oldObject instanceof TestPrivate) {
            setTotals(oldObject);
        }
        // do other stuff
    }

    private <X extends Map> void setTotals(X ledgerable) {
        // do stuff
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1276 False positive in UnusedPrivateMethod when method arg is Object and not called with plain Object</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Parent {
    enum A {
        someEnum;
    }

    public void doSomethingUnqualified(A a) {
        doSomethingPrivateWithQualified(a);
    }

    private void doSomethingPrivateWithQualified(Parent.A a) {
        // PMD error because it doesn't equate Parent.A as the same type as A.
    }

    public void doSomethingQualified(Parent.A a) {
        doSomethingPrivateUnqualified(a);
    }

    private void doSomethingPrivateUnqualified(A a) {
        // PMD error because it doesn't equate Parent.A as the same type as A.
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1281 UnusedPrivateMethod incorrectly flagged for methods nested private classes</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class NestedClassPrivateMethods {
    public void doPublic() {
        doPrivate(new B());
        doPrivate2(new C());
    }

    public void doPublic(C c) {
        doPrivate3(c);
    }

    // incorrectly UnusedPrivateMethod
    private void doPrivate(I i) {}
    private void doPrivate2(I i) {}
    private void doPrivate3(I i) {}

    private interface I {
        void visit();
    }

    private class B implements I {
        public void visit() {
        }
    }

    private class C extends B {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1287 UnusedPrivateMethod returns false positives for Superclass</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class SuperClassFalsePositive {

    public void myPublicMethod() {
        throw convertToUnchecked(new MyException("Something Bad Happened"));
    }

    private IllegalArgumentException convertToUnchecked(Exception e) {
        return new IllegalArgumentException(e);
    }

    private static class MyException extends Exception {
        public MyException(String message) {
            super(message);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1286 UnusedPrivateMethod returns false positives for varags</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class VaragsFalsePositive {

    enum Sizes
    {
        TINY,
        MEDIUM
    }

    public boolean containsTiny(){
        return hasTiny(Sizes.MEDIUM, Sizes.TINY);
    }

    private boolean hasTiny(Sizes... sizes) {
        for (Sizes size : sizes) {
            if (size==Sizes.TINY) {
                return true;
            }
        }
        return false;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1294 False positive UnusedPrivateMethod with public inner enum from another class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
/**
 *
 * UnusedPrivateMethodWithEnum.java
 *
 * Copyright 2014 Expedia, Inc. All rights reserved.
 * EXPEDIA PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.ClassWithPublicEnum;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.ClassWithPublicEnum.PublicEnum;

/**
 * TODO svenz Describe UnusedPrivateMethodWithEnum
 *
 * @author <a href="mailto:svenz@expedia.com">Sven Zethelius</a>
 *
 */
public class UnusedPrivateMethodWithEnum {
        public void doPublic() {
                ClassWithPublicEnum.PublicEnum value = ClassWithPublicEnum.PublicEnum.values()[0];
                doPrivateWithShortEnum1(value);
                doPrivateWithShortEnum2(value);
        }

        private void doPrivateWithShortEnum1(PublicEnum type) {
                // do something
        }
        private void doPrivateWithShortEnum2(ClassWithPublicEnum.PublicEnum type) {
                // do something
        }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1296 PMD UnusedPrivateMethod invalid detection of 'private void method(int,boolean,Integer...)'</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethod {
    public void deleteAllAssetsWithExceptionsNoPurge(int galleryId, Integer... exceptionList)
    {
        deleteAllAssetsWithExceptions(galleryId, false, exceptionList);
    }

    public void deleteAllAssetsWithExceptions(int galleryId, Integer... exceptionList)
    {
        deleteAllAssetsWithExceptions(galleryId, true, exceptionList);
    }

    private void deleteAllAssetsWithExceptions(int galleryId, boolean purge, Integer... exceptionList)
    {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1332 False Positive: UnusedPrivateMethod</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package com.acme;

import org.junit.Test;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertThat;

public class FooTest {

    @Test
    public void testBar() {
        assertThat(createBar("", ""), containsString(""));
    }

    @Test
    public void testFoo() {
        assertThat(createFoo(""), containsString(""));
    }

    private String createFoo(String a) {
        return a;
    }

    private String createBar(String b, String c) {
        return b + c;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1395 UnusedPrivateMethod false positive for array element method call</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.File;
public class UnusedPrivateMethod {
    public void doSomething() {
        File[] files = getFiles();
        for (int i = 0; i < files.length; i++) {
            String name = getNameFromFilename(files[i].getName());
            System.out.println("name is " + name);
        }
    }

    private String getNameFromFilename(String fileName) {
        int index = fileName.lastIndexOf('.');
        return fileName.substring(0, index);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1403 False positive UnusedPrivateMethod with JAVA8</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.function.Function;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import my.Combiners;

public class Purse {

    Purse annPurse5, bobPurse7, bobPurse9, calPurse10, bobPurse16;

    public void mapMergeShouldReturnTheUnionWhenGivenDifferentSetsWithSomeCommonValues() {
        Combiners.mapMerge(mapOf(annPurse5, bobPurse7), mapOf(bobPurse9, calPurse10));
    }

    private static Map<String, Purse> mapOf(final Purse... values) {
        return mapOf2(Purse::getOwner, values);
    }

    private static <K, V> Map<K, V> mapOf2(final Function<V, K> keyMapper, final V... values) {
        return Stream.of(values).collect(Collectors.toMap(keyMapper, Function.identity()));
    }

    String getOwner() { return "me"; }

    static class Combiners {

        static <K, V> Map<K, V> mapMerge(Map<K, V> m1, Map<K, V> m2) {
            return m2;
        }
    }
}
        ]]></code>
    </test-code>

    <test-code disabled="true">
        <!-- Todo I ignored this because the test is not useful. It only checks that we
              avoid the FP when auxclasspath is not set, while the FP is still here with
              auxclasspath. The FP should not be there with or without auxclasspath, and it's
              pointless to ensure it's not there only when the user has configured
              their analysis incorrectly. -->
        <description>#1405 UnusedPrivateMethod false positive?</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[import java.util.ArrayList;
import java.util.List;
import java.util.SortedMap;

class Sup {}

public class Blabla extends Sup {
    public List<String> getProductImageUrls(final Blabla product, final String format) {
        return getImageUrlsListForVariant(product, format);
    }
    private List<String> getImageUrlsListForVariant(final Sup variant, final String format) {
    }
}
        ]]></code>
    </test-code>


    <test-code>
        <description>#521 UnusedPrivateMethod returns false positives with primitive data type in map argument</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Map;
import java.util.LinkedHashMap;
public class Foo {
    public Foo() {
        Map<String, double[]> map = new LinkedHashMap<>();
        addToMap(map);
    }

    private void addToMap(Map<String, double[]> map) {
        map.put("foo", new double[]{0., 1.});
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#907 Add IgnoredAnnotations property to UnusedPrivateMethod</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    @Deprecated
    private void bar() {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#5117 Ignore methods with jakarta.annotation.PostConstruct in UnusedPrivateMethod rule</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import jakarta.annotation.PostConstruct;
public class Foo {
    @PostConstruct
    private void bar() {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#5117 Ignore methods with jakarta.annotation.PreDestroy in UnusedPrivateMethod rule</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import jakarta.annotation.PreDestroy;
public class Foo {
    @PreDestroy
    private void bar() {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Explicit receiver parameters are ignored when matching methods</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
class Foo {
    public void bar() {
        test();
    }

    private void test(@Annotated Foo this) {
    }
    @interface Annotated {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Verify property ignoredAnnotations is used</description>
        <rule-property name="ignoredAnnotations">java.lang.Override</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    @Override // well override doesn't really make sense, but it's good enough for the test case
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Verify property ignoredAnnotations is used - 2</description>
        <rule-property name="ignoredAnnotations"></rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    @Deprecated
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1531 [java] UnusedPrivateMethod false-positive with method result</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethodFP {
    private void print(String s) { // <- unused private method?
        System.out.println(s);
    }

    public void run() {
        print(new Integer(1).toString()); // it is used here
    }

    private void print2(String s) {
        System.out.println(s);
    }

    public void run2() {
        String temp = new Integer(1).toString();
        print2(temp); // workaround with extra temporary variable
    }

    private void print3(String s) {
        System.out.println(s);
    }

    public void run3() {
        print3((String)new Integer(1).toString()); // workaround with extra cast
    }

    public void runBoolean(String s) {
        privateBooleanMethod(s, "true".equals(s));
    }

    private void privateBooleanMethod(String s, boolean isTrue) {
        System.out.println(s);
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#2454 [java] UnusedPrivateMethod violation for disabled annotation in 6.23.0</description>
        <!-- Note: weird whitespace in the property is important        -->
        <rule-property name="ignoredAnnotations">java
            .lang.Deprecated</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class OOO {
    OOO server = this;
    @Deprecated
    private void shutdown() {
        server.shutdown();
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>UnusedPrivateMethod false positive #2890</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Map;
import java.util.Collections;
import java.util.List;
public class Client {


    public void swap(Map<String, List<Integer>> optionIndexes, Object[] entries, int index1, int index2) {

        List<Integer> list1 = optionIndexes.get("option1"),
                list2 = optionIndexes.get("option2");

        sortedInsert(list1, index2);
        sortedInsert(list2, index1);
    }

    private static <T extends Comparable<? super T>> void sortedInsert(List<T> list, T value) // NOPMD: UnusedPrivateMethod: false positive
    {
        int idx = Collections.binarySearch(list, value);
        list.add(idx < 0 ? -idx - 1 : idx, value);
    }

}
        ]]></code>
    </test-code>
    <test-code>
        <description>[java] UnusedPrivateMethod false positive from inner class via external class #1189</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>4</expected-linenumbers>
        <code><![CDATA[
            public final class OuterClass {

                private static class InnerClass {
                    private void privateMethod() {} // shadows other, truly unused

                    public void callPrivateMethod() {
                        Referrer.getOuterClass().privateMethod();
                    }

                }

                private void privateMethod() {}

            }

            class Referrer {
                static OuterClass getOuterClass() { return null; }
            }
        ]]></code>
    </test-code>
    <test-code>
        <description>UnusedPrivateMethod yields false positive for counter-variant arguments #770</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            import org.junit.Test;
            import static org.junit.Assert.*;
            public final class OuterClass {

                @Test
                public void testFlipCaseDigit() {
                    testNoChangeOnFlip("0123456789");
                }

                @Test
                public void testFlipCaseWhitespace() {
                    testNoChangeOnFlip(" \r\t\n");
                }

                @Test
                public void testFlipCaseOtherChars() {
                    testNoChangeOnFlip("!@#$%^");
                }

                private static void testNoChangeOnFlip(CharSequence chars) {
                }
            }
        ]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod false positive when passing in lombok.val as argument #3118</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import lombok.val;

public class ValExample {
    public void example() {
        val example = "value";
        aPrivateMethod(example);
    }

    private void aPrivateMethod(String s) {
        System.out.println(s);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>False negative with unused private method in nested classes</description>
        <expected-problems>2</expected-problems>
        <expected-linenumbers>2,4</expected-linenumbers>
        <code><![CDATA[
public class Outer {
    private void outerUnusedMethod() {}
    public class Inner {
        private void innerUnusedMethod() {} // false negative
        private void innerUsedByInnerMethod() {}
        public void publicInnerMethod() {
            innerUsedByInnerMethod();
        }
        private void innerUsedByOuterMethod() {}
    }
    public void publicOuterMethod() {
        Inner inner = new Inner();
        inner.innerUsedByOuterMethod();
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1175 False positive with Junit 5 MethodSource</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.stream.Stream;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;

public class Outer {
    private static Stream<Arguments> basenameKeyArguments() {
        return Stream.of(
                Arguments.of("simple", "simple"),
                Arguments.of("simple", "one/two/many/simple"),
                Arguments.of("simple", "//////an/////awful/key////simple")
        );
    }

    @ParameterizedTest
    @MethodSource("basenameKeyArguments")
    void basenameKeyTest(final String expected, final String testString) {
        assertEquals(expected, NetworkTable.basenameKey(testString));
    }

}
        ]]></code>
    </test-code>

    <test-code>
        <description>#3468 UnusedPrivateMethod false positive when outer class calls private static method on inner class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class OuterClass {

    public void foo() {
        InnerClass.doSomething();
    }

    static class InnerClass {
        private static void doSomething() {}
    }
}
        ]]></code>
    </test-code> 

    <test-code>
        <description>[java] UnusedPrivateMethod false positive with static method and cast expression #3209</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedAssignmentRule {
    private static class ReachingDefsVisitor {
        private static String getVarIfUnaryAssignment(String node) {
            return null;
        }
    }
    public static class AssignmentEntry {
        final String var;
        final Object rhs;
        public boolean isUnaryReassign() {
            return rhs instanceof String
                && var.equals(ReachingDefsVisitor.getVarIfUnaryAssignment((String) rhs));
        }
    }
}
        ]]></code>
    </test-code>
    
    <test-code>
        <description>[java] UnusedPrivateMethod false positive: Autoboxing into Number #4625</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Example {

    public Example() {
        foo(2);
    }

    //src/Example.java:8:     UnusedPrivateMethod:    Avoid unused private methods such as 'foo(Number)'.
    private void foo(Number bar) {
        System.out.println(bar);
    }
}
]]></code>
    </test-code>

    <test-code>
        <description>#3467 FP when outer class has method with same name as in inner class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class OuterClass {

	private final InnerClass o = new InnerClass();

	public void foo() {
		this.o.foo();
	}

	public void notBar() {
		this.o.bar();
	}

	class InnerClass {

		private void foo() { // same name as method in OuterClass -> false positive
		}

		private void bar() { // different name than a method in OuterClass -> ok
		}
	}
}
]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod false-positive used in lambda #4817</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod;

import java.util.Collections;
import java.util.List;

import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.cache.CacheBuilder;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.cache.CacheLoader;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.cache.LoadingCache;

public class NotUsedPrivateMethodFalsePositive {

    private final LoadingCache<String, List<? extends String>> clientIdsToDps = CacheBuilder.newBuilder()
            .build(CacheLoader.from(clientId -> notCachedGetAllDps(clientId))); // unqualified call

    private List<? extends String> notCachedGetAllDps(String clientId) { // UnusedPrivateMethod:	Avoid unused private methods such as 'notCachedGetAllDps(String)'
        return Collections.singletonList(clientId);
    }

    public List<?> getClientIdsToDps() {
        return clientIdsToDps.getUnchecked("");
    }
}
]]></code>
    </test-code>

    <test-code>
        <description>#3627 FN with anonymous class</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Tester {
  Object anonymousClass = new Object() {
      private void foo() {}  // unused, should report a warning
  };
}
]]></code>
    </test-code>
    <test-code>
        <description>[java] UnusedPrivateMethod false-positive used in lambda - qualified #4817</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod;

import java.util.Collections;
import java.util.List;

import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.cache.CacheBuilder;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.cache.CacheLoader;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.cache.LoadingCache;

public class NotUsedPrivateMethodFalsePositive {

    private final LoadingCache<String, List<? extends String>> clientIdsToDps = CacheBuilder.newBuilder()
            .build(CacheLoader.from(clientId -> this.notCachedGetAllDps(clientId))); // qualified call

    private List<? extends String> notCachedGetAllDps(String clientId) { // UnusedPrivateMethod:	Avoid unused private methods such as 'notCachedGetAllDps(String)'
        return Collections.singletonList(clientId);
    }

    public List<?> getClientIdsToDps() {
        return clientIdsToDps.getUnchecked("");
    }
}
]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod false positive when using @MethodSource on a @Nested test #4975</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.ParameterizedTest;

class FooTest{
    @Nested
    class ExampleTest {

        @ParameterizedTest
        @MethodSource("getStrings")
        void exampleTestUsingPrivateMethod(
                List<String> strings) {
            // insert code
        }

        private static Stream<Arguments> getStrings() {
            Stream<Arguments> tests = Stream.of(
                    Arguments.of(List.of("TEST", "TEST_1")),
                    Arguments.of(List.of("TEST_2", "TEST_3"))
            );

            return Stream.of(tests)
                    .reduce(Stream::concat)
                    .orElseGet(Stream::empty);
        }
    }
}
]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod FP with Junit 5 @MethodSource and default factory method name #4278</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.ParameterizedTest;

class FooTest{
    private static Stream<Arguments> testGetUsername_noMethodSourceValue() {
        return Stream.of(
                Arguments.of("foo"),
                Arguments.of("bar"),
                Arguments.of("baz")
        );
    }

    @MethodSource
    @ParameterizedTest
    void testGetUsername_noMethodSourceValue(String username) {
        User sut = new User(username);

        Assertions.assertEquals(username, sut.getUsername());
    }
}
]]></code>
    </test-code>
    <test-code>
        <description>[java] UnusedPrivateMethod false-positive / method reference in combination with custom object #4985</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            import java.util.List;

            public class Main {

                public static void main(String[] args) {
                    System.out.println("list");

                    // usage of method reference in combination with a custom object leads to a false positive of PMD.UnusedPrivateMethod
                    List.of(new StringWrapper().getString())
                        .stream()

                        .map(Main::foo)
                        .filter(Objects::nonNull)
                        .toList();

                    // no false positive .. :/
                    List.of("s")
                        .stream()
                        .map(Main::foo2)
                        .filter(Objects::nonNull)
                        .toList();
                }

                private static int foo(String s) {
                    return s.length();
                }

                private static int foo2(String s) {
                    return s.length();
                }

            }
            ]]></code>
    </test-code>
    <test-code>
        <description>UnusedPrivateMethod for Generics and Overloads #5047</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            import java.util.function.Function;

            public class Main {
                public static void main(String[] args) {
                    new Utils().printValue();
                }

                public enum ConsentStatus {
                    NOT_APPLICABLE(0L),
                    NO_CONSENT(1L),
                    CONSENT(2L),
                    UNKNOWN_STATUS(3L);

                    private final long id;

                    ConsentStatus(long id) {
                        this.id = id;
                    }

                    public long id() {
                        return this.id;
                    }
                }

                public enum OptOutStatus {
                    NOT_APPLICABLE(0L),
                    OPTED_OUT(1L),
                    DID_NOT_OPT_OUT(2L),
                    UNKNOWN_STATUS(3L);

                    private final long id;

                    OptOutStatus(long id) {
                        this.id = id;
                    }

                    public long id() {
                        return this.id;
                    }
                }

                static class Utils {
                    public void printValue() {
                        System.out.println(getValue(ConsentStatus.CONSENT));
                        System.out.println(getValue(ConsentStatus.NO_CONSENT));

                        System.out.println(getValue(OptOutStatus.DID_NOT_OPT_OUT));
                        System.out.println(getValue(OptOutStatus.OPTED_OUT));
                    }

                    private Long getValue(ConsentStatus val) {
                        return getValue(val, ConsentStatus::id);
                    }

                    private Long getValue(OptOutStatus val) {
                        return getValue(val, OptOutStatus::id);
                    }

                    private <T extends Enum<T>> Long getValue(T enumValue, Function<T, Long> fn) {
                        if (enumValue == null) {
                            return null;
                        }
                        return fn.apply(enumValue);
                    }
                }
            }
            ]]></code>
    </test-code>
    <test-code>
        <description>UnusedPrivateMethod for Lombok ObtainVia #5110</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import lombok.Builder;
import lombok.Builder.ObtainVia;

import java.util.Collections;
import java.util.List;

@Builder(toBuilder = true)
public class ObtainViaTest {

    @ObtainVia(method = "fooProvider")
    private List<String> foo;

    private List<String> fooProvider() {
        return Collections.emptyList();
    }
}
            ]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod false positive when .class files missing from classpath #819</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package com.bumptech.glide.load.engine;

import com.bumptech.glide.load.Key; // key can't be resolved

class Engine {

  void load(EngineKey key) {
    logWithTimeAndKey("", key);
    loadFromActiveResources(key, true);
  }

  private static void logWithTimeAndKey(String log, Key key) { // false positive: not unused
  }

  private void loadFromActiveResources(Key key, boolean isMemoryCacheable) { // false positive: not unused
  }
}
]]></code>
    </test-code>

    <test-code>
        <description>#3633 [java] Make UnusedPrivateMethod consider enum classes</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>5</expected-linenumbers>
        <code><![CDATA[
class Impl {
  enum EnumClass {
      FOO;
      EnumClass() {}
      private void func(){};  // should report a warning here
  }
}
]]></code>
    </test-code>

    <test-code>
        <description>#3633 [java] Make UnusedPrivateMethod consider enum classes (top-level)</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>4</expected-linenumbers>
        <code><![CDATA[
enum EnumClass {
  FOO;
  EnumClass() {}
  private void func(){};  // should report a warning here
}
]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod: false positive with inner class instance method passed as a function reference parameter #3292</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package com.example;

import java.util.function.BiFunction;

public class TestUnusedPrivateMethodWithFunctionReference {

  private final String separator;

  public TestUnusedPrivateMethodWithFunctionReference(String separator) {
    this.separator = separator;
  }

  public static void main(String[] args) {
    new TestUnusedPrivateMethodWithFunctionReference("|").test();
  }

  private void test() {
    System.out.println(makeValue(Holder::combine));
  }

  private String makeValue(BiFunction<Holder, Holder, Holder> combiner) {
    return combiner.apply(new Holder("t1"), new Holder("t2")).value;
  }

  private class Holder {

    private final String value;

    public Holder(String value) {
      this.value = value;
    }

    private Holder combine(Holder other) { // false positive - not unused, used as Holder::combine
      return new Holder(value + separator + other.value);
    }
  }
}
]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod false-positive when a private method defined in an inner private class is called. #4016</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
class OuterClass {
    private final class InnerClass {
        private String readLine() { return ""; }
    }

    private InnerClass currentInner;

    public String readLine() {
        String line = currentInner.readLine();
        return line;
    }
}
]]></code>
    </test-code>

    <test-code>
        <description>#3899 [java] UnusedPrivateMethod - false positive with JDK 17</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
/*
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.issue3899;

public class PmdTestCase {
    public void check() {
        Child child = new Child();

        checkChild(child);
        checkParent(child);
    }

    // OK
    private void checkChild(Child child) {
    }

    // This method results in "UnusedPrivateMethod: Avoid unused private methods such as 'checkParent(Parent)'"
    private void checkParent(Parent parent) { // false positive
    }
}
]]></code>
    </test-code>

    <test-code>
        <description>#5324 UnusedPrivateMethod with method reference</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            package org.example.unusedPrivateMethod;

            import static java.util.Collections.emptySet;

            import java.util.*;
            import java.util.stream.*;

            public class Main {

                public static void main(String[] args) {
                    Library library = new Library(emptySet());
                    Map<String, Map<String, String>> map = new Main().run(library);
                    System.out.println(map);
                }

                private Map<String, Map<String, String>> run(Library library) {
                    return library
                            .books()
                            .stream()
                            .map(book -> book.lenders().stream().collect(Collectors.toMap(Lender::name, lender -> Map.of(book.title(), lender.status()))))
                            .reduce(this::reduceBooksAndLenderStatusByLender)
                            .orElse(null);
                }

                private Map<String, Map<String, String>> reduceBooksAndLenderStatusByLender(
                        Map<String, Map<String, String>> previousMap,
                        Map<String, Map<String, String>> nextMap
                ) {
                    previousMap.putAll(nextMap);
                    return previousMap;
                }
            }


            record Lender(String name, String status) {}
            record Book(String title, Collection<Lender> lenders) {}
            record Library(Collection<Book> books) {}
            ]]></code>
    </test-code>
    <test-code>
        <description>#5324 UnusedPrivateMethod with unresolved types</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            class Foo {
                public User methodA() {
                    val user = userOpt.orElseGet(() -> {
                        try {
                            return registerUser(email, firstName, lastName);
                        } catch (Exception e) {
                            throw new IllegalStateException("Failed to register user for " + email, e);
                        }
                    });
                    // ...
                    return user;
                }

                private User registerUser(String email, String firstName, String lastName) throws Exception {
                    // register user logic here...
                }
            }
            ]]></code>
    </test-code>
    <test-code>
        <description>#5329 UnusedPrivateMethod with unresolved types</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            class Foo {
                public User methodA() {
                    List<SummaryDto.ItemDto> items = new ArrayList<>();
                    loads.stream()
                         .collect(Collectors.groupingBy(Item::getValue))
                         .forEach((a, b) -> items.add(buildItem(a, b)));
                }

                private SummaryDto.ItemDto buildItem(BigDecimal a, List<Item> b) {
                    return SummaryDto.ItemDto.builder().build();
                }
            }
            ]]></code>
    </test-code>
    <test-code>
        <description>#5097 UnusedPrivateMethod with unresolved target for method reference</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[package com.mytest;

        import jakarta.validation.ConstraintViolation; //imported from jakarta.validation:jakarta.validation-api:3.0.2
        import java.util.List;
        import java.util.Set;

        public class UnusedPrivateMethodFalsePositive {
            //this does not trigger UnusedPrivateMethod
            private void doWork(List obj) {
                obj.toString();
            }

            public void execute(Set<List<?>> listOfLists) {
                listOfLists.forEach(this::doWork);
            }

            //BUT this does???
            //UnusedPrivateMethod -  this as a false positive - but what is different?
            private void addValidationError(ConstraintViolation constraintViolation) {
                constraintViolation.toString();
            }

            public void addValidationErrors(Set<ConstraintViolation<?>> constraintViolations) {
                constraintViolations.forEach(this::addValidationError);
            }

        }
            ]]></code>
    </test-code>
    <test-code>
        <description>#5338 UnusedPrivateMethod with unresolved target for lambda</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            import java.util.concurrent.CompletableFuture;
            class SomeTest {

                @Test
                void test() {
                    final BytesListener listener = createListener(
                            (bytes) -> CompletableFuture.completedFuture("HI!")
                    );
                    Assertions.assertNotNull(listener.onRecord(new byte[0]));
                }

                private static BytesListener createListener(
                        BytesParser<String> parser
                ) {
                    return bytes -> parser
                            .parse(bytes)
                            .thenAccept(System.out::println);
                }
            }
            ]]></code>
    </test-code>

    <test-code>
        <description>UnusedPrivateMethod #5113</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            import java.util.Optional;

            public class VarTest {
                public Optional<Boolean> foo(int param) {
                    var optional = param == 0 ? Optional.of(true) : Optional.of(false);
                    return optional.flatMap(this::dummy);
                }

                private Optional<Boolean> dummy(boolean foo) {
                    return Optional.of(foo);
                }
            }
            ]]></code>
    </test-code>
    <test-code>
        <description>UnusedPrivateMethod #5083 - method reference without target type</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            @Getter
            @RequiredArgsConstructor
            enum GenerationType {
                APPLE_DESKTOP("https://apps.apple.com/app/id", GenerationType::isAppleType),
                APPLE_ITUNES("https://itunes.apple.com/app/id", GenerationType::isAppleType),
                SAMSUNG("https://www.samsung.com/us/appstore/app/", GenerationType::isSamsungType),
                ROKU("https://channelstore.roku.com/details/", GenerationType::isRokuType),
                AMAZON("https://www.amazon.com/dp/", GenerationType::isAmazonType),
                ANDROID("https://play.google.com/store/apps/details?id=", GenerationType::isAndroidType);

                private final String baseUrl;
                private final Predicate<String> predicate;

                private static boolean isAppleType(String data) {
                    return "apple".equals(data);
                }

                private static boolean isRokuType(String data) {
                    return "roku".equals(data);
                }

                private static boolean isSamsungType(String data) {
                    return "samsung".equals(data);
                }

                private static boolean isAmazonType(String data) {
                    return "amazon".equals(data);
                }

                private static boolean isAndroidType(String data) {
                    return "android".equals(data);
                }
            }
            ]]></code>
    </test-code>

    <test-code>
        <description>UnusedPrivateMethod #5083 - method reference without target type (2)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            class GenerationType {
                static {
                    foo(GenerationType::isAndroidType);
                }
                {
                    foo(this::instance);
                }

                private  boolean instance(String data) {}
                private static boolean isAndroidType(String data) {
                    return "android".equals(data);
                }
            }
            ]]></code>
    </test-code>

    <test-code>
        <description>#4861 [java] UnusedPrivateMethod - false positive with static methods in core JDK classes</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            package java.lang;
            class Integer {
                static {
                    toStringUTF16(1, 2);
                }
                private static String toStringUTF16(int i, int j) {}
            }
            ]]></code>
    </test-code>

    <test-code>
        <description>#5486 [java] UnusedPrivateMethod detected when class is referenced in another class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
/*
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.issue5486;

public class Class1 {
    public void publicMethod() {
        new Class2().getClass1().privateMethod();
    }

    private void privateMethod() { // This method is detected as UnusedPrivateMethod (false positive)
        // do stuff
    }

    public void publicMethod2() {
        // Declaring the variable, makes the PMD works fine (workaround)
        Class1 class1 = new Class2().getClass1();
        class1.privateMethod2();
    }

    private void privateMethod2() {
        // do stuff
    }
}
]]></code>
    </test-code>

    <test-code>
        <description>#3359 [java] UnusedPrivateMethod does not recognize Lombok @EqualsAndHashCode.Include annotation</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import lombok.EqualsAndHashCode;

@EqualsAndHashCode
public class Foo {

  @EqualsAndHashCode.Exclude
  private BigDecimal bar;

  @EqualsAndHashCode.Include
  private BigDecimal getBarValueForEqAndHc() { // false positive UnusedMethod
    return bar != null ? bar.stripTrailingZeros() : null;
  }
}
]]></code>
    </test-code>

    <test-code>
        <description>Problem with capture of type parameter that has wildcard parameterized bound</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            class AJjtN<N, B> {}
            class JavaccToken {}
            public final class JjtreeBuilder<N extends AJjtN<N, ?>> {


                public void closeNodeScope(N n, boolean condition, JavaccToken lastToken) {
                    closeImpl(n, lastToken);
                }


                private void closeImpl(N n, JavaccToken lastToken) {

                }
            }
            ]]></code>
    </test-code>

    <test-code>
        <description>#5369 [java] UnusedPrivateMethod false positives with lombok.val</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package sample;

import lombok.val; // note: we have this under src/test/java/lombok/val.java on the auxclasspath during test

class Foo {
  public void method() {
     val test = "a";

     privateMethod(test);
  }

  private void privateMethod(String a) {
    System.out.println(a);
  }
}
]]></code>
    </test-code>

    <test-code>
        <description>#5687 [java] UnusedPrivateMethodRule: exclude serialization method readObjectNoData()</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.ObjectStreamException;
public class Foo {
    private void readObjectNoData() throws ObjectStreamException {}
}
]]></code>
    </test-code>

    <test-code>
        <description>#5621 [java] UnusedPrivateMethod false positives with method ref</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package sample;

import java.util.Optional;
import java.io.*;
import java.util.Base64;
import java.net.InetSocketAddress;

class Foo {

    public String foo(final Object foo, final String bar) {
        final String abc = Optional.ofNullable(foo.toString()).map(Foo::getNormalizedAddress).orElse(null);
        return abc;
    }

    private static String getNormalizedAddress(final String encoded) {
        try (var objectInputStream = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(encoded)))) {
            final var inetSocketAddress = (InetSocketAddress) objectInputStream.readObject();
            return inetSocketAddress.toString().substring(1);
        } catch (IOException | ClassNotFoundException | IllegalArgumentException e) {
            return null;
        }
    }

}
]]></code>
    </test-code>

    <test-code>
        <description>#5621 [java] UnusedPrivateMethod false positives with method ref, #2</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package sample;

import java.util.Collection;
import java.util.List;
import java.util.function.Consumer;
import java.io.*;
import java.util.Base64;
import java.net.InetSocketAddress;

class Foo {
    @Override
    public Collection<Consumer<Router>> routes() {
        return List.of(
                r -> r.post("/some/path").handler(this::handleRequest)
        );
    }

    private void handleRequest(RoutingContext rc) { }
    private void handleRequest(String rc) { }
}
]]></code>
    </test-code>


    <test-code>
        <description>Verify that if the method ref is obviously in another class our methods are still flagged</description>
        <expected-problems>4</expected-problems>
        <expected-messages>
            <message>Avoid unused private methods such as 'alala(RoutingContext)'.</message>
            <message>Avoid unused private methods such as 'alala(String)'.</message>
            <message>Avoid unused private methods such as 'elelel(RoutingContext)'.</message>
            <message>Avoid unused private methods such as 'elelel(String)'.</message>
        </expected-messages>
        <code><![CDATA[
package sample;

import java.util.Collection;
import java.util.List;
import java.util.function.Consumer;
import java.io.*;
import java.util.Base64;
import java.net.InetSocketAddress;

import foo.Bar;

class Foo {
    @Override
    public Collection<Consumer<Router>> routes() {
        return List.of(
                // Other is an ambiguous name and it may be var or type,
                // therefore it has a fully unknown type
                r -> r.post("/some/path").handler(Other::handleRequest) 
        );
        return List.of(
                // This is an unresolved type but unambiguous thanks to the
                // import. That means we know that Bar::alala cannot
                // be a reference to one of Foo's alala methods.
                r -> r.post("/some/path").handler(Bar::alala)
        );
        return List.of(
                // This is a fully known type, same thing
                r -> r.post("/some/path").handler(String::elelel)
        );
    }

    private void handleRequest(RoutingContext rc) { }
    private void handleRequest(String rc) { }
    
    private void alala(RoutingContext rc) { }
    private void alala(String rc) { }
    
    private void elelel(RoutingContext rc) { }
    private void elelel(String rc) { }
}
]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod false-positive #5664 (not reproducible)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            @ExtendWith(MockitoExtension.class)
            class TimeProfilerTests {
                @Nested
                class operations_test {
                    private final long[] offset = {0L};

                    private static Long offsetTimeSupplier(final long[] offset) {
                        return offset[0];
                    }

                    @BeforeEach
                    void setUp() {
                        offset[0] = offsetTimeSupplier(offset);
                    }
                }
            }
            ]]></code>
    </test-code>


    <test-code>
        <description>FP with lambda</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            // should reproduce https://github.com/pmd/pmd/issues/5621#issuecomment-2849411551
            class Test {
                class operations_test {

                    void method(long l) {
                    }
                    void method() {}

                    void setUp() {
                        foo(unresolved -> {
                            method(unresolved);
                        });
                    }
                }
            }
            ]]></code>
    </test-code>


    <test-code>
        <description>addAllImpl</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import static com.google.common.collect.CollectPreconditions.checkRemove;
import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.util.Arrays.asList;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Multiset.Entry;
import com.google.common.math.IntMath;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.InlineMe;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.function.ToIntFunction;
import java.util.stream.Collector;
import org.jspecify.annotations.Nullable;

/**
 * Provides static utility methods for creating and working with {@link Multiset} instances.
 *
 * <p>See the Guava User Guide article on <a href=
 * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets">{@code
 * Multisets}</a>.
 *
 * @author Kevin Bourrillion
 * @author Mike Bostock
 * @author Louis Wasserman
 * @since 2.0
 */
@GwtCompatible
public final class Multisets {
  private Multisets() {}

  /**
   * Returns a {@code Collector} that accumulates elements into a multiset created via the specified
   * {@code Supplier}, whose elements are the result of applying {@code elementFunction} to the
   * inputs, with counts equal to the result of applying {@code countFunction} to the inputs.
   * Elements are added in encounter order.
   *
   * <p>If the mapped elements contain duplicates (according to {@link Object#equals}), the element
   * will be added more than once, with the count summed over all appearances of the element.
   *
   * <p>Note that {@code stream.collect(toMultiset(function, e -> 1, supplier))} is equivalent to
   * {@code stream.map(function).collect(Collectors.toCollection(supplier))}.
   *
   * <p>To collect to an {@link ImmutableMultiset}, use {@link
   * ImmutableMultiset#toImmutableMultiset}.
   *
   * @since 22.0
   */
  public static <T extends @Nullable Object, E extends @Nullable Object, M extends Multiset<E>>
      Collector<T, ?, M> toMultiset(
          Function<? super T, E> elementFunction,
          ToIntFunction<? super T> countFunction,
          Supplier<M> multisetSupplier) {
    return CollectCollectors.toMultiset(elementFunction, countFunction, multisetSupplier);
  }

  /**
   * Returns an unmodifiable view of the specified multiset. Query operations on the returned
   * multiset "read through" to the specified multiset, and attempts to modify the returned multiset
   * result in an {@link UnsupportedOperationException}.
   *
   * <p>The returned multiset will be serializable if the specified multiset is serializable.
   *
   * @param multiset the multiset for which an unmodifiable view is to be generated
   * @return an unmodifiable view of the multiset
   */
  public static <E extends @Nullable Object> Multiset<E> unmodifiableMultiset(
      Multiset<? extends E> multiset) {
    if (multiset instanceof UnmodifiableMultiset || multiset instanceof ImmutableMultiset) {
      @SuppressWarnings("unchecked") // Since it's unmodifiable, the covariant cast is safe
      Multiset<E> result = (Multiset<E>) multiset;
      return result;
    }
    return new UnmodifiableMultiset<>(checkNotNull(multiset));
  }

  /**
   * Simply returns its argument.
   *
   * @deprecated no need to use this
   * @since 10.0
   */
  @InlineMe(
      replacement = "checkNotNull(multiset)",
      staticImports = "com.google.common.base.Preconditions.checkNotNull")
  @Deprecated
  public static <E> Multiset<E> unmodifiableMultiset(ImmutableMultiset<E> multiset) {
    return checkNotNull(multiset);
  }

  static class UnmodifiableMultiset<E extends @Nullable Object> extends ForwardingMultiset<E>
      implements Serializable {
    final Multiset<? extends E> delegate;

    UnmodifiableMultiset(Multiset<? extends E> delegate) {
      this.delegate = delegate;
    }

    @SuppressWarnings("unchecked")
    @Override
    protected Multiset<E> delegate() {
      // This is safe because all non-covariant methods are overridden
      return (Multiset<E>) delegate;
    }

    @LazyInit transient @Nullable Set<E> elementSet;

    Set<E> createElementSet() {
      return Collections.<E>unmodifiableSet(delegate.elementSet());
    }

    @Override
    public Set<E> elementSet() {
      Set<E> es = elementSet;
      return (es == null) ? elementSet = createElementSet() : es;
    }

    @LazyInit transient @Nullable Set<Multiset.Entry<E>> entrySet;

    @SuppressWarnings("unchecked")
    @Override
    public Set<Multiset.Entry<E>> entrySet() {
      Set<Multiset.Entry<E>> es = entrySet;
      return (es == null)
          // Safe because the returned set is made unmodifiable and Entry
          // itself is readonly
          ? entrySet = (Set) Collections.unmodifiableSet(delegate.entrySet())
          : es;
    }

    @Override
    public Iterator<E> iterator() {
      return Iterators.<E>unmodifiableIterator(delegate.iterator());
    }

    @Override
    public boolean add(@ParametricNullness E element) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int add(@ParametricNullness E element, int occurrences) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean addAll(Collection<? extends E> elementsToAdd) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean remove(@Nullable Object element) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int remove(@Nullable Object element, int occurrences) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean removeAll(Collection<?> elementsToRemove) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean removeIf(java.util.function.Predicate<? super E> filter) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean retainAll(Collection<?> elementsToRetain) {
      throw new UnsupportedOperationException();
    }

    @Override
    public void clear() {
      throw new UnsupportedOperationException();
    }

    @Override
    public int setCount(@ParametricNullness E element, int count) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
      throw new UnsupportedOperationException();
    }

    @GwtIncompatible @J2ktIncompatible private static final long serialVersionUID = 0;
  }

  /**
   * Returns an unmodifiable view of the specified sorted multiset. Query operations on the returned
   * multiset "read through" to the specified multiset, and attempts to modify the returned multiset
   * result in an {@link UnsupportedOperationException}.
   *
   * <p>The returned multiset will be serializable if the specified multiset is serializable.
   *
   * @param sortedMultiset the sorted multiset for which an unmodifiable view is to be generated
   * @return an unmodifiable view of the multiset
   * @since 11.0
   */
  public static <E extends @Nullable Object> SortedMultiset<E> unmodifiableSortedMultiset(
      SortedMultiset<E> sortedMultiset) {
    // it's in its own file so it can be emulated for GWT
    return new UnmodifiableSortedMultiset<>(checkNotNull(sortedMultiset));
  }

  /**
   * Returns an immutable multiset entry with the specified element and count. The entry will be
   * serializable if {@code e} is.
   *
   * @param e the element to be associated with the returned entry
   * @param n the count to be associated with the returned entry
   * @throws IllegalArgumentException if {@code n} is negative
   */
  public static <E extends @Nullable Object> Multiset.Entry<E> immutableEntry(
      @ParametricNullness E e, int n) {
    return new ImmutableEntry<>(e, n);
  }

  static class ImmutableEntry<E extends @Nullable Object> extends AbstractEntry<E>
      implements Serializable {
    @ParametricNullness private final E element;
    private final int count;

    ImmutableEntry(@ParametricNullness E element, int count) {
      this.element = element;
      this.count = count;
      checkNonnegative(count, "count");
    }

    @Override
    @ParametricNullness
    public final E getElement() {
      return element;
    }

    @Override
    public final int getCount() {
      return count;
    }

    public @Nullable ImmutableEntry<E> nextInBucket() {
      return null;
    }

    @GwtIncompatible @J2ktIncompatible private static final long serialVersionUID = 0;
  }

  /**
   * Returns a view of the elements of {@code unfiltered} that satisfy a predicate. The returned
   * multiset is a live view of {@code unfiltered}; changes to one affect the other.
   *
   * <p>The resulting multiset's iterators, and those of its {@code entrySet()} and {@code
   * elementSet()}, do not support {@code remove()}. However, all other multiset methods supported
   * by {@code unfiltered} are supported by the returned multiset. When given an element that
   * doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods throw
   * an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and {@code
   * clear()} are called on the filtered multiset, only elements that satisfy the filter will be
   * removed from the underlying multiset.
   *
   * <p>The returned multiset isn't threadsafe or serializable, even if {@code unfiltered} is.
   *
   * <p>Many of the filtered multiset's methods, such as {@code size()}, iterate across every
   * element in the underlying multiset and determine which elements satisfy the filter. When a live
   * view is <i>not</i> needed, it may be faster to copy the returned multiset and use the copy.
   *
   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at
   * {@link Predicate#apply}. Do not provide a predicate such as {@code
   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
   * Iterables#filter(Iterable, Class)} for related functionality.)
   *
   * @since 14.0
   */
  public static <E extends @Nullable Object> Multiset<E> filter(
      Multiset<E> unfiltered, Predicate<? super E> predicate) {
    if (unfiltered instanceof FilteredMultiset) {
      // Support clear(), removeAll(), and retainAll() when filtering a filtered
      // collection.
      FilteredMultiset<E> filtered = (FilteredMultiset<E>) unfiltered;
      Predicate<E> combinedPredicate = Predicates.and(filtered.predicate, predicate);
      return new FilteredMultiset<>(filtered.unfiltered, combinedPredicate);
    }
    return new FilteredMultiset<>(unfiltered, predicate);
  }

  private static final class FilteredMultiset<E extends @Nullable Object> extends ViewMultiset<E> {
    final Multiset<E> unfiltered;
    final Predicate<? super E> predicate;

    FilteredMultiset(Multiset<E> unfiltered, Predicate<? super E> predicate) {
      this.unfiltered = checkNotNull(unfiltered);
      this.predicate = checkNotNull(predicate);
    }

    @Override
    public UnmodifiableIterator<E> iterator() {
      return Iterators.filter(unfiltered.iterator(), predicate);
    }

    @Override
    Set<E> createElementSet() {
      return Sets.filter(unfiltered.elementSet(), predicate);
    }

    @Override
    Iterator<E> elementIterator() {
      throw new AssertionError("should never be called");
    }

    @Override
    Set<Entry<E>> createEntrySet() {
      return Sets.filter(unfiltered.entrySet(), entry -> predicate.apply(entry.getElement()));
    }

    @Override
    Iterator<Entry<E>> entryIterator() {
      throw new AssertionError("should never be called");
    }

    @Override
    public int count(@Nullable Object element) {
      int count = unfiltered.count(element);
      if (count > 0) {
        @SuppressWarnings("unchecked") // element is equal to an E
        E e = (E) element;
        return predicate.apply(e) ? count : 0;
      }
      return 0;
    }

    @Override
    public int add(@ParametricNullness E element, int occurrences) {
      checkArgument(
          predicate.apply(element), "Element %s does not match predicate %s", element, predicate);
      return unfiltered.add(element, occurrences);
    }

    @Override
    public int remove(@Nullable Object element, int occurrences) {
      checkNonnegative(occurrences, "occurrences");
      if (occurrences == 0) {
        return count(element);
      } else {
        return contains(element) ? unfiltered.remove(element, occurrences) : 0;
      }
    }
  }

  /**
   * Returns the expected number of distinct elements given the specified elements. The number of
   * distinct elements is only computed if {@code elements} is an instance of {@code Multiset};
   * otherwise the default value of 11 is returned.
   */
  static int inferDistinctElements(Iterable<?> elements) {
    if (elements instanceof Multiset) {
      return ((Multiset<?>) elements).elementSet().size();
    }
    return 11; // initial capacity will be rounded up to 16
  }

  /**
   * Returns an unmodifiable view of the union of two multisets. In the returned multiset, the count
   * of each element is the <i>maximum</i> of its counts in the two backing multisets. The iteration
   * order of the returned multiset matches that of the element set of {@code multiset1} followed by
   * the members of the element set of {@code multiset2} that are not contained in {@code
   * multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  public static <E extends @Nullable Object> Multiset<E> union(
      Multiset<? extends E> multiset1, Multiset<? extends E> multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    return new ViewMultiset<E>() {
      @Override
      public boolean contains(@Nullable Object element) {
        return multiset1.contains(element) || multiset2.contains(element);
      }

      @Override
      public boolean isEmpty() {
        return multiset1.isEmpty() && multiset2.isEmpty();
      }

      @Override
      public int count(@Nullable Object element) {
        return max(multiset1.count(element), multiset2.count(element));
      }

      @Override
      Set<E> createElementSet() {
        return Sets.union(multiset1.elementSet(), multiset2.elementSet());
      }

      @Override
      Iterator<E> elementIterator() {
        throw new AssertionError("should never be called");
      }

      @Override
      Iterator<Entry<E>> entryIterator() {
        Iterator<? extends Entry<? extends E>> iterator1 = multiset1.entrySet().iterator();
        Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();
        // TODO(lowasser): consider making the entries live views
        return new AbstractIterator<Entry<E>>() {
          @Override
          protected @Nullable Entry<E> computeNext() {
            if (iterator1.hasNext()) {
              Entry<? extends E> entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = max(entry1.getCount(), multiset2.count(element));
              return immutableEntry(element, count);
            }
            while (iterator2.hasNext()) {
              Entry<? extends E> entry2 = iterator2.next();
              E element = entry2.getElement();
              if (!multiset1.contains(element)) {
                return immutableEntry(element, entry2.getCount());
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the intersection of two multisets. In the returned multiset,
   * the count of each element is the <i>minimum</i> of its counts in the two backing multisets,
   * with elements that would have a count of 0 not included. The iteration order of the returned
   * multiset matches that of the element set of {@code multiset1}, with repeated occurrences of the
   * same element appearing consecutively.
   *
   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 2.0
   */
  public static <E extends @Nullable Object> Multiset<E> intersection(
      Multiset<E> multiset1, Multiset<?> multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    return new ViewMultiset<E>() {
      @Override
      public int count(@Nullable Object element) {
        int count1 = multiset1.count(element);
        return (count1 == 0) ? 0 : min(count1, multiset2.count(element));
      }

      @Override
      Set<E> createElementSet() {
        return Sets.intersection(multiset1.elementSet(), multiset2.elementSet());
      }

      @Override
      Iterator<E> elementIterator() {
        throw new AssertionError("should never be called");
      }

      @Override
      Iterator<Entry<E>> entryIterator() {
        Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();
        // TODO(lowasser): consider making the entries live views
        return new AbstractIterator<Entry<E>>() {
          @Override
          protected @Nullable Entry<E> computeNext() {
            while (iterator1.hasNext()) {
              Entry<E> entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = min(entry1.getCount(), multiset2.count(element));
              if (count > 0) {
                return immutableEntry(element, count);
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the sum of two multisets. In the returned multiset, the count
   * of each element is the <i>sum</i> of its counts in the two backing multisets. The iteration
   * order of the returned multiset matches that of the element set of {@code multiset1} followed by
   * the members of the element set of {@code multiset2} that are not contained in {@code
   * multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  public static <E extends @Nullable Object> Multiset<E> sum(
      Multiset<? extends E> multiset1, Multiset<? extends E> multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    // TODO(lowasser): consider making the entries live views
    return new ViewMultiset<E>() {
      @Override
      public boolean contains(@Nullable Object element) {
        return multiset1.contains(element) || multiset2.contains(element);
      }

      @Override
      public boolean isEmpty() {
        return multiset1.isEmpty() && multiset2.isEmpty();
      }

      @Override
      public int size() {
        return IntMath.saturatedAdd(multiset1.size(), multiset2.size());
      }

      @Override
      public int count(@Nullable Object element) {
        return multiset1.count(element) + multiset2.count(element);
      }

      @Override
      Set<E> createElementSet() {
        return Sets.union(multiset1.elementSet(), multiset2.elementSet());
      }

      @Override
      Iterator<E> elementIterator() {
        throw new AssertionError("should never be called");
      }

      @Override
      Iterator<Entry<E>> entryIterator() {
        Iterator<? extends Entry<? extends E>> iterator1 = multiset1.entrySet().iterator();
        Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();
        return new AbstractIterator<Entry<E>>() {
          @Override
          protected @Nullable Entry<E> computeNext() {
            if (iterator1.hasNext()) {
              Entry<? extends E> entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = entry1.getCount() + multiset2.count(element);
              return immutableEntry(element, count);
            }
            while (iterator2.hasNext()) {
              Entry<? extends E> entry2 = iterator2.next();
              E element = entry2.getElement();
              if (!multiset1.contains(element)) {
                return immutableEntry(element, entry2.getCount());
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the difference of two multisets. In the returned multiset, the
   * count of each element is the result of the <i>zero-truncated subtraction</i> of its count in
   * the second multiset from its count in the first multiset, with elements that would have a count
   * of 0 not included. The iteration order of the returned multiset matches that of the element set
   * of {@code multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  public static <E extends @Nullable Object> Multiset<E> difference(
      Multiset<E> multiset1, Multiset<?> multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    // TODO(lowasser): consider making the entries live views
    return new ViewMultiset<E>() {
      @Override
      public int count(@Nullable Object element) {
        int count1 = multiset1.count(element);
        return (count1 == 0) ? 0 : max(0, count1 - multiset2.count(element));
      }

      @Override
      public void clear() {
        throw new UnsupportedOperationException();
      }

      @Override
      Iterator<E> elementIterator() {
        Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();
        return new AbstractIterator<E>() {
          @Override
          protected @Nullable E computeNext() {
            while (iterator1.hasNext()) {
              Entry<E> entry1 = iterator1.next();
              E element = entry1.getElement();
              if (entry1.getCount() > multiset2.count(element)) {
                return element;
              }
            }
            return endOfData();
          }
        };
      }

      @Override
      Iterator<Entry<E>> entryIterator() {
        Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();
        return new AbstractIterator<Entry<E>>() {
          @Override
          protected @Nullable Entry<E> computeNext() {
            while (iterator1.hasNext()) {
              Entry<E> entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = entry1.getCount() - multiset2.count(element);
              if (count > 0) {
                return immutableEntry(element, count);
              }
            }
            return endOfData();
          }
        };
      }

      @Override
      int distinctElements() {
        return Iterators.size(entryIterator());
      }
    };
  }

  /**
   * Returns {@code true} if {@code subMultiset.count(o) <= superMultiset.count(o)} for all {@code
   * o}.
   *
   * @since 10.0
   */
  @CanIgnoreReturnValue
  public static boolean containsOccurrences(Multiset<?> superMultiset, Multiset<?> subMultiset) {
    checkNotNull(superMultiset);
    checkNotNull(subMultiset);
    for (Entry<?> entry : subMultiset.entrySet()) {
      int superCount = superMultiset.count(entry.getElement());
      if (superCount < entry.getCount()) {
        return false;
      }
    }
    return true;
  }

  /**
   * Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code
   * multisetToRetain.count(e)}.
   *
   * <p>To be precise, {@code multisetToModify.count(e)} is set to {@code
   * Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link
   * #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},
   * but mutates {@code multisetToModify} instead of returning a view.
   *
   * <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of
   * elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all
   * other elements.
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 10.0
   */
  @CanIgnoreReturnValue
  public static boolean retainOccurrences(
      Multiset<?> multisetToModify, Multiset<?> multisetToRetain) {
    return retainOccurrencesImpl(multisetToModify, multisetToRetain);
  }

  /** Delegate implementation which cares about the element type. */
  private static <E extends @Nullable Object> boolean retainOccurrencesImpl(
      Multiset<E> multisetToModify, Multiset<?> occurrencesToRetain) {
    checkNotNull(multisetToModify);
    checkNotNull(occurrencesToRetain);
    // Avoiding ConcurrentModificationExceptions is tricky.
    Iterator<Entry<E>> entryIterator = multisetToModify.entrySet().iterator();
    boolean changed = false;
    while (entryIterator.hasNext()) {
      Entry<E> entry = entryIterator.next();
      int retainCount = occurrencesToRetain.count(entry.getElement());
      if (retainCount == 0) {
        entryIterator.remove();
        changed = true;
      } else if (retainCount < entry.getCount()) {
        multisetToModify.setCount(entry.getElement(), retainCount);
        changed = true;
      }
    }
    return changed;
  }

  /**
   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one
   * occurrence of {@code e} in {@code multisetToModify}.
   *
   * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code
   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -
   * Iterables.frequency(occurrencesToRemove, e))}.
   *
   * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll
   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear
   * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit
   * sometimes more efficient than, the following:
   *
   * {@snippet :
   * for (E e : occurrencesToRemove) {
   *   multisetToModify.remove(e);
   * }
   * }
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code
   *     Multiset})
   */
  @CanIgnoreReturnValue
  public static boolean removeOccurrences(
      Multiset<?> multisetToModify, Iterable<?> occurrencesToRemove) {
    if (occurrencesToRemove instanceof Multiset) {
      return removeOccurrences(multisetToModify, (Multiset<?>) occurrencesToRemove);
    } else {
      checkNotNull(multisetToModify);
      checkNotNull(occurrencesToRemove);
      boolean changed = false;
      for (Object o : occurrencesToRemove) {
        changed |= multisetToModify.remove(o);
      }
      return changed;
    }
  }

  /**
   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one
   * occurrence of {@code e} in {@code multisetToModify}.
   *
   * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code
   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -
   * occurrencesToRemove.count(e))}.
   *
   * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll
   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear
   * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit
   * sometimes more efficient than, the following:
   *
   * {@snippet :
   * for (E e : occurrencesToRemove) {
   *   multisetToModify.remove(e);
   * }
   * }
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 10.0 (missing in 18.0 when only the overload taking an {@code Iterable} was present)
   */
  @CanIgnoreReturnValue
  public static boolean removeOccurrences(
      Multiset<?> multisetToModify, Multiset<?> occurrencesToRemove) {
    checkNotNull(multisetToModify);
    checkNotNull(occurrencesToRemove);

    boolean changed = false;
    Iterator<? extends Entry<?>> entryIterator = multisetToModify.entrySet().iterator();
    while (entryIterator.hasNext()) {
      Entry<?> entry = entryIterator.next();
      int removeCount = occurrencesToRemove.count(entry.getElement());
      if (removeCount >= entry.getCount()) {
        entryIterator.remove();
        changed = true;
      } else if (removeCount > 0) {
        multisetToModify.remove(entry.getElement(), removeCount);
        changed = true;
      }
    }
    return changed;
  }

  /**
   * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@link
   * Multiset.Entry}.
   */
  abstract static class AbstractEntry<E extends @Nullable Object> implements Multiset.Entry<E> {
    /**
     * Indicates whether an object equals this entry, following the behavior specified in {@link
     * Multiset.Entry#equals}.
     */
    @Override
    public boolean equals(@Nullable Object object) {
      if (object instanceof Multiset.Entry) {
        Multiset.Entry<?> that = (Multiset.Entry<?>) object;
        return this.getCount() == that.getCount()
            && Objects.equals(this.getElement(), that.getElement());
      }
      return false;
    }

    /**
     * Return this entry's hash code, following the behavior specified in {@link
     * Multiset.Entry#hashCode}.
     */
    @Override
    public int hashCode() {
      E e = getElement();
      return ((e == null) ? 0 : e.hashCode()) ^ getCount();
    }

    /**
     * Returns a string representation of this multiset entry. The string representation consists of
     * the associated element if the associated count is one, and otherwise the associated element
     * followed by the characters " x " (space, x and space) followed by the count. Elements and
     * counts are converted to strings as by {@code String.valueOf}.
     */
    @Override
    public String toString() {
      String text = String.valueOf(getElement());
      int n = getCount();
      return (n == 1) ? text : (text + " x " + n);
    }
  }

  /** An implementation of {@link Multiset#equals}. */
  static boolean equalsImpl(Multiset<?> multiset, @Nullable Object object) {
    if (object == multiset) {
      return true;
    }
    if (object instanceof Multiset) {
      Multiset<?> that = (Multiset<?>) object;
      /*
       * We can't simply check whether the entry sets are equal, since that
       * approach fails when a TreeMultiset has a comparator that returns 0
       * when passed unequal elements.
       */

      if (multiset.size() != that.size() || multiset.entrySet().size() != that.entrySet().size()) {
        return false;
      }
      for (Entry<?> entry : that.entrySet()) {
        if (multiset.count(entry.getElement()) != entry.getCount()) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  /** An implementation of {@link Multiset#addAll}. */
  static <E extends @Nullable Object> boolean addAllImpl(
      Multiset<E> self, Collection<? extends E> elements) {
    checkNotNull(self);
    checkNotNull(elements);
    if (elements instanceof Multiset) {
      return addAllImpl(self, (Multiset<? extends E>) elements);
    } else if (elements.isEmpty()) {
      return false;
    } else {
      return Iterators.addAll(self, elements.iterator());
    }
  }

  /** A specialization of {@code addAllImpl} for when {@code elements} is itself a Multiset. */
  private static <E extends @Nullable Object> boolean addAllImpl(
      Multiset<E> self, Multiset<? extends E> elements) {
    if (elements.isEmpty()) {
      return false;
    }
    elements.forEachEntry(self::add);
    return true;
  }

  /** An implementation of {@link Multiset#removeAll}. */
  static boolean removeAllImpl(Multiset<?> self, Collection<?> elementsToRemove) {
    Collection<?> collection =
        (elementsToRemove instanceof Multiset)
            ? ((Multiset<?>) elementsToRemove).elementSet()
            : elementsToRemove;

    return self.elementSet().removeAll(collection);
  }

  /** An implementation of {@link Multiset#retainAll}. */
  static boolean retainAllImpl(Multiset<?> self, Collection<?> elementsToRetain) {
    checkNotNull(elementsToRetain);
    Collection<?> collection =
        (elementsToRetain instanceof Multiset)
            ? ((Multiset<?>) elementsToRetain).elementSet()
            : elementsToRetain;

    return self.elementSet().retainAll(collection);
  }

  /** An implementation of {@link Multiset#setCount(Object, int)}. */
  static <E extends @Nullable Object> int setCountImpl(
      Multiset<E> self, @ParametricNullness E element, int count) {
    checkNonnegative(count, "count");

    int oldCount = self.count(element);

    int delta = count - oldCount;
    if (delta > 0) {
      self.add(element, delta);
    } else if (delta < 0) {
      self.remove(element, -delta);
    }

    return oldCount;
  }

  /** An implementation of {@link Multiset#setCount(Object, int, int)}. */
  static <E extends @Nullable Object> boolean setCountImpl(
      Multiset<E> self, @ParametricNullness E element, int oldCount, int newCount) {
    checkNonnegative(oldCount, "oldCount");
    checkNonnegative(newCount, "newCount");

    if (self.count(element) == oldCount) {
      self.setCount(element, newCount);
      return true;
    } else {
      return false;
    }
  }

  static <E extends @Nullable Object> Iterator<E> elementIterator(
      Iterator<Entry<E>> entryIterator) {
    return new TransformedIterator<Entry<E>, E>(entryIterator) {
      @Override
      @ParametricNullness
      E transform(Entry<E> entry) {
        return entry.getElement();
      }
    };
  }

  abstract static class ElementSet<E extends @Nullable Object> extends Sets.ImprovedAbstractSet<E> {
    abstract Multiset<E> multiset();

    @Override
    public void clear() {
      multiset().clear();
    }

    @Override
    public boolean contains(@Nullable Object o) {
      return multiset().contains(o);
    }

    @Override
    public boolean containsAll(Collection<?> c) {
      return multiset().containsAll(c);
    }

    @Override
    public boolean isEmpty() {
      return multiset().isEmpty();
    }

    @Override
    public abstract Iterator<E> iterator();

    @Override
    public boolean remove(@Nullable Object o) {
      return multiset().remove(o, Integer.MAX_VALUE) > 0;
    }

    @Override
    public int size() {
      return multiset().entrySet().size();
    }
  }

  abstract static class EntrySet<E extends @Nullable Object>
      extends Sets.ImprovedAbstractSet<Entry<E>> {
    abstract Multiset<E> multiset();

    @Override
    public boolean contains(@Nullable Object o) {
      if (o instanceof Entry) {
        Entry<?> entry = (Entry<?>) o;
        if (entry.getCount() <= 0) {
          return false;
        }
        int count = multiset().count(entry.getElement());
        return count == entry.getCount();
      }
      return false;
    }

    @Override
    public boolean remove(@Nullable Object object) {
      if (object instanceof Multiset.Entry) {
        Entry<?> entry = (Entry<?>) object;
        Object element = entry.getElement();
        int entryCount = entry.getCount();
        if (entryCount != 0) {
          // Safe as long as we never add a new entry, which we won't.
          // (Presumably it can still throw CCE/NPE but only if the underlying Multiset does.)
          @SuppressWarnings({"unchecked", "nullness"})
          Multiset<@Nullable Object> multiset = (Multiset<@Nullable Object>) multiset();
          return multiset.setCount(element, entryCount, 0);
        }
      }
      return false;
    }

    @Override
    public void clear() {
      multiset().clear();
    }
  }

  /** An implementation of {@link Multiset#iterator}. */
  static <E extends @Nullable Object> Iterator<E> iteratorImpl(Multiset<E> multiset) {
    return new MultisetIteratorImpl<>(multiset, multiset.entrySet().iterator());
  }

  static final class MultisetIteratorImpl<E extends @Nullable Object> implements Iterator<E> {
    private final Multiset<E> multiset;
    private final Iterator<Entry<E>> entryIterator;
    private @Nullable Entry<E> currentEntry;

    /** Count of subsequent elements equal to current element */
    private int laterCount;

    /** Count of all elements equal to current element */
    private int totalCount;

    private boolean canRemove;

    MultisetIteratorImpl(Multiset<E> multiset, Iterator<Entry<E>> entryIterator) {
      this.multiset = multiset;
      this.entryIterator = entryIterator;
    }

    @Override
    public boolean hasNext() {
      return laterCount > 0 || entryIterator.hasNext();
    }

    @Override
    @ParametricNullness
    public E next() {
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      if (laterCount == 0) {
        currentEntry = entryIterator.next();
        totalCount = laterCount = currentEntry.getCount();
      }
      laterCount--;
      canRemove = true;
      /*
       * requireNonNull is safe because laterCount starts at 0, forcing us to initialize
       * currentEntry above. After that, we never clear it.
       */
      return requireNonNull(currentEntry).getElement();
    }

    @Override
    public void remove() {
      checkRemove(canRemove);
      if (totalCount == 1) {
        entryIterator.remove();
      } else {
        /*
         * requireNonNull is safe because canRemove is set to true only after we initialize
         * currentEntry (which we never subsequently clear).
         */
        multiset.remove(requireNonNull(currentEntry).getElement());
      }
      totalCount--;
      canRemove = false;
    }
  }

  static <E extends @Nullable Object> Spliterator<E> spliteratorImpl(Multiset<E> multiset) {
    Spliterator<Entry<E>> entrySpliterator = multiset.entrySet().spliterator();
    return CollectSpliterators.flatMap(
        entrySpliterator,
        (Entry<E> entry) -> Collections.nCopies(entry.getCount(), entry.getElement()).spliterator(),
        Spliterator.SIZED
            | (entrySpliterator.characteristics()
                & (Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.IMMUTABLE)),
        multiset.size());
  }

  /** An implementation of {@link Multiset#size}. */
  static int linearTimeSizeImpl(Multiset<?> multiset) {
    long size = 0;
    for (Entry<?> entry : multiset.entrySet()) {
      size += entry.getCount();
    }
    return Ints.saturatedCast(size);
  }

  /**
   * Returns a copy of {@code multiset} as an {@link ImmutableMultiset} whose iteration order puts
   * the highest count first, with ties broken by the iteration order of the original multiset.
   *
   * @since 11.0
   */
  public static <E> ImmutableMultiset<E> copyHighestCountFirst(Multiset<E> multiset) {
    @SuppressWarnings("unchecked") // generics+arrays
    // TODO(cpovirk): Consider storing an Entry<?> instead of Entry<E>.
    Entry<E>[] entries = (Entry<E>[]) multiset.entrySet().toArray((Entry<E>[]) new Entry<?>[0]);
    Arrays.sort(entries, DecreasingCount.INSTANCE);
    return ImmutableMultiset.copyFromEntries(asList(entries));
  }

  private static final class DecreasingCount implements Comparator<Entry<?>> {
    static final Comparator<Entry<?>> INSTANCE = new DecreasingCount();

    @Override
    public int compare(Entry<?> entry1, Entry<?> entry2) {
      return entry2.getCount() - entry1.getCount(); // subtracting two nonnegative integers
    }
  }

  /**
   * An {@link AbstractMultiset} with additional default implementations, some of them linear-time
   * implementations in terms of {@code elementSet} and {@code entrySet}.
   */
  private abstract static class ViewMultiset<E extends @Nullable Object>
      extends AbstractMultiset<E> {
    @Override
    public int size() {
      return linearTimeSizeImpl(this);
    }

    @Override
    public void clear() {
      elementSet().clear();
    }

    @Override
    public Iterator<E> iterator() {
      return iteratorImpl(this);
    }

    @Override
    int distinctElements() {
      return elementSet().size();
    }
  }
}
            ]]></code>
    </test-code>



</test-data>
