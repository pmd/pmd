<?xml version="1.0" encoding="UTF-8"?>
<test-data
    xmlns="http://pmd.sourceforge.net/rule-tests"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/rule-tests http://pmd.sourceforge.net/rule-tests_1_0_0.xsd">
    <test-code>
        <description><![CDATA[
private method called by public method
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void bar() {
  foo();
 }
 private void foo() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
simple unused private method
     ]]></description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
 private void foo() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
anonymous inner class calls private method
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void bar() {
  new Runnable() {
   public void run() {
    foo();
   }
  };
 }
 private void foo() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
two private methods with same name but different parameters
     ]]></description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
 private void foo() {}
 private void foo(String baz) {}
 public void bar() {
  foo();
 }
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
calling private method after instantiating new copy of myself
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 private void foo(String[] args) {}
 public static void main(String[] args) {
  Foo u = new Foo();
  u.foo(args); 
 }
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
calling private method using 'this' modifier
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void bar() {
  this.foo();
 }
 private void foo() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
simple unused private static method
     ]]></description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
 private static void foo() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
readResolve/writeReplace/etc are OK
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 private void readResolve() {}
 private void writeReplace() {}
 private void readObject() {}
 private void writeObject() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
Private methods called only by themselves, BUG 1038229
     ]]></description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
 private void bar() {
  bar(); 
 }
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
private with same name as public, different method signature
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void bar(int x) {
  bar(); 
 }
 private void bar() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
False +, BUG 1114754
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
   public void methodFlagged(Object[] arrayObj) {
       for(int i=0; i<arrayObj.length; i++) {
           methodFlagged(arrayObj[i]);
       }
   }
   private void methodFlagged(Object a) {
       a.toString();
   }
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
called from constructor
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public Foo() {
  bar();
 }
 private void bar() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
private method with same name but diff arg count than public method
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void baz() {
  int x, y;
  baz(x, y);
 }
 private void baz(int x, int y) {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
static private called from initializer
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 static { foo(); }
 private static void foo() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
static private invoked in static context - i.e., Foo.hi()
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 static boolean BUZ = Foo.bar(); 
 private static boolean bar() { return true; }
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
private method with same name as param
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 void bar(boolean buz) { 
  buz();
 }
 private void buz() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
two methods, one private, one public, same name, same arg count, diff types
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void baz() {
  foo("hi");
 }
 private void foo(String y) {}
 public void foo(List y) {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
two private methods, both used, same name, same arg count, diff types
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void baz() {
  foo(getBuz());
 }
 private void foo(String y) {}
 private void foo(List y) {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
private method same name as local
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 public void baz() {
  int x = x();
 }
 private int x() { return 42;}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
SuppressWarnings("unused") - simple unused private method
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
 @SuppressWarnings("unused")
 private void foo() {}
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
Calling method on instance of self
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo { 
 private Foo fooField; 
 
 public void bar() { 
  Foo f = new Foo();
  f.fooField.buz();
 }
 private void buz() {} 
}
     ]]></code>
    </test-code>
    <test-code regressionTest="false">
        <description>#46 False +: Unused private field: call to instance of self, received from another class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo { 
 private Foo fooField; 

 public void bar() { 
  Biz.getFoo().buz();
 }

 private void buz() {} 
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
Calling one arg varargs method
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo { 
 public void bar() { 
  buz("baz");
 }
 private void buz(String... s) {} 
}
     ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
Calling two arg varargs method
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo { 
 public void bar() { 
  buz("baz");
 }
 private void buz(String s, String... args) {} 
}
     ]]></code>
    </test-code>
        <test-code>
        <description><![CDATA[
Reproducing bug #1955852: false positives for UnusedPrivateMethod & UnusedLocalField
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[

public class PMDFalsePositiveTest {
	private <T> T doSomething(Object param){
		return (T) param;
	}

	public static void main(String[] args) {
		PMDFalsePositiveTest test = new PMDFalsePositiveTest();
		Object o = "Awesome!";
		String result = test.<String>doSomething(o);
		System.out.println(result);
	}
}

     ]]></code>
    </test-code>
    <test-code>
        <description>verify #1156 False failure with "Avoid unused private methods"</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void endTest(final SourceLocation sourceLocation, final String message, final Object... params) {
    }
    public static void main(String[] args) {
        Foo f = new Foo();
        f.endTest(sourceLocation, "", (Object[]) null);
        f.endTest(sourceLocation, format, params);
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1223 UnusedPrivateMethod: Java 8 method reference causing false positives</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private static Runnable staticMethod() {
        return () -> System.out.println("run");
    }
    private Runnable doLater() {
        return () -> System.out.println("later");
    }
    private Runnable doLater2() {
        return () -> System.out.println("later");
    }

    public static void main(String[] args) {
        Runnable r1 = Foo::staticMethod;
        Runnable r2 = new Foo()::doLater;
    }
    public void doNow() {
        Runnable r3 = this::doLater2;
        r3.run();
    }
}
        ]]></code>
        <source-type>java 1.8</source-type>
    </test-code>
    <test-code>
        <description>#1226 False Positive: UnusedPrivateMethod overloading with varargs</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>9</expected-linenumbers>
        <code><![CDATA[
public class Foo {
    private String s;

    public Foo() {
        s = "Foobar";
    }

    //This method isn't flagged
    private void bar(int... n)
    {
    }

    //This method is flagged
    private void bar(String s)
    {
    }

    public void dummyMethod() {
        bar(s);
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (1)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public ModelAndView viewEntry(Model model, HttpServletRequest request) {
        //call private method.  Flagged Method
        return view(model, VIEW);
    }

    /** THIS IS FLAGGED AS UNUSED **/
    private ModelAndView view(Model model, String view) {
        //add values to the model

        //return the correct view
        return new ModelAndView(view, MVC_CONSTANTS.MODEL_KEY, model.asMap());
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (2)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public ModelAndView showLineGraph(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        //call private method  USAGE #1.  Method not flagged
        MyObject filter = getGraphInnateFilter(request);

        //LINE GRAPHIC LOGIC

        //write output to response stream and return
    }

    public ModelAndView showPieChart(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        //call private method  USAGE #2.  Method not flagg
        MyObject filter = getGraphInnateFilter(request);

        //PIE CHART LOGIC

        //write output to response stream and return
    }

    /** This method is NOT flagged as unused **/
    private MyObject getGraphInnateFilter(HttpServletRequest request) {
        MyObject filter = new MyObject();

        //call private method.  Flagged method
        setInnateFilterFields(filter, request);
        //perform logic

        //return
        return filter;
    }

    /** THIS IS FLAGGED AS UNUSED **/
    private void setInnateFilterFields(MyObject filter, HttpServletRequest request) {
        //add values to filter object
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (3)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    String VIEW = "foo";

    @RequestMapping(method = RequestMethod.GET, value = URL_MAPPINGS.BULK_ACTION_URL)
    public ModelAndView viewEntry(Model model, HttpServletRequest request, @RequestParam(value = "fiscalYear", required = true) int fy) {
        return view(model, VIEW, fy);
    }

    private ModelAndView view(Model model, String view, int fy) {
        //add values to the model
        model.addAttribute(FIELDS.FISCAL_YEAR, fy);

        //return the correct view
        return new ModelAndView(view, MVC_CONSTANTS.MODEL_KEY, model.asMap());
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (4)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.awt.*;
import javax.swing.*;

public class Foo {
  public JComponent makeUI() {
    Box box = Box.createVerticalBox();
    JTextField field = new JTextField();
    box.add(makePanel("aaa", field));
    return box;
  }
  private static JPanel makePanel(String title, JComponent c) { // this is wrongly triggered
    JPanel p = new JPanel(new BorderLayout());
    p.setBorder(BorderFactory.createTitledBorder(title));
    p.add(c);
    return p;
  }
  public static void main(String[] args) {
    EventQueue.invokeLater(new Runnable() {
      @Override public void run() {
        createAndShowGUI();
      }
    });
  }
  public static void createAndShowGUI() {
    JFrame f = new JFrame();
    f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    f.getContentPane().add(new Foo().makeUI());
    f.setSize(320, 240);
    f.setLocationRelativeTo(null);
    f.setVisible(true);
  }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (5a)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo extends MultiActionController {

    private static final Logger logger = Logger.getLogger(Foo.class);

    public DashboardGraphInnateFilter getGraphInnateFilter(HttpServletRequest request) {
        setInnateFilterFields();
        return null;
    }

    private void setInnateFilterFields() { //Not flagged
        logger.info("here");
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (5b)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.*;

public class Foo extends MultiActionController {
    private static final Logger logger = Logger.getLogger(Foo.class);

    public DashboardGraphInnateFilter getGraphInnateFilter(HttpServletRequest request) {
        DashboardGraphInnateFilter filter = new DashboardGraphInnateFilter();
        setInnateFilterFields(filter, request);
        return filter;
    }

    private void setInnateFilterFields(DashboardInnateFilter filter, HttpServletRequest request) { //incorrectly flagged
        logger.info("here");
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1233 UnusedPrivateMethod: False positive : method called on returned object.</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Locale;

public class Test {

    public static void main(String args[]) {
        Test t = new Test();
        t.baz();
    }

    // Here we call both foo() and bar()
    public void baz() {
        foo().toLowerCase(Locale.US);
        bar().toLowerCase();
    }

    private String foo() {
        return "Hello World";
    }

    private String bar() {
        return "Hello World";
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (6)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void double_class_1(Double d) {}
    private void double_class_2(Double d) {}
    private void double_class_3(Double d) {}
    private void double_class_4(Double d) {}
    private void double_class_5(Double d) {}
    private void double_class_6(Double d) {}
    private void double_class_7(Double d) {}
    private void double_class_8(Double d) {}
    private void double_class_9(Double d) {}
    private void double_class_10(Double d) {}
    private void double_class_11(Double d) {}
    private void double_class_12(Double d) {}
    private void double_type_1(double d) {}
    private void double_type_2(double d) {}
    private void double_type_3(double d) {}
    private void double_type_4(double d) {}
    private void double_type_5(double d) {}
    private void double_type_6(double d) {}
    private void double_type_7(double d) {}
    private void double_type_8(double d) {}
    private void double_type_9(double d) {}
    private void double_type_10(double d) {}
    private void double_type_11(double d) {}
    private void double_type_12(double d) {}

    private void float_class_1(Float f) {}
    private void float_class_2(Float f) {}
    private void float_class_3(Float f) {}
    private void float_class_4(Float f) {}
    private void float_class_5(Float f) {}
    private void float_class_6(Float f) {}
    private void float_class_7(Float f) {}
    private void float_class_8(Float f) {}
    private void float_class_9(Float f) {}
    private void float_class_10(Float f) {}
    private void float_class_11(Float f) {}
    private void float_type_1(float f) {}
    private void float_type_2(float f) {}
    private void float_type_3(float f) {}
    private void float_type_4(float f) {}
    private void float_type_5(float f) {}
    private void float_type_6(float f) {}
    private void float_type_7(float f) {}
    private void float_type_8(float f) {}
    private void float_type_9(float f) {}
    private void float_type_10(float f) {}
    private void float_type_11(float f) {}

    private void int_class_1(Integer i) {}
    private void int_class_2(Integer i) {}
    private void int_class_3(Integer i) {}
    private void int_class_4(Integer i) {}
    private void int_class_5(Integer i) {}
    private void int_class_6(Integer i) {}
    private void int_class_7(Integer i) {}
    private void int_class_8(Integer i) {}
    private void int_class_9(Integer i) {}
    private void int_class_10(Integer i) {}
    private void int_class_11(Integer i) {}
    private void int_class_12(Integer i) {}
    private void int_class_13(Integer i) {}
    private void int_class_14(Integer i) {}
    private void int_type_1(int i) {}
    private void int_type_2(int i) {}
    private void int_type_3(int i) {}
    private void int_type_4(int i) {}
    private void int_type_5(int i) {}
    private void int_type_6(int i) {}
    private void int_type_7(int i) {}
    private void int_type_8(int i) {}
    private void int_type_9(int i) {}
    private void int_type_10(int i) {}
    private void int_type_11(int i) {}
    private void int_type_12(int i) {}
    private void int_type_13(int i) {}
    private void int_type_14(int i) {}
    private void int_type_15(int i) {}
    private void long_class_1(Long l) {}
    private void long_class_2(Long l) {}
    private void long_class_3(Long l) {}
    private void long_class_4(Long l) {}
    private void long_class_5(Long l) {}
    private void long_class_6(Long l) {}
    private void long_class_7(Long l) {}
    private void long_class_8(Long l) {}
    private void long_type_1(long l) {}
    private void long_type_2(long l) {}
    private void long_type_3(long l) {}
    private void long_type_4(long l) {}
    private void long_type_5(long l) {}
    private void long_type_6(long l) {}
    private void long_type_7(long l) {}
    private void long_type_8(long l) {}
    private void byte_class(Byte i) {}
    private void byte_type(byte i) {}
    private void short_class(Short s) {}
    private void short_type(short s) {}
    private void char_class_1(Character c) {}
    private void char_class_2(Character c) {}
    private void char_class_3(Character c) {}
    private void char_class_4(Character c) {}
    private void char_class_5(Character c) {}
    private void char_type_1(char c) {}
    private void char_type_2(char c) {}
    private void char_type_3(char c) {}
    private void char_type_4(char c) {}
    private void char_type_5(char c) {}


    public void test() {
        double double_value = 2.0;
        Double Double_value = 2.0;
        float float_value = 2.0f;
        Float Float_value = 2.0f;
        int int_value = 1;
        Integer Int_value = 1;
        byte byte_value = 1;
        Byte Byte_value = 1;
        short short_value = 1;
        Short Short_value = 1;
        long long_value = 1L;
        Long Long_value = 1L;
        char char_value = 'a';
        Character Char_value = 'a';

        double_class_1(2.0);
        double_class_2(double_value);
        double_class_3(Double_value);
        double_class_4((double)2.0f);
        double_class_5((double)float_value);
        double_class_6((double)Float_value);
        double_class_7((double)1);
        double_class_8((double)int_value);
        double_class_9((double)Int_value);
        double_class_10((double)1L);
        double_class_11((double)long_value);
        double_class_12((double)Long_value);
        double_type_1(2.0);
        double_type_2(double_value);
        double_type_3(Double_value);
        double_type_4(2.0f);
        double_type_5(float_value);
        double_type_6(Float_value);
        double_type_7(1);
        double_type_8(int_value);
        double_type_9(Int_value);
        double_type_10(1L);
        double_type_11(long_value);
        double_type_12(Long_value);

        float_class_1(2.0f);
        float_class_2(float_value);
        float_class_3(Float_value);
        float_class_4((float)2.0);
        float_class_5((float)double_value);
        float_class_6((float)1);
        float_class_7((float)int_value);
        float_class_8((float)Int_value);
        float_class_9((float)1L);
        float_class_10((float)long_value);
        float_class_11((float)Long_value);
        float_type_1(2.0f);
        float_type_2(float_value);
        float_type_3(Float_value);
        float_type_4((float)2.0);
        float_type_5((float)double_value);
        float_type_6(1);
        float_type_7(int_value);
        float_type_8(Int_value);
        float_type_9(1L);
        float_type_10(long_value);
        float_type_11(Long_value);

        int_class_1(1);
        int_class_2(int_value);
        int_class_3(Int_value);
        int_class_4((int)1L);
        int_class_5((int)long_value);
        int_class_6((int)1.0);
        int_class_7((int)double_value);
        int_class_8((int)1.0f);
        int_class_9((int)float_value);
        int_class_10((int)short_value);
        int_class_11((int)Short_value);
        int_class_12((int)byte_value);
        int_class_13((int)char_value);
        int_class_14((int)Char_value);
        int_type_1(1);
        int_type_2(int_value);
        int_type_3(Int_value);
        int_type_4((int)1L);
        int_type_5((int)long_value);
        int_type_6((int)1.0);
        int_type_7((int)double_value);
        int_type_8((int)1.0f);
        int_type_9((int)float_value);
        int_type_10(short_value);
        int_type_11(Short_value);
        int_type_12(byte_value);
        int_type_13(Byte_value);
        int_type_14(char_value);
        int_type_15(Char_value);

        long_class_1(1L);
        long_class_2(long_value);
        long_class_3(Long_value);
        long_class_4((long)1);
        long_class_5((long)int_value);
        long_class_6((long)Int_value);
        long_class_7((long)char_value);
        long_class_8((long)Char_value);
        long_type_1(1L);
        long_type_2(long_value);
        long_type_3(Long_value);
        long_type_4(1);
        long_type_5(int_value);
        long_type_6(Int_value);
        long_type_7(char_value);
        long_type_8(Char_value);

        byte_class((byte)1);
        byte_type(Byte_value);
        short_class((short)1);
        short_type(Short_value);

        char_class_1('a');
        char_class_2(char_value);
        char_class_3(Char_value);
        char_class_4((char)1);
        char_class_5((char)int_value);
        char_type_1('a');
        char_type_2(char_value);
        char_type_3(Char_value);
        char_type_4((char)1);
        char_type_5((char)int_value);
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (7)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.tree.*;

public class Bar {
    private final JTree tree = new JTree();
    public JComponent makeUI() {
        Box box = Box.createVerticalBox();
        box.add(new JButton(new AbstractAction("expand  ") {
            @Override public void actionPerformed(ActionEvent e) {
                TreeNode root = (TreeNode) tree.getModel().getRoot();
                visitAll(tree, new TreePath(root), true); // line 14
            }
        }));
        box.add(new JButton(new AbstractAction("collapse") {
            @Override public void actionPerformed(ActionEvent e) {
                TreeNode root = (TreeNode) tree.getModel().getRoot();
                visitAll(tree, new TreePath(root), false); // line 20
            }
        }));
        box.add(Box.createVerticalGlue());

        JPanel p = new JPanel(new BorderLayout());
        p.add(box, BorderLayout.EAST);
        p.add(new JScrollPane(tree));
        return p;
    }
    private static void visitAll(JTree tree, TreePath parent, boolean expand) {
        TreeNode node = (TreeNode) parent.getLastPathComponent();
        if (!node.isLeaf() && node.getChildCount() >= 0) {
            Enumeration e = node.children();
            while (e.hasMoreElements()) {
                TreeNode n = (TreeNode) e.nextElement();
                TreePath path = parent.pathByAddingChild(n);
                visitAll(tree, path, expand); // line 37
            }
        }
        if (expand) {
            tree.expandPath(parent);
        } else {
            tree.collapsePath(parent);
        }
    }
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable() {
            @Override public void run() {
                createAndShowGUI();
            }
        });
    }
    public static void createAndShowGUI() {
        JFrame f = new JFrame();
        f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        f.getContentPane().add(new Bar().makeUI());
        f.setSize(320, 240);
        f.setLocationRelativeTo(null);
        f.setVisible(true);
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1234 Unused private methods still giving false positives in 5.1.3 snapshot</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public List<IListObject> getBliCodeByFiscalYear(int fiscalYear) {
       List<IListObject> records = bliCodeCache.get(fiscalYear);
        if (records == null) {
            logger.info("No BLI Code records cached for year : " + fiscalYear + ". Caching now.");
            records = this.selectBLICodeByFiscalYear(fiscalYear);
            bliCodeCache.put(fiscalYear, records);
        }
        if (records == null) {
            logger.error("Could not load BLI Code DATA.  No records retrieved.");
        }
        return records;
    }

    /**
     * Get a list of All BLI Code for given fiscal year.  
     * @param fy the selected FY
     * @return an List of BLI Codes
     */
    private List<IListObject> selectBLICodeByFiscalYear(int fy) {

        List<IListObject> result = new ArrayList<IListObject>();
        try {
            result = spiStripFieldService.getBliCodeList(fy);
        } catch (ServiceException se) {
                logger.error("Error getting BLI Code DATA: " + se.getMessage(), se);
        }
        return result;
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1156 False failure with "Avoid unused private methods" (part 2)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        int i = 1;
        String s = getBoolString(i > 0);
    }
    private String getBoolString(boolean b) {
        return b ? "TRUE" : "FALSE";
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1251 UnusedPrivateMethod false positives for boxing &amp; unboxing arguments</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethodFalsePositives {

    // UnusedPrivateMethod false positive
    private void prvUnboxing(final int i)     {}
    public  void pubUnboxing(final Integer i) {prvUnboxing(i);}

    // UnusedPrivateMethod false positive
    private void prvBoxing(final Integer i) {}
    public  void pubBoxing(final int i)     {prvBoxing(i);}

    // Correctly does not generate a warning
    private void prvPrimitive(final int i) {}
    public  void pubPrimitive(final int i) {prvPrimitive(i);}

    // Correctly does not generate a warning
    private void prvObject(final Integer i) {}
    public  void pubObject(final Integer i) {prvObject(i);}
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1249 Regression: UnusedPrivateMethod from 5.0.5 to 5.1.2</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package de.friedenhagen.pmd_private;

import java.net.URI;

import org.junit.runner.Description;

/**
 * Holder object for the id in the {@link TestLink} annotation. By defining only a private constructor in this abstract
 * class and having both extending classes as inner classes, we assure nobody is able to create other extending classes.
 * 
 * @param <T>
 *            of the id, either {@link Long} for internal or {@link String} for external IDs.
 *
 * @author Mirko Friedenhagen
 */
abstract class TestLinkId<T> {

    /** id of the test. */
    private final T id;

    /**
     * Private to make sure we only have {@link ExternalTestLinkId} and {@link InternalTestLinkId} as subclasses.
     *
     * @param id
     *            of the test.
     */
    private TestLinkId(final T id) {
        this.id = id;
    }

    /**
     * @return the id.
     */
    public T getId() {
        return id;
    }

    /**
     * Returns a String representation of the type of the current TestLink ID.
     *
     * @return type of the ID.
     */
    public abstract String getType();

    /** {@inheritDoc} */
    @Override
    public String toString() {
        return String.format("%s='%s'", getType(), getId());
    }

    /**
     * An external Testlink ID.
     */
    public static class ExternalTestLinkId extends TestLinkId<String> {

        /**
         * @param id
         *            of the testcase
         */
        public ExternalTestLinkId(String id) {
            super(id);
        }

        /** {@inheritDoc} */
        @Override
        public String getType() {
            return "external_id";
        }
    }

    /**
     * An internal Testlink ID.
     */
    public static class InternalTestLinkId extends TestLinkId<Long> {

        /**
         * @param id
         *            of the testcase
         */
        public InternalTestLinkId(final Long id) {
            super(id);
        }

        /** {@inheritDoc} */
        @Override
        public String getType() {
            return "id";
        }
    }
}

/**
 * Resolves links to the Testlink instance.
 *
 * @author Mirko Friedenhagen
 */
public class TestLinkUriResolver {

    /** baseUri of the Testlink instance. */
    private final URI baseUri;

    /**
     * The constructor normalizes the URI by adding a trailing slash when it is missing.
     * 
     * @param baseUri
     *            without <tt>index.php</tt>, eg <tt>http://testlink.sourceforge.net/demo/</tt>.
     */
    TestLinkUriResolver(URI baseUri) {
        final String asciiUri = baseUri.toASCIIString();
        if (asciiUri.endsWith("/")) {
            this.baseUri = baseUri;
        } else {
            this.baseUri = URI.create(asciiUri + "/");
        }
    }

    /**
     * http://testlink.sourceforge.net/demo/lib/testcases/tcPrint.php?testcase_id=2750.
     * 
     * @param internalTestLinkId
     *            id of the testcase
     * @return an URI pointing to the printview of the last version of the testcase description.
     */
    private URI fromTestLinkId(final TestLinkId.InternalTestLinkId internalTestLinkId) {
        return baseUri.resolve(String.format("lib/testcases/tcPrint.php?testcase_id=%s", internalTestLinkId.getId()));
    }

    /**
     * http://testlink.sourceforge.net/demo/lib/testcases/archiveData.php?targetTestCase=SM-1&edit=testcase&allowedit=0.
     * 
     * @param externalTestLinkId
     *            id of the testcase
     * @return an URI pointing to the printview of the last version of the testcase description.
     */
    private URI fromTestLinkId(final TestLinkId.ExternalTestLinkId externalTestLinkId) {
        return baseUri
                .resolve(String.format("lib/testcases/archiveData.php?targetTestCase=%s&edit=testcase&allowedit=0",
                        externalTestLinkId.getId()));
    }

    /**
     * Returns a link to the last version of the testcase description.
     *
     * http://testlink.sourceforge.net/demo/lib/testcases/tcPrint.php?testcase_id=2750
     * http://testlink.sourceforge.net/demo/lib/testcases/archiveData.php?targetTestCase=SM-1&edit=testcase&allowedit=0
     * 
     * @param testLinkId
     *            of the test case.
     * @return an URI pointing to the last version of the testcase description.
     */
    URI fromTestLinkId(final TestLinkId<?> testLinkId) {
        // As this class is package protected we may safely assume there only two kinds of TestLinkIds.
        if (testLinkId instanceof TestLinkId.InternalTestLinkId) {
            return fromTestLinkId((TestLinkId.InternalTestLinkId) testLinkId);
        } else {
            return fromTestLinkId((TestLinkId.ExternalTestLinkId) testLinkId);
        }
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class TestPrivate<T> {
    protected Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final Object bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 2</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;

public class TestPrivate<T extends List> {
    protected Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final List bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 3</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;

public class TestPrivate {
    protected <T extends List> Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final List bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 4</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Map;

public class TestPrivate {
    public <T extends Map<?,?>, X extends Map<?,?>>  void createLedgerAndChangeHistory(T oldObject, X updatedObject, boolean isChildLedgerEntry) throws ServiceException {
        Map.Entry entry = new Map.Entry();

        try {
            if (oldObject instanceof BudgetPackage || oldObject instanceof SpiEntity) {
                setTotals(oldObject);
            }
        // do other stuff
        } catch (ServiceException e) {
        }
    }

    private <X extends Map> void setTotals(X ledgerable) throws ServiceException {
        // do stuff
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1276 False positive in UnusedPrivateMethod when method arg is Object and not called with plain Object</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Parent {
    enum A {
        someEnum;
    }

    public void doSomethingUnqualified(A a) {
        doSomethingPrivateWithQualified(a);
    }

    private void doSomethingPrivateWithQualified(Parent.A a) {
        // PMD error because it doesn't equate Parent.A as the same type as A.
    }

    public void doSomethingQualified(Parent.A a) {
        doSomethingPrivateUnqualified(a);
    }

    private void doSomethingPrivateUnqualified(A a) {
        // PMD error because it doesn't equate Parent.A as the same type as A.
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1281 UnusedPrivateMethod incorrectly flagged for methods nested private classes</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class NestedClassPrivateMethods {
    public void doPublic() {
        doPrivate(new B());
        doPrivate2(new C());
    }

    public void doPublic(C c) {
        doPrivate3(c);
    }

    // incorrectly UnusedPrivateMethod
    private void doPrivate(I i) {}
    private void doPrivate2(I i) {}
    private void doPrivate3(I i) {}

    private interface I {
        void visit();
    }

    private class B implements I {
        public void visit() {
        }
    }

    private class C extends B {
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1287 UnusedPrivateMethod returns false positives for Superclass</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class SuperClassFalsePositive {

    public void myPublicMethod() {
        throw convertToUnchecked(new MyException("Something Bad Happened"));
    }

    private IllegalArgumentException convertToUnchecked(Exception e) {
        return new IllegalArgumentException(e);
    }

    private static class MyException extends Exception {
        public MyException(String message) {
            super(message);
        }
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1286 UnusedPrivateMethod returns false positives for varags</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class VaragsFalsePositive {

    enum Sizes
    {
        TINY,
        MEDIUM
    }

    public boolean containsTiny(){
        return hasTiny(Sizes.MEDIUM, Sizes.TINY);
    }

    private boolean hasTiny(Sizes... sizes) {
        for (Sizes size : sizes) {
            if (size==Sizes.TINY) {
                return true;
            }
        }
        return false;
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1294 False positive UnusedPrivateMethod with public inner enum from another class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
/**
 *
 * UnusedPrivateMethodWithEnum.java
 *
 * Copyright 2014 Expedia, Inc. All rights reserved.
 * EXPEDIA PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.ClassWithPublicEnum;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.ClassWithPublicEnum.PublicEnum;

/**
 * TODO svenz Describe UnusedPrivateMethodWithEnum
 * 
 * @author <a href="mailto:svenz@expedia.com">Sven Zethelius</a>
 *
 */
public class UnusedPrivateMethodWithEnum {
        public void doPublic() {
                ClassWithPublicEnum.PublicEnum value = ClassWithPublicEnum.PublicEnum.values()[0];
                doPrivateWithShortEnum1(value);
                doPrivateWithShortEnum2(value);
        }

        private void doPrivateWithShortEnum1(PublicEnum type) {
                // do something
        }
        private void doPrivateWithShortEnum2(ClassWithPublicEnum.PublicEnum type) {
                // do something
        }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1296 PMD UnusedPrivateMethod invalid detection of 'private void method(int,boolean,Integer...)'</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethod {
    public void deleteAllAssetsWithExceptionsNoPurge(int galleryId, Integer... exceptionList) throws MediaServiceException
    {
        deleteAllAssetsWithExceptions(galleryId, false, exceptionList);
    }

    public void deleteAllAssetsWithExceptions(int galleryId, Integer... exceptionList) throws MediaServiceException
    {
        deleteAllAssetsWithExceptions(galleryId, true, exceptionList);
    }

    private void deleteAllAssetsWithExceptions(int galleryId, boolean purge, Integer... exceptionList) throws MediaServiceException
    {
    }
}
        ]]></code>
    </test-code>

    <test-code>
    <description>#1332 False Positive: UnusedPrivateMethod</description>
    <expected-problems>0</expected-problems>
    <code><![CDATA[
package com.acme;

import org.junit.Test;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertThat;

public class FooTest {

    @Test
    public void testBar() {
        assertThat(createBar("", ""), containsString(""));
    }

    @Test
    public void testFoo() {
        assertThat(createFoo(""), containsString(""));
    }

    private String createFoo(String a) {
        return a;
    }

    private String createBar(String b, String c) {
        return b + c;
    }
}
    ]]></code>
    </test-code>

    <test-code>
        <description>#1395 UnusedPrivateMethod false positive for array element method call</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethod {
    public void doSomething() {
        File[] files = getFiles();
        for (int i = 0; i < files.length; i++) {
            String name = getNameFromFilename(files[i].getName());
            System.out.println("name is " + name);
        }
    }

    private String getNameFromFilename(String fileName) {
        int index = fileName.lastIndexOf('.');
        return fileName.substring(0, index);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1403 False positive UnusedPrivateMethod with JAVA8</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Something {
    @Test public void mapMergeShouldReturnTheUnionWhenGivenDifferentSetsWithSomeCommonValues() {
        final Map<String, Purse> actual
            = Combiners.mapMerge(mapOf(annPurse5, bobPurse7), mapOf(bobPurse9, calPurse10), ADDITION);
        assertEquals(mapOf(annPurse5, bobPurse16, calPurse10), actual);
    }
    private static Map<String, Purse> mapOf(final Purse... values) {
        return mapOf2(Purse::getOwner, values);
    }
    private static <K, V> Map<K, V> mapOf2(final Function<V, K> keyMapper, final V... values) {
        return Stream.of(values).collect(Collectors.toMap(keyMapper, Function.identity()));
    }
}
        ]]></code>
    </test-code>

    <test-code useAuxClasspath="false">
        <description>#1405 UnusedPrivateMethod false positive?</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class blabla implements blabla2 {
    @Override
    public List<String> getProductImageUrls(final ApparelStyleVariantProductModel product, final String format) {
        return getImageUrlsListForVariant(product, format);
    }
    private List<String> getImageUrlsListForVariant(final VariantProductModel variant, final String format) {
        final SortedMap<Integer, String> imageUrls = getImageUrlsMapForVariant(variant, format);
        return new ArrayList<String>(imageUrls.values());
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1412 UnusedPrivateMethod false positive: Issue #1403 not completely solved</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Something {
    private Purse annPurse5;
    private Purse bobPurse7;
    @Before public void setUp() {
        modifiableEmptyMap = new HashMap<>();
        annPurse5 = new Purse(ANN, 5);
        bobPurse7 = new Purse(BOB, 7);
    }
    @Test public void mapMergeShouldReturnTheUnionWhenGivenDifferentSetsWithSomeCommonValues() {
        final Map<String, Purse> actual
            = Combiners.mapMerge(mapOf(annPurse5, bobPurse7), mapOf(bobPurse9, calPurse10), ADDITION);
        assertEquals(mapOf(annPurse5, bobPurse16, calPurse10), actual);
    }
    private static Map<String, Purse> mapOf(final Purse... values) {
        return mapOf(Purse::getOwner, values);
    }
    private static <K, V> Map<K, V> mapOf(final Function<V, K> keyMapper, final V... values) {
        return Stream.of(values).collect(Collectors.toMap(keyMapper, Function.identity()));
    }
}
]]></code>
    </test-code>

    <test-code>
        <description>#521 UnusedPrivateMethod returns false positives with primitive data type in map argument</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
        public class Foo {
          public Foo() {
            Map<String, double[]> map = new LinkedHashMap<>();
            addToMap(map);
          }

          private void addToMap(Map<String, double[]> map) {
            map.put("foo", new double[]{0., 1.});
          }
        }
        ]]></code>
    </test-code>

    <test-code>
        <description>#907 Add IgnoredAnnotations property to UnusedPrivateMethod</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
        public class Foo {
          @Deprecated
          private bar() {
          }
        }
        ]]></code>
    </test-code>
    <test-code>
        <description><![CDATA[
Explicit receiver parameters are ignored when matching methods
     ]]></description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
class Foo {
  public void bar() {
    test();
  }
  
  private void test(@AnnotatedUsage Foo this) {
  }
}
     ]]></code>
    </test-code>

    <test-code>
        <description>Verify property ignoredAnnotations is used</description>
        <rule-property name="ignoredAnnotations">java.lang.Override</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    @Override // well override doesn't really make sense, but it's good enough for the test case
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Verify property ignoredAnnotations is used - 2</description>
        <rule-property name="ignoredAnnotations"></rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    @Deprecated
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1531 [java] UnusedPrivateMethod false-positive with method result</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethodFP {
    private void print(String s) { // <- unused private method?
        System.out.println(s);
    }

    public void run() {
        print(new Integer(1).toString()); // it is used here
    }

    private void print2(String s) {
        System.out.println(s);
    }

    public void run2() {
        String temp = new Integer(1).toString();
        print2(temp); // workaround with extra temporary variable
    }

    private void print3(String s) {
        System.out.println(s);
    }

    public void run3() {
        print3((String)new Integer(1).toString()); // workaround with extra cast
    }

    public void runBoolean(String s) {
        privateBooleanMethod(s, "true".equals(s));
    }

    private void privateBooleanMethod(String s, boolean isTrue) {
        System.out.println(s);
    }
}
        ]]></code>
    </test-code>
</test-data>
