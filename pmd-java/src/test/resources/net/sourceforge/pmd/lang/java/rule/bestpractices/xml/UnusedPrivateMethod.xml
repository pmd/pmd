<?xml version="1.0" encoding="UTF-8"?>
<test-data
    xmlns="http://pmd.sourceforge.net/rule-tests"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/rule-tests http://pmd.sourceforge.net/rule-tests_1_0_0.xsd">

    <test-code>
        <description>private method called by public method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        foo();
    }
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>simple unused private method</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>anonymous inner class calls private method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        new Runnable() {
            public void run() {
                foo();
            }
        };
    }
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>two private methods with same name but different parameters</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    private void foo() {}
    private void foo(String baz) {}
    public void bar() {
        foo();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>calling private method after instantiating new copy of myself</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void foo(String[] args) {}
    public static void main(String[] args) {
        Foo u = new Foo();
        u.foo(args);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>calling private method using 'this' modifier</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        this.foo();
    }
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>simple unused private static method</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    private static void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>readResolve/writeReplace/etc are OK</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void readResolve() {}
    private void writeReplace() {}
    private void readObject() {}
    private void writeObject() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Private methods called only by themselves, BUG 1038229</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    private void bar() {
        bar();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>private with same name as public, different method signature</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar(int x) {
        bar();
    }
    private void bar() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>False +, BUG 1114754</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
   public void methodFlagged(Object[] arrayObj) {
       for(int i=0; i<arrayObj.length; i++) {
           methodFlagged(arrayObj[i]);
       }
   }
   private void methodFlagged(Object a) {
       a.toString();
   }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>called from constructor</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public Foo() {
        bar();
    }
    private void bar() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>private method with same name but diff arg count than public method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void baz() {
        int x, y;
        baz(x, y);
    }
    private void baz(int x, int y) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>static private called from initializer</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    static { foo(); }
    private static void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>static private invoked in static context - i.e., Foo.hi()</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    static boolean BUZ = Foo.bar();
    private static boolean bar() { return true; }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>private method with same name as param</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    void bar(boolean buz) {
        buz();
    }
    private void buz() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>two methods, one private, one public, same name, same arg count, diff types</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void baz() {
        foo("hi");
    }
    private void foo(String y) {}
    public void foo(Integer y) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>two private methods, only one used, same name, same arg count, diff types</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>7</expected-linenumbers>
        <expected-messages>
            <message>Avoid unused private methods such as 'foo(Integer)'.</message>
        </expected-messages>
        <code><![CDATA[
public class Foo {
    public void baz() {
        foo(getBuz());
    }
    String getBuz() {return "";}
    private void foo(String y) {}
    private void foo(Integer y) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>private method same name as local</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void baz() {
        int x = x();
    }
    private int x() { return 42;}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>SuppressWarnings("unused") - simple unused private method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    @SuppressWarnings("unused")
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Calling method on instance of self</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private Foo fooField;

    public void bar() {
        Foo f = new Foo();
        f.fooField.buz();
    }
    private void buz() {}
}
        ]]></code>
    </test-code>

    <test-code disabled="true">
        <description>#46 False +: Unused private field: call to instance of self, received from another class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private Foo fooField;

    public void bar() {
        Biz.getFoo().buz();
    }

    private void buz() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Calling one arg varargs method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        buz("baz");
    }
    private void buz(String... s) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Calling two arg varargs method</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        buz("baz");
    }
    private void buz(String s, String... args) {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Reproducing bug #1955852: false positives for UnusedPrivateMethod and UnusedLocalField</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class PMDFalsePositiveTest {
    private <T> T doSomething(Object param){
        return (T) param;
    }

    public static void main(String[] args) {
        PMDFalsePositiveTest test = new PMDFalsePositiveTest();
        Object o = "Awesome!";
        String result = test.<String>doSomething(o);
        System.out.println(result);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>verify #1156 False failure with "Avoid unused private methods"</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void endTest(final String message, final Object... params) {
    }
    public static void main(String[] args) {
        Foo f = new Foo();
        f.endTest("", (Object[]) null);
        f.endTest(format, params);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1223 UnusedPrivateMethod: Java 8 method reference causing false positives</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private static Runnable staticMethod() {
        return () -> System.out.println("run");
    }
    private Runnable doLater() {
        return () -> System.out.println("later");
    }
    private Runnable doLater2() {
        return () -> System.out.println("later");
    }

    public static void main(String[] args) {
        Runnable r1 = Foo::staticMethod;
        Runnable r2 = new Foo()::doLater;
    }
    public void doNow() {
        Runnable r3 = this::doLater2;
        r3.run();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1226 False Positive: UnusedPrivateMethod overloading with varargs</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>9</expected-linenumbers>
        <code><![CDATA[
public class Foo {
    private String s;

    public Foo() {
        s = "Foobar";
    }

    //This method isn't flagged
    private void bar(int... n)
    {
    }

    //This method is flagged
    private void bar(String s)
    {
    }

    public void dummyMethod() {
        bar(s);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (1)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import my.Model;
public class ModelAndView {
    public ModelAndView viewEntry(Model model) {
        //call private method.  Flagged Method
        return view(model, VIEW);
    }

    /** THIS IS FLAGGED AS UNUSED **/
    private ModelAndView view(Model model, String view) {
        //add values to the model

        //return the correct view
        return new ModelAndView(view, "MVC_CONSTANTS.MODEL_KEY", model.asMap());
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (2)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import my.HttpServletRequest;
import my.HttpServletResponse;
import my.ServletException;
public class ModelAndView {
    public ModelAndView showLineGraph(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        //call private method  USAGE #1.  Method not flagged
        Object filter = getGraphInnateFilter(request);

        //LINE GRAPHIC LOGIC

        //write output to response stream and return
    }

    public ModelAndView showPieChart(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        //call private method  USAGE #2.  Method not flagg
        Object filter = getGraphInnateFilter(request);

        //PIE CHART LOGIC

        //write output to response stream and return
    }

    /** This method is NOT flagged as unused **/
    private Object getGraphInnateFilter(HttpServletRequest request) {
        Object filter = new Object();

        //call private method.  Flagged method
        setInnateFilterFields(filter, request);
        //perform logic

        //return
        return filter;
    }

    /** THIS IS FLAGGED AS UNUSED **/
    private void setInnateFilterFields(Object filter, HttpServletRequest request) {
        //add values to filter object
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (3)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import my.HttpServletRequest;
import my.Model;
public class ModelAndView {
    String VIEW = "foo";

    public ModelAndView viewEntry(Model model, HttpServletRequest request, int fy) {
        return view(model, VIEW, fy);
    }

    private ModelAndView view(Model model, String view, int fy) {
        //return the correct view
        return new ModelAndView(view, "MVC_CONSTANTS.MODEL_KEY", model.asMap());
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (4)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public Foo makeUI() {
        Foo box = new Foo();
        box.add(makePanel("aaa", box));
        return box;
    }
    private static Foo makePanel(String title, Foo c) { // this is wrongly triggered
        return c;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (5a)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import javax.servlet.http.HttpServletRequest;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.DashboardGraphInnateFilter;

public class Foo {

    public DashboardGraphInnateFilter getGraphInnateFilter(HttpServletRequest request) {
        setInnateFilterFields();
        return null;
    }

    private void setInnateFilterFields() { //Not flagged
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (5b)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import javax.servlet.http.HttpServletRequest;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.DashboardGraphInnateFilter;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.DashboardInnateFilter;

public class Foo {

    public DashboardGraphInnateFilter getGraphInnateFilter(HttpServletRequest request) {
        DashboardGraphInnateFilter filter = new DashboardGraphInnateFilter();
        setInnateFilterFields(filter, request);
        return filter;
    }

    private void setInnateFilterFields(DashboardInnateFilter filter, HttpServletRequest request) { //incorrectly flagged
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1233 UnusedPrivateMethod: False positive : method called on returned object.</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Locale;

public class Test {

    public static void main(String args[]) {
        Test t = new Test();
        t.baz();
    }

    // Here we call both foo() and bar()
    public void baz() {
        foo().toLowerCase(Locale.US);
        bar().toLowerCase();
    }

    private String foo() {
        return "Hello World";
    }

    private String bar() {
        return "Hello World";
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (6)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    private void double_class_1(Double d) {}
    private void double_class_2(Double d) {}
    private void double_class_3(Double d) {}
    private void double_class_4(Double d) {}
    private void double_class_5(Double d) {}
    private void double_class_6(Double d) {}
    private void double_class_7(Double d) {}
    private void double_class_8(Double d) {}
    private void double_class_9(Double d) {}
    private void double_class_10(Double d) {}
    private void double_class_11(Double d) {}
    private void double_class_12(Double d) {}
    private void double_type_1(double d) {}
    private void double_type_2(double d) {}
    private void double_type_3(double d) {}
    private void double_type_4(double d) {}
    private void double_type_5(double d) {}
    private void double_type_6(double d) {}
    private void double_type_7(double d) {}
    private void double_type_8(double d) {}
    private void double_type_9(double d) {}
    private void double_type_10(double d) {}
    private void double_type_11(double d) {}
    private void double_type_12(double d) {}

    private void float_class_1(Float f) {}
    private void float_class_2(Float f) {}
    private void float_class_3(Float f) {}
    private void float_class_4(Float f) {}
    private void float_class_5(Float f) {}
    private void float_class_6(Float f) {}
    private void float_class_7(Float f) {}
    private void float_class_8(Float f) {}
    private void float_class_9(Float f) {}
    private void float_class_10(Float f) {}
    private void float_class_11(Float f) {}
    private void float_type_1(float f) {}
    private void float_type_2(float f) {}
    private void float_type_3(float f) {}
    private void float_type_4(float f) {}
    private void float_type_5(float f) {}
    private void float_type_6(float f) {}
    private void float_type_7(float f) {}
    private void float_type_8(float f) {}
    private void float_type_9(float f) {}
    private void float_type_10(float f) {}
    private void float_type_11(float f) {}

    private void int_class_1(Integer i) {}
    private void int_class_2(Integer i) {}
    private void int_class_3(Integer i) {}
    private void int_class_4(Integer i) {}
    private void int_class_5(Integer i) {}
    private void int_class_6(Integer i) {}
    private void int_class_7(Integer i) {}
    private void int_class_8(Integer i) {}
    private void int_class_9(Integer i) {}
    private void int_class_10(Integer i) {}
    private void int_class_11(Integer i) {}
    private void int_class_12(Integer i) {}
    private void int_class_13(Integer i) {}
    private void int_class_14(Integer i) {}
    private void int_type_1(int i) {}
    private void int_type_2(int i) {}
    private void int_type_3(int i) {}
    private void int_type_4(int i) {}
    private void int_type_5(int i) {}
    private void int_type_6(int i) {}
    private void int_type_7(int i) {}
    private void int_type_8(int i) {}
    private void int_type_9(int i) {}
    private void int_type_10(int i) {}
    private void int_type_11(int i) {}
    private void int_type_12(int i) {}
    private void int_type_13(int i) {}
    private void int_type_14(int i) {}
    private void int_type_15(int i) {}
    private void long_class_1(Long l) {}
    private void long_class_2(Long l) {}
    private void long_class_3(Long l) {}
    private void long_class_4(Long l) {}
    private void long_class_5(Long l) {}
    private void long_class_6(Long l) {}
    private void long_class_7(Long l) {}
    private void long_class_8(Long l) {}
    private void long_type_1(long l) {}
    private void long_type_2(long l) {}
    private void long_type_3(long l) {}
    private void long_type_4(long l) {}
    private void long_type_5(long l) {}
    private void long_type_6(long l) {}
    private void long_type_7(long l) {}
    private void long_type_8(long l) {}
    private void byte_class(Byte i) {}
    private void byte_type(byte i) {}
    private void short_class(Short s) {}
    private void short_type(short s) {}
    private void char_class_1(Character c) {}
    private void char_class_2(Character c) {}
    private void char_class_3(Character c) {}
    private void char_class_4(Character c) {}
    private void char_class_5(Character c) {}
    private void char_type_1(char c) {}
    private void char_type_2(char c) {}
    private void char_type_3(char c) {}
    private void char_type_4(char c) {}
    private void char_type_5(char c) {}


    public void test() {
        double double_value = 2.0;
        Double Double_value = 2.0;
        float float_value = 2.0f;
        Float Float_value = 2.0f;
        int int_value = 1;
        Integer Int_value = 1;
        byte byte_value = 1;
        Byte Byte_value = 1;
        short short_value = 1;
        Short Short_value = 1;
        long long_value = 1L;
        Long Long_value = 1L;
        char char_value = 'a';
        Character Char_value = 'a';

        double_class_1(2.0);
        double_class_2(double_value);
        double_class_3(Double_value);
        double_class_4((double)2.0f);
        double_class_5((double)float_value);
        double_class_6((double)Float_value);
        double_class_7((double)1);
        double_class_8((double)int_value);
        double_class_9((double)Int_value);
        double_class_10((double)1L);
        double_class_11((double)long_value);
        double_class_12((double)Long_value);
        double_type_1(2.0);
        double_type_2(double_value);
        double_type_3(Double_value);
        double_type_4(2.0f);
        double_type_5(float_value);
        double_type_6(Float_value);
        double_type_7(1);
        double_type_8(int_value);
        double_type_9(Int_value);
        double_type_10(1L);
        double_type_11(long_value);
        double_type_12(Long_value);

        float_class_1(2.0f);
        float_class_2(float_value);
        float_class_3(Float_value);
        float_class_4((float)2.0);
        float_class_5((float)double_value);
        float_class_6((float)1);
        float_class_7((float)int_value);
        float_class_8((float)Int_value);
        float_class_9((float)1L);
        float_class_10((float)long_value);
        float_class_11((float)Long_value);
        float_type_1(2.0f);
        float_type_2(float_value);
        float_type_3(Float_value);
        float_type_4((float)2.0);
        float_type_5((float)double_value);
        float_type_6(1);
        float_type_7(int_value);
        float_type_8(Int_value);
        float_type_9(1L);
        float_type_10(long_value);
        float_type_11(Long_value);

        int_class_1(1);
        int_class_2(int_value);
        int_class_3(Int_value);
        int_class_4((int)1L);
        int_class_5((int)long_value);
        int_class_6((int)1.0);
        int_class_7((int)double_value);
        int_class_8((int)1.0f);
        int_class_9((int)float_value);
        int_class_10((int)short_value);
        int_class_11((int)Short_value);
        int_class_12((int)byte_value);
        int_class_13((int)char_value);
        int_class_14((int)Char_value);
        int_type_1(1);
        int_type_2(int_value);
        int_type_3(Int_value);
        int_type_4((int)1L);
        int_type_5((int)long_value);
        int_type_6((int)1.0);
        int_type_7((int)double_value);
        int_type_8((int)1.0f);
        int_type_9((int)float_value);
        int_type_10(short_value);
        int_type_11(Short_value);
        int_type_12(byte_value);
        int_type_13(Byte_value);
        int_type_14(char_value);
        int_type_15(Char_value);

        long_class_1(1L);
        long_class_2(long_value);
        long_class_3(Long_value);
        long_class_4((long)1);
        long_class_5((long)int_value);
        long_class_6((long)Int_value);
        long_class_7((long)char_value);
        long_class_8((long)Char_value);
        long_type_1(1L);
        long_type_2(long_value);
        long_type_3(Long_value);
        long_type_4(1);
        long_type_5(int_value);
        long_type_6(Int_value);
        long_type_7(char_value);
        long_type_8(Char_value);

        byte_class((byte)1);
        byte_type(Byte_value);
        short_class((short)1);
        short_type(Short_value);

        char_class_1('a');
        char_class_2(char_value);
        char_class_3(Char_value);
        char_class_4((char)1);
        char_class_5((char)int_value);
        char_type_1('a');
        char_type_2(char_value);
        char_type_3(Char_value);
        char_type_4((char)1);
        char_type_5((char)int_value);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1228 UnusedPrivateMethod returns false positives (7)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
class JTree {
    JTree getRoot() {return this;}
}
class TreeNode extends JTree {}

public class Box {
    interface Action { void perform(); }

    void add(Action a) {}

    private final JTree tree = new JTree();
    public void makeUI() {
        Box box = new Box();
        box.add(new Action() {
            @Override public void perform() {
                TreeNode root = (TreeNode) tree.getRoot();
                visitAll(tree, true); // line 14
            }
        });
    }
    private static void visitAll(JTree tree, boolean expand) { }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1234 Unused private methods still giving false positives in 5.1.3 snapshot</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;
import java.util.Map;
public class Foo {
    interface IListObject {}
    Map<Integer, List<IListObject>> bliCodeCache;
    public List<IListObject> getBliCodeByFiscalYear(int fiscalYear) {
       List<IListObject> records = bliCodeCache.get(fiscalYear);
        if (records == null) {
            records = this.selectBLICodeByFiscalYear(fiscalYear);
            bliCodeCache.put(fiscalYear, records);
        }
        return records;
    }

    /**
     * Get a list of All BLI Code for given fiscal year.
     * @param fy the selected FY
     * @return an List of BLI Codes
     */
    private List<IListObject> selectBLICodeByFiscalYear(int fy) {
        return null;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1156 False failure with "Avoid unused private methods" (part 2)</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    public void bar() {
        int i = 1;
        String s = getBoolString(i > 0);
    }
    private String getBoolString(boolean b) {
        return b ? "TRUE" : "FALSE";
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1251 UnusedPrivateMethod false positives for boxing &amp; unboxing arguments</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethodFalsePositives {

    // UnusedPrivateMethod false positive
    private void prvUnboxing(final int i)     {}
    public  void pubUnboxing(final Integer i) {prvUnboxing(i);}

    // UnusedPrivateMethod false positive
    private void prvBoxing(final Integer i) {}
    public  void pubBoxing(final int i)     {prvBoxing(i);}

    // Correctly does not generate a warning
    private void prvPrimitive(final int i) {}
    public  void pubPrimitive(final int i) {prvPrimitive(i);}

    // Correctly does not generate a warning
    private void prvObject(final Integer i) {}
    public  void pubObject(final Integer i) {prvObject(i);}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1249 Regression: UnusedPrivateMethod from 5.0.5 to 5.1.2</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package de.friedenhagen.pmd_private;

import java.net.URI;

import org.junit.runner.Description;

/**
 * Holder object for the id in the {@link TestLink} annotation. By defining only a private constructor in this abstract
 * class and having both extending classes as inner classes, we assure nobody is able to create other extending classes.
 *
 * @param <T>
 *            of the id, either {@link Long} for internal or {@link String} for external IDs.
 *
 * @author Mirko Friedenhagen
 */
abstract class TestLinkId<T> {

    /** id of the test. */
    private final T id;

    /**
     * Private to make sure we only have {@link ExternalTestLinkId} and {@link InternalTestLinkId} as subclasses.
     *
     * @param id
     *            of the test.
     */
    private TestLinkId(final T id) {
        this.id = id;
    }

    /**
     * @return the id.
     */
    public T getId() {
        return id;
    }

    /**
     * Returns a String representation of the type of the current TestLink ID.
     *
     * @return type of the ID.
     */
    public abstract String getType();

    /** {@inheritDoc} */
    @Override
    public String toString() {
        return String.format("%s='%s'", getType(), getId());
    }

    /**
     * An external Testlink ID.
     */
    public static class ExternalTestLinkId extends TestLinkId<String> {

        /**
         * @param id
         *            of the testcase
         */
        public ExternalTestLinkId(String id) {
            super(id);
        }

        /** {@inheritDoc} */
        @Override
        public String getType() {
            return "external_id";
        }
    }

    /**
     * An internal Testlink ID.
     */
    public static class InternalTestLinkId extends TestLinkId<Long> {

        /**
         * @param id
         *            of the testcase
         */
        public InternalTestLinkId(final Long id) {
            super(id);
        }

        /** {@inheritDoc} */
        @Override
        public String getType() {
            return "id";
        }
    }
}

/**
 * Resolves links to the Testlink instance.
 *
 * @author Mirko Friedenhagen
 */
public class TestLinkUriResolver {

    /** baseUri of the Testlink instance. */
    private final URI baseUri;

    /**
     * The constructor normalizes the URI by adding a trailing slash when it is missing.
     *
     * @param baseUri
     *            without <tt>index.php</tt>, eg <tt>http://testlink.sourceforge.net/demo/</tt>.
     */
    TestLinkUriResolver(URI baseUri) {
        final String asciiUri = baseUri.toASCIIString();
        if (asciiUri.endsWith("/")) {
            this.baseUri = baseUri;
        } else {
            this.baseUri = URI.create(asciiUri + "/");
        }
    }

    /**
     * http://testlink.sourceforge.net/demo/lib/testcases/tcPrint.php?testcase_id=2750.
     *
     * @param internalTestLinkId
     *            id of the testcase
     * @return an URI pointing to the printview of the last version of the testcase description.
     */
    private URI fromTestLinkId(final TestLinkId.InternalTestLinkId internalTestLinkId) {
        return baseUri.resolve(String.format("lib/testcases/tcPrint.php?testcase_id=%s", internalTestLinkId.getId()));
    }

    /**
     * http://testlink.sourceforge.net/demo/lib/testcases/archiveData.php?targetTestCase=SM-1&edit=testcase&allowedit=0.
     *
     * @param externalTestLinkId
     *            id of the testcase
     * @return an URI pointing to the printview of the last version of the testcase description.
     */
    private URI fromTestLinkId(final TestLinkId.ExternalTestLinkId externalTestLinkId) {
        return baseUri
                .resolve(String.format("lib/testcases/archiveData.php?targetTestCase=%s&edit=testcase&allowedit=0",
                        externalTestLinkId.getId()));
    }

    /**
     * Returns a link to the last version of the testcase description.
     *
     * http://testlink.sourceforge.net/demo/lib/testcases/tcPrint.php?testcase_id=2750
     * http://testlink.sourceforge.net/demo/lib/testcases/archiveData.php?targetTestCase=SM-1&edit=testcase&allowedit=0
     *
     * @param testLinkId
     *            of the test case.
     * @return an URI pointing to the last version of the testcase description.
     */
    URI fromTestLinkId(final TestLinkId<?> testLinkId) {
        // As this class is package protected we may safely assume there only two kinds of TestLinkIds.
        if (testLinkId instanceof TestLinkId.InternalTestLinkId) {
            return fromTestLinkId((TestLinkId.InternalTestLinkId) testLinkId);
        } else {
            return fromTestLinkId((TestLinkId.ExternalTestLinkId) testLinkId);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class TestPrivate<T> {
    protected Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final Object bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 2</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;

public class TestPrivate<T extends List> {
    protected Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final List bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 3</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.List;

public class TestPrivate {
    protected <T extends List> Object getProtected(final T bean) {
        return getPrivate(bean);
    }
    private Object getPrivate(final List bean) {
        return bean;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1261 False positive "Avoid unused private methods" with Generics 4</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.AbstractMap;
import java.util.Map;

public class TestPrivate {
    public <T extends Map<?,?>, X extends Map<?,?>>  void createLedgerAndChangeHistory(T oldObject, X updatedObject, boolean isChildLedgerEntry) {

        if (oldObject instanceof TestPrivate) {
            setTotals(oldObject);
        }
        // do other stuff
    }

    private <X extends Map> void setTotals(X ledgerable) {
        // do stuff
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1276 False positive in UnusedPrivateMethod when method arg is Object and not called with plain Object</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Parent {
    enum A {
        someEnum;
    }

    public void doSomethingUnqualified(A a) {
        doSomethingPrivateWithQualified(a);
    }

    private void doSomethingPrivateWithQualified(Parent.A a) {
        // PMD error because it doesn't equate Parent.A as the same type as A.
    }

    public void doSomethingQualified(Parent.A a) {
        doSomethingPrivateUnqualified(a);
    }

    private void doSomethingPrivateUnqualified(A a) {
        // PMD error because it doesn't equate Parent.A as the same type as A.
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1281 UnusedPrivateMethod incorrectly flagged for methods nested private classes</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class NestedClassPrivateMethods {
    public void doPublic() {
        doPrivate(new B());
        doPrivate2(new C());
    }

    public void doPublic(C c) {
        doPrivate3(c);
    }

    // incorrectly UnusedPrivateMethod
    private void doPrivate(I i) {}
    private void doPrivate2(I i) {}
    private void doPrivate3(I i) {}

    private interface I {
        void visit();
    }

    private class B implements I {
        public void visit() {
        }
    }

    private class C extends B {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1287 UnusedPrivateMethod returns false positives for Superclass</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class SuperClassFalsePositive {

    public void myPublicMethod() {
        throw convertToUnchecked(new MyException("Something Bad Happened"));
    }

    private IllegalArgumentException convertToUnchecked(Exception e) {
        return new IllegalArgumentException(e);
    }

    private static class MyException extends Exception {
        public MyException(String message) {
            super(message);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1286 UnusedPrivateMethod returns false positives for varags</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class VaragsFalsePositive {

    enum Sizes
    {
        TINY,
        MEDIUM
    }

    public boolean containsTiny(){
        return hasTiny(Sizes.MEDIUM, Sizes.TINY);
    }

    private boolean hasTiny(Sizes... sizes) {
        for (Sizes size : sizes) {
            if (size==Sizes.TINY) {
                return true;
            }
        }
        return false;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1294 False positive UnusedPrivateMethod with public inner enum from another class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
/**
 *
 * UnusedPrivateMethodWithEnum.java
 *
 * Copyright 2014 Expedia, Inc. All rights reserved.
 * EXPEDIA PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.ClassWithPublicEnum;
import net.sourceforge.pmd.lang.java.rule.bestpractices.unusedprivatemethod.ClassWithPublicEnum.PublicEnum;

/**
 * TODO svenz Describe UnusedPrivateMethodWithEnum
 *
 * @author <a href="mailto:svenz@expedia.com">Sven Zethelius</a>
 *
 */
public class UnusedPrivateMethodWithEnum {
        public void doPublic() {
                ClassWithPublicEnum.PublicEnum value = ClassWithPublicEnum.PublicEnum.values()[0];
                doPrivateWithShortEnum1(value);
                doPrivateWithShortEnum2(value);
        }

        private void doPrivateWithShortEnum1(PublicEnum type) {
                // do something
        }
        private void doPrivateWithShortEnum2(ClassWithPublicEnum.PublicEnum type) {
                // do something
        }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1296 PMD UnusedPrivateMethod invalid detection of 'private void method(int,boolean,Integer...)'</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethod {
    public void deleteAllAssetsWithExceptionsNoPurge(int galleryId, Integer... exceptionList)
    {
        deleteAllAssetsWithExceptions(galleryId, false, exceptionList);
    }

    public void deleteAllAssetsWithExceptions(int galleryId, Integer... exceptionList)
    {
        deleteAllAssetsWithExceptions(galleryId, true, exceptionList);
    }

    private void deleteAllAssetsWithExceptions(int galleryId, boolean purge, Integer... exceptionList)
    {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1332 False Positive: UnusedPrivateMethod</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
package com.acme;

import org.junit.Test;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertThat;

public class FooTest {

    @Test
    public void testBar() {
        assertThat(createBar("", ""), containsString(""));
    }

    @Test
    public void testFoo() {
        assertThat(createFoo(""), containsString(""));
    }

    private String createFoo(String a) {
        return a;
    }

    private String createBar(String b, String c) {
        return b + c;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1395 UnusedPrivateMethod false positive for array element method call</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.File;
public class UnusedPrivateMethod {
    public void doSomething() {
        File[] files = getFiles();
        for (int i = 0; i < files.length; i++) {
            String name = getNameFromFilename(files[i].getName());
            System.out.println("name is " + name);
        }
    }

    private String getNameFromFilename(String fileName) {
        int index = fileName.lastIndexOf('.');
        return fileName.substring(0, index);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1403 False positive UnusedPrivateMethod with JAVA8</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.function.Function;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import my.Combiners;

public class Purse {

    Purse annPurse5, bobPurse7, bobPurse9, calPurse10, bobPurse16;

    public void mapMergeShouldReturnTheUnionWhenGivenDifferentSetsWithSomeCommonValues() {
        Combiners.mapMerge(mapOf(annPurse5, bobPurse7), mapOf(bobPurse9, calPurse10));
    }

    private static Map<String, Purse> mapOf(final Purse... values) {
        return mapOf2(Purse::getOwner, values);
    }

    private static <K, V> Map<K, V> mapOf2(final Function<V, K> keyMapper, final V... values) {
        return Stream.of(values).collect(Collectors.toMap(keyMapper, Function.identity()));
    }

    String getOwner() { return "me"; }

    static class Combiners {

        static <K, V> Map<K, V> mapMerge(Map<K, V> m1, Map<K, V> m2) {
            return m2;
        }
    }
}
        ]]></code>
    </test-code>

    <test-code disabled="true">
        <!-- Todo I ignored this because the test is not useful. It only checks that we
              avoid the FP when auxclasspath is not set, while the FP is still here with
              auxclasspath. The FP should not be there with or without auxclasspath, and it's
              pointless to ensure it's not there only when the user has configured
              their analysis incorrectly. -->
        <description>#1405 UnusedPrivateMethod false positive?</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[import java.util.ArrayList;
import java.util.List;
import java.util.SortedMap;

class Sup {}

public class Blabla extends Sup {
    public List<String> getProductImageUrls(final Blabla product, final String format) {
        return getImageUrlsListForVariant(product, format);
    }
    private List<String> getImageUrlsListForVariant(final Sup variant, final String format) {
    }
}
        ]]></code>
    </test-code>


    <test-code>
        <description>#521 UnusedPrivateMethod returns false positives with primitive data type in map argument</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Map;
import java.util.LinkedHashMap;
public class Foo {
    public Foo() {
        Map<String, double[]> map = new LinkedHashMap<>();
        addToMap(map);
    }

    private void addToMap(Map<String, double[]> map) {
        map.put("foo", new double[]{0., 1.});
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#907 Add IgnoredAnnotations property to UnusedPrivateMethod</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    @Deprecated
    private bar() {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Explicit receiver parameters are ignored when matching methods</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
class Foo {
    public void bar() {
        test();
    }

    private void test(@Annotated Foo this) {
    }
    @interface Annotated {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Verify property ignoredAnnotations is used</description>
        <rule-property name="ignoredAnnotations">java.lang.Override</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
    @Override // well override doesn't really make sense, but it's good enough for the test case
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Verify property ignoredAnnotations is used - 2</description>
        <rule-property name="ignoredAnnotations"></rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
public class Foo {
    @Deprecated
    private void foo() {}
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1531 [java] UnusedPrivateMethod false-positive with method result</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedPrivateMethodFP {
    private void print(String s) { // <- unused private method?
        System.out.println(s);
    }

    public void run() {
        print(new Integer(1).toString()); // it is used here
    }

    private void print2(String s) {
        System.out.println(s);
    }

    public void run2() {
        String temp = new Integer(1).toString();
        print2(temp); // workaround with extra temporary variable
    }

    private void print3(String s) {
        System.out.println(s);
    }

    public void run3() {
        print3((String)new Integer(1).toString()); // workaround with extra cast
    }

    public void runBoolean(String s) {
        privateBooleanMethod(s, "true".equals(s));
    }

    private void privateBooleanMethod(String s, boolean isTrue) {
        System.out.println(s);
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#2454 [java] UnusedPrivateMethod violation for disabled annotation in 6.23.0</description>
        <!-- Note: weird whitespace in the property is important        -->
        <rule-property name="ignoredAnnotations">java
            .lang.Deprecated</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class OOO {
    OOO server = this;
    @Deprecated
    private void shutdown() {
        server.shutdown();
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>UnusedPrivateMethod false positive #2890</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.Map;
import java.util.Collections;
import java.util.List;
public class Client {


    public void swap(Map<String, List<Integer>> optionIndexes, Object[] entries, int index1, int index2) {

        List<Integer> list1 = optionIndexes.get("option1"),
                list2 = optionIndexes.get("option2");

        sortedInsert(list1, index2);
        sortedInsert(list2, index1);
    }

    private static <T extends Comparable<? super T>> void sortedInsert(List<T> list, T value) // NOPMD: UnusedPrivateMethod: false positive
    {
        int idx = Collections.binarySearch(list, value);
        list.add(idx < 0 ? -idx - 1 : idx, value);
    }

}
        ]]></code>
    </test-code>
    <test-code>
        <description>[java] UnusedPrivateMethod false positive from inner class via external class #1189</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>4</expected-linenumbers>
        <code><![CDATA[
            public final class OuterClass {

                private static class InnerClass {
                    private void privateMethod() {} // shadows other, truly unused

                    public void callPrivateMethod() {
                        Referrer.getOuterClass().privateMethod();
                    }

                }

                private void privateMethod() {}

            }

            class Referrer {
                static OuterClass getOuterClass() { return null; }
            }
        ]]></code>
    </test-code>
    <test-code>
        <description>UnusedPrivateMethod yields false positive for counter-variant arguments #770</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
            import org.junit.Test;
            import static org.junit.Assert.*;
            public final class OuterClass {

                @Test
                public void testFlipCaseDigit() {
                    testNoChangeOnFlip("0123456789");
                }

                @Test
                public void testFlipCaseWhitespace() {
                    testNoChangeOnFlip(" \r\t\n");
                }

                @Test
                public void testFlipCaseOtherChars() {
                    testNoChangeOnFlip("!@#$%^");
                }

                private static void testNoChangeOnFlip(CharSequence chars) {
                }
            }
        ]]></code>
    </test-code>

    <test-code>
        <description>[java] UnusedPrivateMethod false positive when passing in lombok.val as argument #3118</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import lombok.val;

public class ValExample {
    public void example() {
        val example = "value";
        aPrivateMethod(example);
    }

    private void aPrivateMethod(String s) {
        System.out.println(s);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>False negative with unused private method in nested classes</description>
        <expected-problems>2</expected-problems>
        <expected-linenumbers>2,4</expected-linenumbers>
        <code><![CDATA[
public class Outer {
    private void outerUnusedMethod() {}
    public class Inner {
        private void innerUnusedMethod() {} // false negative
        private void innerUsedByInnerMethod() {}
        public void publicInnerMethod() {
            innerUsedByInnerMethod();
        }
        private void innerUsedByOuterMethod() {}
    }
    public void publicOuterMethod() {
        Inner inner = new Inner();
        inner.innerUsedByOuterMethod();
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1175 False positive with Junit 5 MethodSource</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.stream.Stream;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;

public class Outer {
    private static Stream<Arguments> basenameKeyArguments() {
        return Stream.of(
                Arguments.of("simple", "simple"),
                Arguments.of("simple", "one/two/many/simple"),
                Arguments.of("simple", "//////an/////awful/key////simple")
        );
    }

    @ParameterizedTest
    @MethodSource("basenameKeyArguments")
    void basenameKeyTest(final String expected, final String testString) {
        assertEquals(expected, NetworkTable.basenameKey(testString));
    }

}
        ]]></code>
    </test-code>

    <test-code>
        <description>#3468 UnusedPrivateMethod false positive when outer class calls private static method on inner class</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class OuterClass {

    public void foo() {
        InnerClass.doSomething();
    }

    static class InnerClass {
        private static void doSomething() {}
    }
}
        ]]></code>
    </test-code> 

    <test-code>
        <description>[java] UnusedPrivateMethod false positive with static method and cast expression #3209</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class UnusedAssignmentRule {
    private static class ReachingDefsVisitor {
        private static String getVarIfUnaryAssignment(String node) {
            return null;
        }
    }
    public static class AssignmentEntry {
        final String var;
        final Object rhs;
        public boolean isUnaryReassign() {
            return rhs instanceof String
                && var.equals(ReachingDefsVisitor.getVarIfUnaryAssignment((String) rhs));
        }
    }
}
        ]]></code>
    </test-code>
</test-data>
