<?xml version="1.0"?>

<ruleset name="Naming"
    xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
  <description>
The Naming Ruleset contains rules regarding preferred usage of names and identifiers.
  </description>


  <rule name="ShortVariable"
        language="java"
        since="0.3"
        message="Avoid variables with short names like {0}"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#shortvariable">
    <description>
Fields, local variables, or parameter names that are very short are not helpful to the reader.
    </description>
    <priority>3</priority>
    <properties>
        <property name="minimum" type="Integer" value="3" min="1" max="100" description="Number of characters that are required as a minimum for a variable name."/>
        <property name="xpath">
            <value>
<![CDATA[
//VariableDeclaratorId[string-length(@Image) < $minimum]
 [not(ancestor::ForInit)]
 [not(../../VariableDeclarator and ../../../LocalVariableDeclaration and ../../../../ForStatement)]
 [not((ancestor::FormalParameter) and (ancestor::TryStatement))]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
public class Something {
    private int q = 15;                         // field - too short
    public static void main( String as[] ) {    // formal arg - too short
        int r = 20 + q;                         // local var - too short
        for (int i = 0; i < 10; i++) {          // not a violation (inside 'for' loop)
            r += q;
        }
        for (Integer i : numbers) {             // not a violation (inside 'for-each' loop)
            r += q;
        }
    }
}
]]>
    </example>
  </rule>

  <rule name="LongVariable"
        language="java"
        since="0.3"
        message="Avoid excessively long variable names like {0}"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#longvariable">
    <description>
Fields, formal arguments, or local variable names that are too long can make the code difficult to follow.
    </description>
    <priority>3</priority>
    <properties>
        <property name="minimum" type="Integer" description="The variable length reporting threshold" min="1" max="100" value="17"/>
        <property name="xpath">
            <value>
<![CDATA[
//VariableDeclaratorId[string-length(@Image) > $minimum]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
public class Something {
    int reallyLongIntName = -3;             // VIOLATION - Field
    public static void main( String argumentsList[] ) { // VIOLATION - Formal
        int otherReallyLongName = -5;       // VIOLATION - Local
        for (int interestingIntIndex = 0;   // VIOLATION - For
             interestingIntIndex < 10;
             interestingIntIndex ++ ) {
    }
}
]]>
    </example>
  </rule>

  <rule name="ShortMethodName"
        language="java"
        since="0.3"
        message="Avoid using short method names"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#shortmethodname">
    <description>
Method names that are very short are not helpful to the reader.
    </description>
    <priority>3</priority>
    <properties>
        <property name="minimum" type="Integer" value="3" min="1" max="100" description="Number of characters that are required as a minimum for a method name."/>
        <property name="xpath">
            <value>
<![CDATA[
//MethodDeclarator[string-length(@Image) < $minimum]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
public class ShortMethod {
    public void a( int i ) { // Violation
    }
}
]]>
     </example>
  </rule>

  <rule name="VariableNamingConventions"
        since="1.2"
        message="{0} variable {1} should begin with {2}"
        class="net.sourceforge.pmd.lang.java.rule.naming.VariableNamingConventionsRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#variablenamingconventions">
    <description>
A variable naming conventions rule - customize this to your liking.  Currently, it
checks for final variables that should be fully capitalized and non-final variables
that should not include underscores.
    </description>
    <priority>1</priority>
    <example>
<![CDATA[
public class Foo {
    public static final int MY_NUM = 0;
    public String myTest = "";
    DataModule dmTest = new DataModule();
}
]]>
    </example>
  </rule>

  <rule name="MethodNamingConventions"
        since="1.2"
        message="Method name does not begin with a lower case character."
        class="net.sourceforge.pmd.lang.java.rule.naming.MethodNamingConventionsRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#methodnamingconventions">
    <description>
Method names should always begin with a lower case character, and should not contain underscores.
    </description>
    <priority>1</priority>
    <example>
<![CDATA[
public class Foo {
    public void fooStuff() {
    }
}
]]>
    </example>
  </rule>

  <rule name="ClassNamingConventions"
        since="1.2"
        message="Class names should begin with an uppercase character"
        class="net.sourceforge.pmd.lang.java.rule.naming.ClassNamingConventionsRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#classnamingconventions">
    <description>
Class names should always begin with an upper case character.
    </description>
    <priority>1</priority>
    <example>
<![CDATA[
public class Foo {}
]]>
    </example>
  </rule>

  <rule name="AbstractNaming"
        language="java"
        since="1.4"
        message="Abstract classes should be named 'AbstractXXX'"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#abstractnaming">
    <description>
Abstract classes should be named 'AbstractXXX'.
    </description>
    <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true' and @Interface='false']
 [not (starts-with(@Image,'Abstract'))]
|
//ClassOrInterfaceDeclaration
 [@Abstract='false']
 [$strict='true']
 [starts-with(@Image, 'Abstract')]
]]>
            </value>
        </property>
        <property name="strict" type="Boolean" value="true" description="Also flag classes, that are named Abstract, but are not abstract."/>
    </properties>
    <example>
<![CDATA[
public abstract class Foo { // should be AbstractFoo
}
]]>
    </example>
  </rule>

  <rule name="AvoidDollarSigns"
        since="1.5"
        message="Avoid using dollar signs in variable/method/class/interface names"
        class="net.sourceforge.pmd.lang.java.rule.naming.AvoidDollarSignsRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#avoiddollarsigns">
    <description>
Avoid using dollar signs in variable/method/class/interface names.
    </description>
    <priority>3</priority>
    <example>
<![CDATA[
public class Fo$o {  // not a recommended name
}
]]>
    </example>
  </rule>

  <rule name="MethodWithSameNameAsEnclosingClass"
        since="1.5"
        message="Classes should not have non-constructor methods with the same name as the class"
        class="net.sourceforge.pmd.lang.java.rule.naming.MethodWithSameNameAsEnclosingClassRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#methodwithsamenameasenclosingclass">
    <description>
Non-constructor methods should not have the same name as the enclosing class.
    </description>
    <priority>3</priority>
    <example>
<![CDATA[
public class MyClass {

    public MyClass() {}         // this is OK because it is a constructor

    public void MyClass() {}    // this is bad because it is a method
}
    ]]>
    </example>
  </rule>

  <rule name="SuspiciousHashcodeMethodName"
        since="1.5"
        message="The method name and return type are suspiciously close to hashCode()"
        class="net.sourceforge.pmd.lang.java.rule.naming.SuspiciousHashcodeMethodNameRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#suspicioushashcodemethodname">
    <description>
The method name and return type are suspiciously close to hashCode(), which may denote an intention
to override the hashCode() method.
    </description>
    <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
    public int hashcode() { // oops, this probably was supposed to be 'hashCode'
    }
}
    ]]>
    </example>
  </rule>

  <rule name="SuspiciousConstantFieldName"
        language="java"
        since="2.0"
        message="The field name indicates a constant but its modifiers do not"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#suspiciousconstantfieldname">
    <description>
Field names using all uppercase characters - Sun's Java naming conventions indicating constants - should
be declared as final.
    </description>
    <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Interface='false']
 /ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
  [@Final='false']
  [VariableDeclarator/VariableDeclaratorId[upper-case(@Image)=@Image]]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
public class Foo {
 // this is bad, since someone could accidentally
 // do PI = 2.71828; which is actually e
 // final double PI = 3.16; is ok
  double PI = 3.16;
}
]]>
    </example>
  </rule>

  <rule name="SuspiciousEqualsMethodName"
        language="java"
        since="2.0"
        message="The method name and parameter number are suspiciously close to equals(Object)"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#suspiciousequalsmethodname">
    <description>
The method name and parameter number are suspiciously close to equals(Object), which can denote an
intention to override the equals(Object) method.
    </description>
    <priority>2</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//MethodDeclarator[@Image = 'equals']
[   
    (count(FormalParameters/*) = 1
    and not (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
        [@Image = 'Object' or @Image = 'java.lang.Object'])
    or not (../ResultType/Type/PrimitiveType[@Image = 'boolean'])
    )  or  (
    count(FormalParameters/*) = 2
    and ../ResultType/Type/PrimitiveType[@Image = 'boolean']
    and FormalParameters//ClassOrInterfaceType[@Image = 'Object' or @Image = 'java.lang.Object']
    and not(../../Annotation/MarkerAnnotation/Name[@Image='Override'])
    )
]
| //MethodDeclarator[@Image = 'equal']
[
    count(FormalParameters/*) = 1
    and FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
        [@Image = 'Object' or @Image = 'java.lang.Object']
]           
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
public class Foo {
   public int equals(Object o) {
     // oops, this probably was supposed to be boolean equals
   }
   public boolean equals(String s) {
     // oops, this probably was supposed to be equals(Object)
   }
   public boolean equals(Object o1, Object o2) {
     // oops, this probably was supposed to be equals(Object)
   }
}
]]>
    </example>
  </rule>

  <rule name="AvoidFieldNameMatchingTypeName"
        since="3.0"
        message="It is somewhat confusing to have a field name matching the declaring class name"
        class="net.sourceforge.pmd.lang.java.rule.naming.AvoidFieldNameMatchingTypeNameRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#avoidfieldnamematchingtypename">
    <description>
It is somewhat confusing to have a field name matching the declaring class name.
This probably means that type and/or field names should be chosen more carefully.
    </description>
    <priority>3</priority>
    <example>
<![CDATA[
public class Foo extends Bar {
    int foo;    // There is probably a better name that can be used
}
]]>
    </example>
  </rule>

  <rule name="AvoidFieldNameMatchingMethodName"
        since="3.0"
        message="Field {0} has the same name as a method"
        class="net.sourceforge.pmd.lang.java.rule.naming.AvoidFieldNameMatchingMethodNameRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#avoidfieldnamematchingmethodname">
    <description>
It can be confusing to have a field name with the same name as a method. While this is permitted, 
having information (field) and actions (method) is not clear naming. Developers versed in 
Smalltalk often prefer this approach as the methods denote accessor methods.
    </description>
    <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
    Object bar;
    // bar is data or an action or both?
    void bar() {
    }
}
]]>
    </example>
  </rule>

  <rule name="NoPackage"
        language="java"
        since="3.3"
        message="All classes and interfaces must belong to a named package"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#nopackage">
    <description>
Detects when a class or interface does not have a package definition.
    </description>
    <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration[count(preceding::PackageDeclaration) = 0]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
// no package declaration
public class ClassInDefaultPackage {
}
]]>
    </example>
  </rule>

  <rule name="PackageCase"
        language="java"
        since="3.3"
        message="Package name contains upper case characters"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#packagecase">
    <description>
Detects when a package definition contains uppercase characters.
    </description>
    <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//PackageDeclaration/Name[lower-case(@Image)!=@Image]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
package com.MyCompany;  // should be lowercase name

public class SomeClass {
}
]]>
    </example>
  </rule>

  <rule name="MisleadingVariableName"
        language="java"
        since="3.4"
        message="Avoid naming non-fields with the prefix 'm_'"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#misleadingvariablename">
    <description>
Detects when a non-field has a name starting with 'm_'.  This usually denotes a field and could be confusing.
    </description>
    <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//VariableDeclaratorId
[starts-with(@Image, 'm_')]
[not (../../../FieldDeclaration)]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
public class Foo {
    private int m_foo; // OK
    public void bar(String m_baz) { // Bad
      int m_boz = 42; // Bad
    }
}
]]>
    </example>
  </rule>

  <rule name="BooleanGetMethodName"
        language="java"
        since="4.0"
        message="A 'getX()' method which returns a boolean should be named 'isX()'"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#booleangetmethodname">
    <description>
Methods that return boolean results should be named as predicate statements to denote this.
I.e, 'isReady()', 'hasValues()', 'canCommit()', 'willFail()', etc.   Avoid the use of the 'get'
prefix for these methods.
    </description>
    <priority>4</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//MethodDeclaration[
MethodDeclarator[count(FormalParameters/FormalParameter) = 0 or $checkParameterizedMethods = 'true']
                [starts-with(@Image, 'get')]
and
ResultType/Type/PrimitiveType[@Image = 'boolean']
and not(../Annotation//Name[@Image = 'Override'])
]
]]>
            </value>
        </property>
        <property name="checkParameterizedMethods" type="Boolean" description="Check parameterized methods" value="false"/>
    </properties>
    <example>
<![CDATA[
public boolean getFoo();            // bad
public boolean isFoo();             // ok
public boolean getFoo(boolean bar); // ok, unless checkParameterizedMethods=true
]]>
    </example>
  </rule>

  <rule name="ShortClassName"
        language="java"
        since="5.0"
        message="Avoid short class names like {0}"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#shortclassname">
    <description>
Short Classnames with fewer than e.g. five characters are not recommended.
    </description>
    <priority>4</priority>
    <properties>
        <property name="minimum" type="Integer" value="5" min="1" max="100" description="Number of characters that are required as a minimum for a class name."/>
        <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration[string-length(@Image) < $minimum]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
public class Foo {
}
]]>
    </example>
  </rule>

  <rule name="GenericsNaming"
        language="java"
        since="4.2.6"
        message="Generics names should be a one letter long and upper case."
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_naming.html#genericsnaming">
    <description>
Names for references to generic values should be limited to a single uppercase letter.
    </description>
    <priority>4</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/TypeParameters/TypeParameter[
  string-length(@Image) > 1 
  or
  string:upper-case(@Image) != @Image
]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
public interface GenericDao<E extends BaseModel, K extends Serializable> extends BaseDao {
    // This is ok...
}

public interface GenericDao<E extends BaseModel, K extends Serializable> {
    // Also this
}

public interface GenericDao<e extends BaseModel, K extends Serializable> {
    // 'e' should be an 'E'
}

public interface GenericDao<EF extends BaseModel, K extends Serializable> {
   // 'EF' is not ok.
}
]]>
    </example>
  </rule>

<rule name=“MethodTypeAndNameIsInconsistent”
	  language = "java"
	  since = "5.5.1"
          message="Linguistics Antipattern - Method name and return type is inconsistent linguistically"
          class="net.sourceforge.pmd.lang.java.rule.naming.MethodTypeAndNameIsInconsistentRule”
        externalInfoUrl="${pmd.website.baseurl}/rules/java/naming.html#MethodTypeAndNameIsInconsistent”> 
      <description>
      Linguistics Antipattern - Method name and return type is inconsistent linguistically      
</description>
        <priority>3</priority>
 
      <example>
<![CDATA[
public class MethodTypeAndNameIsInconsistentTest 
{
	
	//First and third method in every group shouldnt raise error but second should
	//Groups are seperated by comments
	
	int isotherm()
	{
		return 1;
	}
	
	int isValid()
	{
		return 1;
	}
	
	boolean isSmall()
	{
		return true;
	}
	
	//////////////////////////
	
	int haskell()
	{
		return 1;
	}
	
	int hasChild()
	{
		return 1;
	}
	
	boolean hasHorn()
	{
		return true;
	}
	
	//////////////////////////
	
	int havelock()
	{
		return 1;
	}
	
	int haveChild()
	{
		return 1;
	}
	
	boolean haveHorn()
	{
		return true;
	}
	
	/////////////////////////
	
	int cannibal()
	{
		return 1;
	}
	
	int canFly()
	{
		return 1;
	}
	
	boolean canWalk()
	{
		return true;
	}
	
	/////////////////////////
	
	int william()
	{
		return 1;
	}
	
	int willFly()
	{
		return 1;
	}
	
	boolean willWalk()
	{
		return true;
	}
	
	/////////////////////////
	
	int shoulder()
	{
		return 1;
	}
	
	int shouldFly()
	{
		return 1;
	}
	
	boolean shouldWalk()
	{
		return true;
	}
	
	/////////////////////////

	int settlement()
	{
		return 1;
	}
	
	int setName()
	{
		return 1;
	}
	
	void setFlag()
	{
		
	}
	
	/////////////////////////

	void getaways()
	{
		
	}
	
	void getName()
	{
		
	}
	
	int getCount()
	{
		return 1;
	}
	
	/////////////////////////

	void tokenize()
	{
		
	}
	
	void toDataType()
	{
		
	}
	
	int toMyInteger()
	{
		return 1;
	}
	
	void grapeToWine()
	{
		
	}
	
	int hopsToBeer()
	{
		return 1;
	}
	
}
]]>
      </example>
    </rule>

<rule name=“AttributeTypeAndNameIsInconsistent”
	  language = "java"
	  since = "5.5.1"
          message="Linguistics Antipattern - Attribute name and type is inconsistent linguistically"
          class="net.sourceforge.pmd.lang.java.rule.naming.AttributeTypeAndNameIsInconsistentRule”
        externalInfoUrl="${pmd.website.baseurl}/rules/java/naming.html#AttributeTypeAndNameIsInconsistent”> 
      <description>
      Linguistics Antipattern - Attribute name and type is inconsistent linguistically      
</description>
        <priority>3</priority>
 
      <example>
<![CDATA[
public class AttributeTypeAndNameIsInconsistentTest 
{
	//First and third variable in every group shouldnt raise error but second should

	int isotherm;
	int isValid;
	boolean isTrue;
	
	int haskell;
	int hasMoney;
	boolean hasSalary;
	
	int cannibal;
	int canFly;
	boolean canWalk;
	
	int william;
	int willMove;
	boolean willRun;
	
	int havexxx;
	int haveLegs;
	boolean haveHorns;
	
	int shoulder;
	int shouldClimb;
	boolean shouldEat;
	
	void myMethod()
	{
		int isothermLocal;
		int isValidLocal;
		boolean isTrueLocal;
		
		int haskellLocal;
		int hasMoneyLocal;
		boolean hasSalaryLocal;
		
		int cannibalLocal;
		int canFlyLocal;
		boolean canWalkLocal;
		
		int williamLocal;
		int willMoveLocal;
		boolean willRunLocal;
		
		int havexxxLocal;
		int haveLegsLocal;
		boolean haveHornsLocal;
		
		int shoulderLocal;
		int shouldClimbLocal;
		boolean shouldEatLocal;
	}
	

}
]]>
      </example>
    </rule>

</ruleset>
