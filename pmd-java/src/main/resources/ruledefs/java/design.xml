<?xml version="1.0"?>

<ruleset name="Design"
    xmlns="http://pmd.sourceforge.net/ruleset/3.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/3.0.0 http://pmd.sourceforge.net/ruleset_3_0_0.xsd">

  <description>
The Design ruleset contains rules that flag suboptimal code implementations. Alternate approaches
are suggested.
  </description>

  <rule name="UseUtilityClass"
        since="0.3"
        message="All methods are static.  Consider using a utility class instead. Alternatively, you could add a private constructor or make the class abstract to silence this warning."
        class="net.sourceforge.pmd.lang.java.rule.design.UseUtilityClassRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#useutilityclass">
    <description>
For classes that only have static methods, consider making them utility classes.
Note that this doesn't apply to abstract classes, since their subclasses may
well include non-static methods.  Also, if you want this class to be a utility class,
remember to add a private constructor to prevent instantiation.
(Note, that this use was known before PMD 5.1.0 as UseSingleton).
    </description>
      <priority>3</priority>
    <example>
<![CDATA[
public class MaybeAUtility {
  public static void foo() {}
  public static void bar() {}
}
]]>
    </example>
  </rule>

  <rule name="SimplifyBooleanReturns"
        since="0.9"
        message="Avoid unnecessary if..then..else statements when returning booleans"
        class="net.sourceforge.pmd.lang.java.rule.design.SimplifyBooleanReturnsRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#simplifybooleanreturns">
    <description>
Avoid unnecessary if-then-else statements when returning a boolean. The result of
the conditional test can be returned instead.
    </description>
      <priority>3</priority>
    <example>
<![CDATA[
public boolean isBarEqualTo(int x) {
    if (bar == x) {      // this bit of code...
        return true;
    } else {
        return false;
    }
}

public boolean isBarEqualTo(int x) {
    return bar == x;    // can be replaced with this
}
]]>
    </example>
  </rule>

  <rule name="SimplifyBooleanExpressions"
        language="java"
        since="1.05"
        message="Avoid unnecessary comparisons in boolean expressions"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#simplifybooleanexpressions">
      <description>
Avoid unnecessary comparisons in boolean expressions, they serve no purpose and impacts readability.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//EqualityExpression/PrimaryExpression
 /PrimaryPrefix/Literal/BooleanLiteral
]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Bar {
  // can be simplified to
  // bar = isFoo();
  private boolean bar = (isFoo() == true);

  public isFoo() { return false;}
}
  ]]>
      </example>
    </rule>

  <rule name="SwitchStmtsShouldHaveDefault"
        language="java"
        since="1.0"
        message="Switch statements should have a default label"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#switchstmtsshouldhavedefault">
    <description>
All switch statements should include a default option to catch any unspecified values.
    </description>
    <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//SwitchStatement[not(SwitchLabel[@Default='true'])]
                  ]]>
              </value>
          </property>
      </properties>
    <example>
<![CDATA[
public void bar() {
    int x = 2;
    switch (x) {
      case 1: int j = 6;
      case 2: int j = 8;
          // missing default: here
    }
}
]]>
    </example>
    </rule>

  <rule name="AvoidDeeplyNestedIfStmts"
        since="1.0"
        message="Deeply nested if..then statements are hard to read"
        class="net.sourceforge.pmd.lang.java.rule.design.AvoidDeeplyNestedIfStmtsRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#avoiddeeplynestedifstmts">
    <description>
Avoid creating deeply nested if-then statements since they are harder to read and error-prone to maintain.
    </description>
      <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
  public void bar(int x, int y, int z) {
    if (x>y) {
      if (y>z) {
        if (z==x) {
         // !! too deep
        }
      }
    }
  }
}
]]>
    </example>
    </rule>

  <rule name="AvoidReassigningParameters"
        since="1.0"
        message="Avoid reassigning parameters such as ''{0}''"
        class="net.sourceforge.pmd.lang.java.rule.design.AvoidReassigningParametersRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#avoidreassigningparameters">
    <description>
Reassigning values to incoming parameters is not recommended.  Use temporary local variables instead.
    </description>
        <priority>2</priority>
    <example>
<![CDATA[
public class Foo {
  private void foo(String bar) {
    bar = "something else";
  }
}
]]>
    </example>
  </rule>

  <rule name="SwitchDensity"
        since="1.02"
        message="A high ratio of statements to labels in a switch statement.  Consider refactoring."
        class="net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#switchdensity">
      <description>
A high ratio of statements to labels in a switch statement implies that the switch statement
is overloaded.  Consider moving the statements into new methods or creating subclasses based
on the switch variable.
      </description>
        <priority>3</priority>
      <example>
 <![CDATA[
public class Foo {
  public void bar(int x) {
    switch (x) {
      case 1: {
        // lots of statements
        break;
      } case 2: {
        // lots of statements
        break;
      }
    }
  }
}
 ]]>
      </example>
    </rule>

  <rule name="ConstructorCallsOverridableMethod"
        since="1.04"
        message="Overridable {0} called during object construction"
        class="net.sourceforge.pmd.lang.java.rule.design.ConstructorCallsOverridableMethodRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#constructorcallsoverridablemethod">
      <description>
Calling overridable methods during construction poses a risk of invoking methods on an incompletely
constructed object and can be difficult to debug.
It may leave the sub-class unable to construct its superclass or forced to replicate the construction
process completely within itself, losing the ability to call super().  If the default constructor
contains a call to an overridable method, the subclass may be completely uninstantiable.   Note that
this includes method calls throughout the control flow graph - i.e., if a constructor Foo() calls a
private method bar() that calls a public method buz(), this denotes a problem.
      </description>
        <priority>1</priority>
      <example>
  <![CDATA[
public class SeniorClass {
  public SeniorClass(){
      toString(); //may throw NullPointerException if overridden
  }
  public String toString(){
    return "IAmSeniorClass";
  }
}
public class JuniorClass extends SeniorClass {
  private String name;
  public JuniorClass(){
    super(); //Automatic call leads to NullPointerException
    name = "JuniorClass";
  }
  public String toString(){
    return name.toUpperCase();
  }
}
  ]]>
      </example>
    </rule>

  <rule name="AccessorClassGeneration"
        since="1.04"
        message="Avoid instantiation through private constructors from outside of the constructor's class."
        class="net.sourceforge.pmd.lang.java.rule.design.AccessorClassGenerationRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#accessorclassgeneration">
      <description>
Instantiation by way of private constructors from outside of the constructor's class often causes the
generation of an accessor. A factory method, or non-privatization of the constructor can eliminate this
situation. The generated class file is actually an interface.  It gives the accessing class the ability
to invoke a new hidden package scope constructor that takes the interface as a supplementary parameter.
This turns a private constructor effectively into one with package scope, and is challenging to discern.
      </description>
      <priority>3</priority>
      <example>
  <![CDATA[
public class Outer {
 void method(){
  Inner ic = new Inner();//Causes generation of accessor class
 }
 public class Inner {
  private Inner(){}
 }
}
  ]]>
      </example>
    </rule>

  <rule name="FinalFieldCouldBeStatic"
        language="java"
        since="1.1"
        message="This final field could be made static"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#finalfieldcouldbestatic">
      <description>
If a final field is assigned to a compile-time constant, it could be made static, thus saving overhead
in each object at runtime.
      </description>
      <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//FieldDeclaration
 [@Final='true' and @Static='false']
   /VariableDeclarator/VariableInitializer/Expression
    /PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Literal
                    ]]>
                </value>
            </property>
        </properties>
      <example>
  <![CDATA[
public class Foo {
  public final int BAR = 42; // this could be static and save some space
}
  ]]>
      </example>
    </rule>


  <rule name="CloseResource"
        since="1.2.2"
        message="Ensure that resources like this {0} object are closed after use"
        class="net.sourceforge.pmd.lang.java.rule.design.CloseResourceRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#closeresource">
    <description>
Ensure that resources (like Connection, Statement, and ResultSet objects) are always closed after use.
    </description>
    <priority>3</priority>
    <example>
<![CDATA[
public class Bar {
  public void foo() {
    Connection c = pool.getConnection();
    try {
      // do stuff
    } catch (SQLException ex) {
     // handle exception
    } finally {
      // oops, should close the connection using 'close'!
      // c.close();
    }
  }
}
]]>
    </example>
  </rule>

  <rule name="NonStaticInitializer"
        language="java"
        since="1.5"
        message="Non-static initializers are confusing"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#nonstaticinitializer">
       <description>
A non-static initializer block will be called any time a constructor is invoked (just prior to
invoking the constructor).  While this is a valid language construct, it is rarely used and is
confusing.
       </description>
       <priority>3</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//Initializer[@Static='false']
]]>
                 </value>
             </property>
         </properties>
       <example>
   <![CDATA[
public class MyClass {
  // this block gets run before any call to a constructor
  {
    System.out.println("I am about to construct myself");
  }
}
   ]]>
       </example>
     </rule>

  <rule name="DefaultLabelNotLastInSwitchStmt"
        language="java"
        since="1.5"
        message="The default label should be the last label in a switch statement"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#defaultlabelnotlastinswitchstmt">
       <description>
By convention, the default label should be the last label in a switch statement.
       </description>
       <priority>3</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//SwitchStatement
 [not(SwitchLabel[position() = last()][@Default='true'])]
 [SwitchLabel[@Default='true']]
]]>
                 </value>
             </property>
         </properties>
       <example>
   <![CDATA[
public class Foo {
  void bar(int a) {
   switch (a) {
    case 1:  // do something
       break;
    default:  // the default case should be last, by convention
       break;
    case 2:
       break;
   }
  }
}   ]]>
       </example>
     </rule>

  <rule name="NonCaseLabelInSwitchStatement"
        language="java"
        since="1.5"
        message="A non-case label was present in a switch statement"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#noncaselabelinswitchstatement">
       <description>
A non-case label (e.g. a named break/continue label) was present in a switch statement.
This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
       </description>
       <priority>3</priority>
         <properties>
             <property name="xpath">
                 <value>
 <![CDATA[
//SwitchStatement//BlockStatement/Statement/LabeledStatement
 ]]>
                 </value>
             </property>
         </properties>
       <example>
   <![CDATA[
public class Foo {
  void bar(int a) {
   switch (a) {
     case 1:
       // do something
       break;
     mylabel: // this is legal, but confusing!
       break;
     default:
       break;
    }
  }
}
   ]]>
       </example>
     </rule>

  <rule name="OptimizableToArrayCall"
        language="java"
        since="1.8"
        message="This call to Collection.toArray() may be optimizable"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#optimizabletoarraycall">
      <description>
Calls to a collection's toArray() method should specify target arrays sized to match the size of the
collection. Initial arrays that are too small are discarded in favour of new ones that have to be created
that are the proper size.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//PrimaryExpression
[PrimaryPrefix/Name[ends-with(@Image, 'toArray')]]
[
PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression/PrimaryPrefix/AllocationExpression
 /ArrayDimsAndInits/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image='0']
]
                  ]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
List foos = getFoos();

    // inefficient, the array will be discarded
Foo[] fooArray = foos.toArray(new Foo[0]);

    // much better; this one sizes the destination array,
    // avoiding of a new one via reflection
Foo[] fooArray = foos.toArray(new Foo[foos.size()]);
  ]]>
      </example>
    </rule>


  <rule name="BadComparison"
        language="java"
        since="1.8"
        message="Avoid equality comparisons with Double.NaN"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#badcomparison">
      <description>
Avoid equality comparisons with Double.NaN. Due to the implicit lack of representation
precision when comparing floating point numbers these are likely to cause logic errors.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//EqualityExpression[@Image='==']
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image='Double.NaN' or @Image='Float.NaN']
                  ]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
boolean x = (y == Double.NaN);
  ]]>
      </example>
    </rule>

  <rule name="EqualsNull"
        language="java"
        since="1.9"
        message="Avoid using equals() to compare against null"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#equalsnull">
        <description>
Tests for null should not use the equals() method. The '==' operator should be used instead.
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
    <![CDATA[
//PrimaryExpression
  [
    PrimaryPrefix[Name[ends-with(@Image, 'equals')]]
      [following-sibling::node()/Arguments/ArgumentList[count(Expression)=1]
          /Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]

    or

    PrimarySuffix[ends-with(@Image, 'equals')]
      [following-sibling::node()/Arguments/ArgumentList[count(Expression)=1]
          /Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]

  ]
    ]]>
                </value>
            </property>
         </properties>
    <example>
       <![CDATA[
String x = "foo";

if (x.equals(null)) {   // bad form
    doSomething();
}

if (x == null) {        // preferred
    doSomething();
}
    ]]>
        </example>
        </rule>

  <rule name="ConfusingTernary"
        since="1.9"
        message="Avoid if (x != y) ..; else ..;"
        class="net.sourceforge.pmd.lang.java.rule.design.ConfusingTernaryRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#confusingternary">
        <description>
Avoid negation within an "if" expression with an "else" clause.  For example, rephrase:
`if (x != y) diff(); else same();` as: `if (x == y) same(); else diff();`.

Most "if (x != y)" cases without an "else" are often return cases, so consistent use of this
rule makes the code easier to read.  Also, this resolves trivial ordering problems, such
as "does the error case go first?" or "does the common case go first?".
        </description>
        <priority>3</priority>
        <example>
          <![CDATA[
boolean bar(int x, int y) {
    return (x != y) ? diff : same;
}
          ]]>
        </example>
      </rule>

  <rule name="InstantiationToGetClass"
        language="java"
        since="2.0"
        message="Avoid instantiating an object just to call getClass() on it; use the .class public member instead"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#instantiationtogetclass">
      <description>
Avoid instantiating an object just to call getClass() on it; use the .class public member instead.
      </description>
      <priority>4</priority>
        <properties>
          <property name="xpath">
            <value>
                <![CDATA[
//PrimarySuffix
 [@Image='getClass']
 [parent::PrimaryExpression
  [PrimaryPrefix/AllocationExpression]
  [count(PrimarySuffix) = 2]
 ]
     ]]>
            </value>
          </property>
        </properties>
        <example>
    <![CDATA[
// replace this
Class c = new String().getClass();

// with this:
Class c = String.class;
    ]]>
        </example>
      </rule>

  <rule name="IdempotentOperations"
        since="2.0"
        message="Avoid idempotent operations (like assigning a variable to itself)."
        class="net.sourceforge.pmd.lang.java.rule.design.IdempotentOperationsRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#idempotentoperations">
      <description>
Avoid idempotent operations - they have no effect.
      </description>
        <priority>3</priority>

      <example>
      <![CDATA[
public class Foo {
 public void bar() {
  int x = 2;
  x = x;
 }
}
      ]]>
      </example>
    </rule>

  <rule name="SimpleDateFormatNeedsLocale"
        language="java"
        since="2.0"
        message="When instantiating a SimpleDateFormat object, specify a Locale"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#simpledateformatneedslocale">
        <description>
Be sure to specify a Locale when creating SimpleDateFormat instances to ensure that locale-appropriate
formatting is used.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//AllocationExpression
 [ClassOrInterfaceType[@Image='SimpleDateFormat']]
 [Arguments[@ArgumentCount=1]]
]]>
                    </value>
                 </property>
              </properties>
        <example>
        <![CDATA[
public class Foo {
  // Should specify Locale.US (or whatever)
  private SimpleDateFormat sdf = new SimpleDateFormat("pattern");
}
        ]]>
        </example>
    </rule>

  <rule name="ImmutableField"
        since="2.0"
        message="Private field ''{0}'' could be made final; it is only initialized in the declaration or constructor."
        class="net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#immutablefield">
      <description>
Identifies private fields whose values never change once they are initialized either in the declaration
of the field or by a constructor.  This helps in converting existing classes to becoming immutable ones.
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
public class Foo {
  private int x; // could be final
  public Foo() {
      x = 7;
  }
  public void foo() {
     int a = x + 2;
  }
}
  ]]>
      </example>
    </rule>

  <rule name="UseLocaleWithCaseConversions"
        language="java"
        since="2.0"
        message="When doing a String.toLowerCase()/toUpperCase() call, use a Locale"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#uselocalewithcaseconversions">
      <description>
When doing String.toLowerCase()/toUpperCase() conversions, use Locales to avoids problems with languages that
have unusual conventions, i.e. Turkish.
      </description>
      <priority>3</priority>
        <properties>
          <property name="xpath">
            <value>
                <![CDATA[
//PrimaryExpression
[
PrimaryPrefix
[Name[ends-with(@Image, 'toLowerCase') or ends-with(@Image, 'toUpperCase')]]
[following-sibling::PrimarySuffix[position() = 1]/Arguments[@ArgumentCount=0]]

or

PrimarySuffix
[ends-with(@Image, 'toLowerCase') or ends-with(@Image, 'toUpperCase')]
[following-sibling::PrimarySuffix[position() = 1]/Arguments[@ArgumentCount=0]]
]
[not(PrimaryPrefix/Name[ends-with(@Image, 'toHexString')])]
]]>
            </value>
          </property>
        </properties>
        <example>
    <![CDATA[
class Foo {
    // BAD
    if (x.toLowerCase().equals("list")) { }

    /*
     * This will not match "LIST" when in Turkish locale
     * The above could be
     * if (x.toLowerCase(Locale.US).equals("list")) { }
     * or simply
     * if (x.equalsIgnoreCase("list")) { }
     */
    // GOOD
    String z = a.toLowerCase(Locale.EN);
}
    ]]>
        </example>
    </rule>

  <rule name="AvoidProtectedFieldInFinalClass"
        language="java"
        since="2.1"
        message="Avoid protected fields in a final class.  Change to private or package access."
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#avoidprotectedfieldinfinalclass">
         <description>
Do not use protected fields in final classes since they cannot be subclassed.
Clarify your intent by using private or package access modifiers instead.
         </description>
         <priority>3</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Final='true']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/FieldDeclaration[@Protected='true']
 ]]>
                 </value>
             </property>
         </properties>
        <example>
<![CDATA[
public final class Bar {
  private int x;
  protected int y;  // bar cannot be subclassed, so is y really private or package visible?
  Bar() {}
}
 ]]>
         </example>
       </rule>

  <rule name="AssignmentToNonFinalStatic"
        since="2.2"
        message="Possible unsafe assignment to a non-final static field in a constructor."
        class="net.sourceforge.pmd.lang.java.rule.design.AssignmentToNonFinalStaticRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#assignmenttononfinalstatic">
       <description>
Identifies a possible unsafe usage of a static field.
       </description>
         <priority>3</priority>
       <example>
   <![CDATA[
public class StaticField {
   static int x;
   public FinalFields(int y) {
    x = y; // unsafe
   }
}
   ]]>
       </example>
     </rule>

  <rule name="MissingStaticMethodInNonInstantiatableClass"
        language="java"
        since="3.0"
        message="Class cannot be instantiated and does not provide any static methods or fields"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#missingstaticmethodinnoninstantiatableclass">
      <description>
A class that has private constructors and does not have any static methods or fields cannot be used.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ClassOrInterfaceDeclaration[@Nested='false']
[
  (
    ./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration
    and
    count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration) = count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private='true'])
  )
  and
  not(.//MethodDeclaration[@Static='true'])
  and
  not(.//FieldDeclaration[@Private='false'][@Static='true'])
  and
  not(.//ClassOrInterfaceDeclaration[@Nested='true']
           [@Public='true']
           [@Static='true']
           [not(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration) or ./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Public='true']]
           [./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
                [@Public='true']
                [./ResultType/Type/ReferenceType/ClassOrInterfaceType
                    [@Image = //ClassOrInterfaceDeclaration[@Nested='false']/@Image]
                ]
            ]
        )
]
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
// This class is unusable, since it cannot be
// instantiated (private constructor),
// and no static method can be called.

public class Foo {
  private Foo() {}
  void foo() {}
}

]]>
      </example>
    </rule>

  <rule name="AvoidSynchronizedAtMethodLevel"
        language="java"
        since="3.0"
        message="Use block level rather than method level synchronization"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#avoidsynchronizedatmethodlevel">
      <description>
Method-level synchronization can cause problems when new code is added to the method.
Block-level synchronization helps to ensure that only the code that needs synchronization
gets it.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//MethodDeclaration[@Synchronized='true']
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class Foo {
  // Try to avoid this:
  synchronized void foo() {
  }
  // Prefer this:
  void bar() {
    synchronized(this) {
    }
  }

  // Try to avoid this for static methods:
  static synchronized void fooStatic() {
  }

  // Prefer this:
  static void barStatic() {
    synchronized(Foo.class) {
    }
  }
}
]]>
      </example>
    </rule>

  <rule name="MissingBreakInSwitch"
        language="java"
        since="3.0"
        message="A switch statement does not contain a break"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#missingbreakinswitch">
      <description>
Switch statements without break or return statements for each case option
may indicate problematic behaviour. Empty cases are ignored as these indicate an intentional fall-through.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//SwitchStatement
[(count(.//BreakStatement)
 + count(BlockStatement//Statement/ReturnStatement)
 + count(BlockStatement//Statement/ContinueStatement)
 + count(BlockStatement//Statement/ThrowStatement)
 + count(BlockStatement//Statement/IfStatement[@Else='true' and Statement[2][ReturnStatement|ContinueStatement|ThrowStatement]]/Statement[1][ReturnStatement|ContinueStatement|ThrowStatement])
 + count(SwitchLabel[name(following-sibling::node()) = 'SwitchLabel'])
 + count(SwitchLabel[count(following-sibling::node()) = 0])
  < count (SwitchLabel))]
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public void bar(int status) {
    switch(status) {
      case CANCELLED:
        doCancelled();
        // break; hm, should this be commented out?
      case NEW:
        doNew();
        // is this really a fall-through?
      case REMOVED:
        doRemoved();
        // what happens if you add another case after this one?
      case OTHER: // empty case - this is interpreted as an intentional fall-through
      case ERROR:
        doErrorHandling();
        break;
    }
}
]]>
      </example>
    </rule>

  <rule name="UseNotifyAllInsteadOfNotify"
        language="java"
        since="3.0"
        message="Call Thread.notifyAll() rather than Thread.notify()"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#usenotifyallinsteadofnotify">
      <description>
Thread.notify() awakens a thread monitoring the object. If more than one thread is monitoring, then only
one is chosen.  The thread chosen is arbitrary; thus its usually safer to call notifyAll() instead.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//StatementExpression/PrimaryExpression
[PrimarySuffix/Arguments[@ArgumentCount = '0']]
[
    PrimaryPrefix[
        ./Name[@Image='notify' or ends-with(@Image,'.notify')]
        or ../PrimarySuffix/@Image='notify'
        or (./AllocationExpression and ../PrimarySuffix[@Image='notify'])
    ]
]
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
  void bar() {
    x.notify();
    // If many threads are monitoring x, only one (and you won't know which) will be notified.
    // use instead:
    x.notifyAll();
  }
]]>
      </example>
    </rule>

  <rule name="AvoidInstanceofChecksInCatchClause"
        language="java"
        since="3.0"
        message="An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type."
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#avoidinstanceofchecksincatchclause">
      <description>
Each caught exception type should be handled in its own catch clause.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//CatchStatement/FormalParameter
 /following-sibling::Block//InstanceOfExpression/PrimaryExpression/PrimaryPrefix
  /Name[
   @Image = ./ancestor::Block/preceding-sibling::FormalParameter
    /VariableDeclaratorId/@Image
  ]
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
try { // Avoid this
    // do something
} catch (Exception ee) {
    if (ee instanceof IOException) {
        cleanup();
    }
}

try {  // Prefer this:
    // do something
} catch (IOException ee) {
    cleanup();
}
]]>
      </example>
    </rule>

  <rule name="AbstractClassWithoutAbstractMethod"
        language="java"
        since="3.0"
        message="This abstract class does not have any abstract methods"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#abstractclasswithoutabstractmethod">
      <description>
The abstract class does not contain any abstract methods. An abstract class suggests
an incomplete implementation, which is to be completed by subclasses implementing the
abstract methods. If the class is intended to be used as a base class only (not to be instantiated
directly) a protected constructor can be provided prevent direct instantiation.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value><![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true'
  and count( .//MethodDeclaration[@Abstract='true'] )=0 ]
  [count(ImplementsList)=0]
  [count(.//ExtendsList)=0]
              ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public abstract class Foo {
  void int method1() { ... }
  void int method2() { ... }
  // consider using abstract methods or removing
  // the abstract modifier and adding protected constructors
}
]]>
      </example>
    </rule>

  <rule name="SimplifyConditional"
        language="java"
        since="3.1"
        message="No need to check for null before an instanceof"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#simplifyconditional">
          <description>
No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.
          </description>
          <priority>3</priority>
          <properties>
              <property name="xpath">
                  <value>
                      <![CDATA[
//Expression
 [ConditionalOrExpression
 [EqualityExpression[@Image='==']
  //NullLiteral
  and
  UnaryExpressionNotPlusMinus
   [@Image='!']//InstanceOfExpression[PrimaryExpression
     //Name/@Image = ancestor::ConditionalOrExpression/EqualityExpression
      /PrimaryExpression/PrimaryPrefix/Name/@Image]
  and
  (count(UnaryExpressionNotPlusMinus) + 1 = count(*))
 ]
or
ConditionalAndExpression
 [EqualityExpression[@Image='!=']//NullLiteral
 and
InstanceOfExpression
 [PrimaryExpression[count(PrimarySuffix[@ArrayDereference='true'])=0]
  //Name[not(contains(@Image,'.'))]/@Image = ancestor::ConditionalAndExpression
   /EqualityExpression/PrimaryExpression/PrimaryPrefix/Name/@Image]
 and
(count(InstanceOfExpression) + 1 = count(*))
 ]
]
 ]]>
                  </value>
              </property>
          </properties>
           <example>
      <![CDATA[
class Foo {
  void bar(Object x) {
    if (x != null && x instanceof Bar) {
      // just drop the "x != null" check
    }
  }
}      ]]>
           </example>
        </rule>

  <rule name="CompareObjectsWithEquals"
        since="3.2"
        message="Use equals() to compare object references."
        class="net.sourceforge.pmd.lang.java.rule.design.CompareObjectsWithEqualsRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#compareobjectswithequals">
  <description>
Use equals() to compare object references; avoid comparing them with ==.
  </description>
  <priority>3</priority>
  <example>
<![CDATA[
class Foo {
  boolean bar(String a, String b) {
    return a == b;
  }
}

]]>
  </example>
</rule>

  <rule name="PositionLiteralsFirstInComparisons"
        language="java"
        since="3.3"
        message="Position literals first in String comparisons"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#positionliteralsfirstincomparisons">
  <description>
Position literals first in comparisons, if the second argument is null then NullPointerExceptions
can be avoided, they will just return false.
  </description>
  <priority>3</priority>
  <properties>
      <property name="xpath">
          <value>
              <![CDATA[
//PrimaryExpression[
    PrimaryPrefix[Name[(ends-with(@Image, '.equals'))]]
        [
            (../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal[@StringLiteral='true'])
            and
            ( count(../PrimarySuffix/Arguments/ArgumentList/Expression) = 1 )
        ]
]
[not(ancestor::Expression/ConditionalAndExpression//EqualityExpression[@Image='!=']//NullLiteral)]
[not(ancestor::Expression/ConditionalOrExpression//EqualityExpression[@Image='==']//NullLiteral)]
          ]]>
          </value>
      </property>
  </properties>
  <example>
<![CDATA[
class Foo {
  boolean bar(String x) {
    return x.equals("2"); // should be "2".equals(x)
  }
}

]]>
  </example>
</rule>

  <rule name="PositionLiteralsFirstInCaseInsensitiveComparisons"
        language="java"
        since="5.1"
        message="Position literals first in String comparisons for EqualsIgnoreCase"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#positionliteralsfirstincaseinsensitivecomparisons">
  <description>
Position literals first in comparisons, if the second argument is null then NullPointerExceptions
can be avoided, they will just return false.
  </description>
  <priority>3</priority>
  <properties>
      <property name="xpath">
          <value>
              <![CDATA[
//PrimaryExpression[
        PrimaryPrefix[Name
                [
    (ends-with(@Image, '.equalsIgnoreCase'))
                ]
        ]
        [
                   (../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal)
    and
    ( count(../PrimarySuffix/Arguments/ArgumentList/Expression) = 1 )
        ]
]
[not(ancestor::Expression/ConditionalAndExpression//EqualityExpression[@Image='!=']//NullLiteral)]
[not(ancestor::Expression/ConditionalOrExpression//EqualityExpression[@Image='==']//NullLiteral)]

          ]]>
          </value>
      </property>
  </properties>
  <example>
<![CDATA[
class Foo {
  boolean bar(String x) {
    return x.equalsIgnoreCase("2"); // should be "2".equalsIgnoreCase(x)
  }
}

]]>
  </example>
</rule>


  <rule name="UnnecessaryLocalBeforeReturn"
        since="3.3"
        message="Consider simply returning the value vs storing it in local variable ''{0}''"
        class="net.sourceforge.pmd.lang.java.rule.design.UnnecessaryLocalBeforeReturnRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#unnecessarylocalbeforereturn">
      <description>
Avoid the creation of unnecessary local variables
      </description>
        <priority>3</priority>
      <example>
  <![CDATA[
public class Foo {
   public int foo() {
     int x = doSomething();
     return x;  // instead, just 'return doSomething();'
   }
}
  ]]>
      </example>
    </rule>

  <rule name="NonThreadSafeSingleton"
        since="3.4"
        message="Singleton is not thread safe"
        class="net.sourceforge.pmd.lang.java.rule.design.NonThreadSafeSingletonRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#nonthreadsafesingleton">
        <description>
Non-thread safe singletons can result in bad state changes. Eliminate
static singletons if possible by instantiating the object directly. Static
singletons are usually not needed as only a single instance exists anyway.
Other possible fixes are to synchronize the entire method or to use an
[initialize-on-demand holder class](https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom).

Refrain from using the double-checked locking pattern. The Java Memory Model doesn't
guarantee it to work unless the variable is declared as `volatile`, adding an uneeded
performance penalty. [Reference](http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)

See Effective Java, item 48.
        </description>
        <priority>3</priority>
        <example><![CDATA[
private static Foo foo = null;

//multiple simultaneous callers may see partially initialized objects
public static Foo getFoo() {
    if (foo==null) {
        foo = new Foo();
    }
    return foo;
}
        ]]></example>
    </rule>

  <rule name="SingleMethodSingleton"
        since="5.4"
        message="Class contains multiple getInstance methods. Please review."
        class="net.sourceforge.pmd.lang.java.rule.design.SingleMethodSingletonRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#singlemethodsingleton">
    <description>
Some classes contain overloaded getInstance. The problem with overloaded getInstance methods
is that the instance created using the overloaded method is not cached and so,
for each call and new objects will be created for every invocation.
    </description>
    <priority>2</priority>
    <example><![CDATA[
public class Singleton {

    private static Singleton singleton = new Singleton( );

    private Singleton(){ }

    public static Singleton getInstance( ) {
        return singleton;
    }

    public static Singleton getInstance(Object obj){
        Singleton singleton = (Singleton) obj;
        return singleton;           //violation
    }
}
]]>
    </example>
  </rule>

  <rule name="SingletonClassReturningNewInstance"
        since="5.4"
        message="getInstance method always creates a new object and hence does not comply to Singleton Design Pattern behaviour. Please review"
        class="net.sourceforge.pmd.lang.java.rule.design.SingletonClassReturningNewInstanceRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#singletonclassreturningnewinstance">
    <description>
Some classes contain overloaded getInstance. The problem with overloaded getInstance methods
is that the instance created using the overloaded method is not cached and so,
for each call and new objects will be created for every invocation.
    </description>
    <priority>2</priority>
    <example><![CDATA[
class Singleton {
    private static Singleton instance = null;
    public static Singleton getInstance() {
        synchronized(Singleton.class) {
            return new Singleton();
        }
    }
}
]]>
    </example>
  </rule>

  <rule name="UncommentedEmptyMethodBody"
        language="java"
        since="3.4"
        message="Document empty method body"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#uncommentedemptymethodbody">
      <description>
Uncommented Empty Method Body finds instances where a method body does not contain
statements, but there is no comment. By explicitly commenting empty method bodies
it is easier to distinguish between intentional (commented) and unintentional
empty methods.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//MethodDeclaration/Block[count(BlockStatement) = 0 and @containsComment = 'false']
 ]]>
             </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public void doSomething() {
}
 ]]>
      </example>
    </rule>

  <rule name="UncommentedEmptyConstructor"
        language="java"
        since="3.4"
        message="Document empty constructor"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        typeResolution="true"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#uncommentedemptyconstructor">
      <description>
Uncommented Empty Constructor finds instances where a constructor does not
contain statements, but there is no comment. By explicitly commenting empty
constructors it is easier to distinguish between intentional (commented)
and unintentional empty constructors.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ConstructorDeclaration[@Private='false']
                        [count(BlockStatement) = 0 and ($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false']
                        [not(../Annotation/MarkerAnnotation/Name[typeof(@Image, 'javax.inject.Inject', 'Inject')])]
]]>
             </value>
          </property>
          <property name="ignoreExplicitConstructorInvocation" type="Boolean" description="Ignore explicit constructor invocation when deciding whether constructor is empty or not" value="false"/>
      </properties>
      <example>
  <![CDATA[
public Foo() {
  // This constructor is intentionally empty. Nothing special is needed here.
}
 ]]>
      </example>
    </rule>

  <rule name="UnsynchronizedStaticDateFormatter"
        since="3.6"
        message="Static DateFormatter objects should be accessed in a synchronized manner"
        class="net.sourceforge.pmd.lang.java.rule.design.UnsynchronizedStaticDateFormatterRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#unsynchronizedstaticdateformatter">
      <description>
SimpleDateFormat instances are not synchronized. Sun recommends using separate format instances
for each thread. If multiple threads must access a static formatter, the formatter must be
synchronized either on method or block level.
      </description>
      <priority>3</priority>
      <example>
    <![CDATA[
public class Foo {
    private static final SimpleDateFormat sdf = new SimpleDateFormat();
    void bar() {
        sdf.format(); // poor, no thread-safety
    }
    synchronized void foo() {
        sdf.format(); // preferred
    }
}
    ]]>
      </example>
    </rule>

  <rule name="PreserveStackTrace"
        since="3.7"
        message="New exception is thrown in catch block, original stack trace may be lost"
        class="net.sourceforge.pmd.lang.java.rule.design.PreserveStackTraceRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#preservestacktrace">
      <description>
Throwing a new exception from a catch block without passing the original exception into the
new exception will cause the original stack trace to be lost making it difficult to debug
effectively.
      </description>
      <priority>3</priority>
      <example>
    <![CDATA[
public class Foo {
    void good() {
        try{
            Integer.parseInt("a");
        } catch (Exception e) {
            throw new Exception(e); // first possibility to create exception chain
        }
        try {
            Integer.parseInt("a");
        } catch (Exception e) {
            throw (IllegalStateException)new IllegalStateException().initCause(e); // second possibility to create exception chain.
        }
    }
    void bad() {
        try{
            Integer.parseInt("a");
        } catch (Exception e) {
            throw new Exception(e.getMessage());
        }
    }
}
    ]]>
      </example>
    </rule>

  <rule name="UseCollectionIsEmpty"
        since="3.9"
        message="Substitute calls to size() == 0 (or size() != 0, size() &gt; 0, size() &lt; 1) with calls to isEmpty()"
        class="net.sourceforge.pmd.lang.java.rule.design.UseCollectionIsEmptyRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#usecollectionisempty">
         <description>
The isEmpty() method on java.util.Collection is provided to determine if a collection has any elements.
Comparing the value of size() to 0 does not convey intent as well as the isEmpty() method.
      </description>
      <priority>3</priority>
      <example>
    <![CDATA[
public class Foo {
    void good() {
        List foo = getList();
        if (foo.isEmpty()) {
            // blah
        }
    }

    void bad() {
        List foo = getList();
        if (foo.size() == 0) {
            // blah
        }
    }
}
    ]]>
      </example>
    </rule>

  <rule name="ClassWithOnlyPrivateConstructorsShouldBeFinal"
        language="java"
        since="4.1"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        message="A class which only has private constructors should be final"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#classwithonlyprivateconstructorsshouldbefinal">
        <description>
A class with only private constructors should be final, unless the private constructor
is invoked by a inner class.
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
TypeDeclaration[count(../TypeDeclaration) = 1]/ClassOrInterfaceDeclaration
[@Final = 'false']
[count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private = 'true']) >= 1 ]
[count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[(@Public = 'true') or (@Protected = 'true') or (@PackagePrivate = 'true')]) = 0 ]
[not(.//ClassOrInterfaceDeclaration)]
             ]]></value>
            </property>
        </properties>
        <example><![CDATA[
public class Foo {  //Should be final
    private Foo() { }
}
     ]]></example>
    </rule>


  <rule name="EmptyMethodInAbstractClassShouldBeAbstract"
        language="java"
        since="4.1"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        message="An empty method in an abstract class should be abstract instead"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#emptymethodinabstractclassshouldbeabstract">
        <description>
Empty or auto-generated methods in an abstract class should be tagged as abstract. This helps to remove their inapproprate
usage by developers who should be implementing their own versions in the concrete subclasses.
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                <![CDATA[
                    //ClassOrInterfaceDeclaration[@Abstract = 'true']
                        /ClassOrInterfaceBody
                        /ClassOrInterfaceBodyDeclaration
                        /MethodDeclaration[@Abstract = 'false' and @Native = 'false']
                        [
                            ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral) = 'true' )
                            or
                            ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image = '0']) = 'true' )
                            or
                            ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) = 2]) = 'true' )
                            or
                            (./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/EmptyStatement)
                            or
                            ( count (./Block/*) = 0 )
                        ]
                ]]>
             </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public abstract class ShouldBeAbstract {
    public Object couldBeAbstract() {
        // Should be abstract method ?
        return null;
    }

    public void couldBeAbstract() {
    }
}
]]>
    </example>
  </rule>

  <rule name="SingularField"
        since="3.1"
        message="Perhaps ''{0}'' could be replaced by a local variable."
        class="net.sourceforge.pmd.lang.java.rule.design.SingularFieldRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#singularfield">
    <description>
Fields whose scopes are limited to just single methods do not rely on the containing
object to provide them to other methods. They may be better implemented as local variables
within those methods.
      </description>
      <priority>3</priority>
      <example><![CDATA[
public class Foo {
    private int x;  // no reason to exist at the Foo instance level
    public void foo(int y) {
     x = y + 5;
     return x;
    }
}
   ]]></example>
    </rule>

  <rule name="ReturnEmptyArrayRatherThanNull"
        language="java"
        since="4.2"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        message="Return an empty array rather than 'null'."
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#returnemptyarrayratherthannull">
        <description>
For any method that returns an array, it is a better to return an empty array rather than a
null reference. This removes the need for null checking all results and avoids inadvertent
NullPointerExceptions.
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
                        //MethodDeclaration
                        [
                        (./ResultType/Type[@Array='true'])
                        and
                        (./Block/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral)
                        ]
                    ]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
public class Example {
    // Not a good idea...
    public int[] badBehavior() {
        // ...
        return null;
    }

    // Good behavior
    public String[] bonnePratique() {
        //...
        return new String[0];
    }
}
            ]]></example>
    </rule>

  <rule name="AbstractClassWithoutAnyMethod"
        language="java"
        since="4.2"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        typeResolution="true"
        message="No abstract method which means that the keyword is most likely used to prevent instantiation. Use a private or protected constructor instead."
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#abstractclasswithoutanymethod">
        <description>
If an abstract class does not provides any methods, it may be acting as a simple data container
that is not meant to be instantiated. In this case, it is probably better to use a private or
protected constructor in order to prevent instantiation than make the class misleadingly abstract.
       </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration
    [@Abstract = 'true']
    [count(//MethodDeclaration) + count(//ConstructorDeclaration) = 0]
    [not(../Annotation/MarkerAnnotation/Name[typeof(@Image, 'com.google.auto.value.AutoValue', 'AutoValue')])]
                    ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class abstract Example {
    String field;
    int otherField;
}
            ]]>
        </example>
    </rule>

  <rule name="TooFewBranchesForASwitchStatement"
        language="java"
        since="4.2"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        message="A switch with less than three branches is inefficient, use a 'if statement' instead."
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#toofewbranchesforaswitchstatement">
        <description>
Switch statements are intended to be used to support complex branching behaviour. Using a switch for only a few
cases is ill-advised, since switches are not as easy to understand as if-then statements. In these cases use the
if-then statement to increase code readability.
        </description>
        <priority>3</priority>
        <properties>
            <property name="minimumNumberCaseForASwitch" type="Integer" description="Minimum number of branches for a switch" min="1" max="100" value="3"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//SwitchStatement[
    (count(.//SwitchLabel) < $minimumNumberCaseForASwitch)
]
                    ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
// With a minimumNumberCaseForASwitch of 3
public class Foo {
    public void bar() {
        switch (condition) {
            case ONE:
                instruction;
                break;
            default:
                break; // not enough for a 'switch' stmt, a simple 'if' stmt would have been more appropriate
        }
    }
}
            ]]>
        </example>
    </rule>

  <rule name="LogicInversion"
        language="java"
        since="5.0"
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        message="Use opposite operator instead of the logic complement operator."
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#logicinversion">
    <description>
Use opposite operator instead of negating the whole expression with a logic complement operator.
    </description>
    <priority>3</priority>
    <properties>
       <property name="xpath">
          <value>
          <![CDATA[
//UnaryExpressionNotPlusMinus[@Image='!']/PrimaryExpression/PrimaryPrefix/Expression[EqualityExpression or RelationalExpression]
          ]]>
          </value>
       </property>
    </properties>
    <example>
    <![CDATA[
public boolean bar(int a, int b) {

    if (!(a == b)) { // use !=
         return false;
     }

    if (!(a < b)) { // use >=
         return false;
    }

    return true;
}
    ]]>
    </example>
  </rule>

  <rule name="UseVarargs"
        language="java"
        minimumLanguageVersion="1.5"
        since="5.0"
        message="Consider using varargs for methods or constructors which take an array the last parameter."
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#usevarargs">
        <description>
Java 5 introduced the varargs parameter declaration for methods and constructors.  This syntactic
sugar provides flexibility for users of these methods and constructors, allowing them to avoid
having to deal with the creation of an array.
</description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FormalParameters/FormalParameter
    [position()=last()]
    [@Array='true']
    [@Varargs='false']
    [not (./Type/ReferenceType[@Array='true'][PrimitiveType[@Image='byte']])]
    [not (./Type/ReferenceType[ClassOrInterfaceType[@Image='Byte']])]
    [not (./Type/PrimitiveType[@Image='byte'])]
    [not (ancestor::MethodDeclaration/preceding-sibling::Annotation/*/Name[@Image='Override'])]
    [not(
        ancestor::MethodDeclaration
            [@Public='true' and @Static='true']
            [child::ResultType[@Void='true']] and
        ancestor::MethodDeclarator[@Image='main'] and
        ..[@ParameterCount='1'] and
        ./Type/ReferenceType[ClassOrInterfaceType[@Image='String']]
    )]
            ]]></value>
            </property>
        </properties>
        <example><![CDATA[
public class Foo {
    public void foo(String s, Object[] args) {
        // Do something here...
    }

    public void bar(String s, Object... args) {
        // Ahh, varargs tastes much better...
    }
}
        ]]></example>
    </rule>

  <rule name="FieldDeclarationsShouldBeAtStartOfClass"
        language="java"
        since="5.0"
        message="Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes."
        class="net.sourceforge.pmd.lang.java.rule.design.FieldDeclarationsShouldBeAtStartOfClassRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#fielddeclarationsshouldbeatstartofclass">
    <description>
Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
    </description>
    <priority>3</priority>
    <example>
      <![CDATA[
public class HelloWorldBean {

  // Field declared before methods / inner classes - OK
  private String _thing;

  public String getMessage() {
    return "Hello World!";
  }

  // Field declared after methods / inner classes - avoid this
  private String _fieldInWrongLocation;
}
      ]]>
    </example>
  </rule>

  <rule name="GodClass"
        language="java"
        since="5.0"
        message="Possible God Class (WMC={0}, ATFD={2}, TCC={1})"
        metrics="true"
        class="net.sourceforge.pmd.lang.java.rule.design.GodClassRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#godclass">
        <description>
The God Class rule detects the God Class design flaw using metrics. God classes do too many things,
are very big and overly complex. They should be split apart to be more object-oriented.
The rule uses the detection strategy described in "Object-Oriented Metrics in Practice".
The violations are reported against the entire class.

See also the references:

Michele Lanza and Radu Marinescu. Object-Oriented Metrics in Practice:
Using Software Metrics to Characterize, Evaluate, and Improve the Design
of Object-Oriented Systems. Springer, Berlin, 1 edition, October 2006. Page 80.
        </description>
        <priority>3</priority>
    </rule>

  <rule name="AvoidProtectedMethodInFinalClassNotExtending"
        language="java"
        since="5.1"
        message="Avoid protected methods in a final class that doesn't extend anything other than Object.  Change to private or package access."
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#avoidprotectedmethodinfinalclassnotextending">
         <description>
Do not use protected methods in most final classes since they cannot be subclassed. This should
only be allowed in final classes that extend other classes with protected methods (whose
visibility cannot be reduced). Clarify your intent by using private or package access modifiers instead.
         </description>
         <priority>3</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Final='true' and not(ExtendsList)]
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/MethodDeclaration[@Protected='true'][MethodDeclarator/@Image != 'finalize']
 ]]>
                 </value>
             </property>
         </properties>
        <example>
<![CDATA[
public final class Foo {
  private int bar() {}
  protected int baz() {} // Foo cannot be subclassed, and doesn't extend anything, so is baz() really private or package visible?
}
 ]]>
         </example>
       </rule>

  <rule name="ConstantsInInterface"
        language="java"
        since="5.5"
        message="Avoid constants in interfaces. Interfaces define types, constants are implementation details better placed in classes or enums. See Effective Java, item 19."
        class="net.sourceforge.pmd.lang.rule.XPathRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#constantsininterface">
        <description>
Avoid constants in interfaces. Interfaces should define types, constants are implementation details
better placed in classes or enums. See Effective Java, item 19.
        </description>
        <priority>3</priority>
        <properties>
        <property name="ignoreIfHasMethods" type="Boolean" description="Whether to ignore constants in interfaces if the interface defines any methods" value="true"/>
            <property name="xpath">
                <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Interface='true'][$ignoreIfHasMethods='false' or not(.//MethodDeclaration)]//FieldDeclaration
 ]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public interface ConstantInterface {
    public static final int CONST1 = 1; // violation, no fields allowed in interface!
    static final int CONST2 = 1;        // violation, no fields allowed in interface!
    final int CONST3 = 1;               // violation, no fields allowed in interface!
    int CONST4 = 1;                     // violation, no fields allowed in interface!
}

// with ignoreIfHasMethods = false
public interface AnotherConstantInterface {
    public static final int CONST1 = 1; // violation, no fields allowed in interface!

    int anyMethod();
}

// with ignoreIfHasMethods = true
public interface YetAnotherConstantInterface {
    public static final int CONST1 = 1; // no violation

    int anyMethod();
}
 ]]>
        </example>
    </rule>

  <rule name="AccessorMethodGeneration"
        language="java"
        since="5.5.4"
        message="Avoid autogenerated methods to access private fields and methods of inner / outer classes"
        class="net.sourceforge.pmd.lang.java.rule.design.AccessorMethodGenerationRule"
        externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#accessormethodgeneration">
        <description>
When accessing a private field / method from another class, the Java compiler will generate a accessor methods
with package-private visibility. This adds overhead, and to the dex method count on Android. This situation can
be avoided by changing the visibility of the field / method from private to package-private.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class OuterClass {
    private int counter;
    /* package */ int id;

    public class InnerClass {
        InnerClass() {
            OuterClass.this.counter++; // wrong accessor method will be generated
        }

        public int getOuterClassId() {
            return OuterClass.this.id; // id is package-private, no accessor method needed
        }
    }
}
 ]]>
        </example>
    </rule>
</ruleset>
