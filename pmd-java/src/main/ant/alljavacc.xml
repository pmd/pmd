<project name="pmd" default="alljavacc" basedir="../../">

    <property name="javacc-home.path" value="target/lib" />
    <property name="target-package-dir" value="${target}/net/sourceforge/pmd/lang/java/ast" />
    <property name="stamp-file" value="${target}/../../last-generated-timestamp"/>

    <!-- Matches the names of deprecated node types to add a @Deprecated annotation -->
    <property name="deprecated-nodes-pattern" value="ASTR(UN)?SIGNEDSHIFT" />

    <!-- Visitor names -->
    <property name="base-visitor-interface-name" value="JavaParserVisitor" />
    <property name="base-visitor-interface-file" value="${target-package-dir}/${base-visitor-interface-name}.java" />

    <property name="generic-sideeffect-visitor-interface-name" value="SideEffectingVisitor" />
    <property name="generic-sideeffect-visitor-interface-file"
              value="${target-package-dir}/${generic-sideeffect-visitor-interface-name}.java" />

    <!-- TARGETS -->

    <target name="alljavacc"
            description="Generates all JavaCC aspects within PMD"
            depends="checkUpToDate,init,javajjtree,cleanup" />

    <target name="checkUpToDate">
        <uptodate property="javaccBuildNotRequired" targetfile="${stamp-file}">
            <srcfiles dir="etc/grammar" includes="*.jj*"/>
            <srcfiles file="src/main/ant/alljavacc.xml" />
        </uptodate>
        <echo message="up to date check: javaccBuildNotRequired=${javaccBuildNotRequired}"/>
    </target>

    <target name="init" unless="javaccBuildNotRequired">
        <mkdir dir="${javacc-home.path}" />
        <copy file="${javacc.jar}" tofile="${javacc-home.path}/javacc.jar" />

        <mkdir dir="${target}"/>
        <touch file="${stamp-file}"/>
    </target>

    <target name="cleanup">
        <delete dir="${javacc-home.path}" />
    </target>

    <target name="javajjtree" description="Generates the Java parser and AST source files" unless="javaccBuildNotRequired">
        <delete dir="${target-package-dir}" />
        <mkdir dir="${target-package-dir}" />
        <jjtree target="etc/grammar/Java.jjt"
                outputdirectory="${target-package-dir}"
                javacchome="${javacc-home.path}" />
        <!-- Ensure generated using CharStream interface -->
        <javacc static="false"
                usercharstream="true"
                target="${target-package-dir}/Java.jj"
                outputdirectory="${target-package-dir}"
                javacchome="${javacc-home.path}" />
        <delete file="${target-package-dir}/Node.java" />
        <delete file="${target-package-dir}/SimpleNode.java" />
        <delete file="${target-package-dir}/CharStream.java" />
        <delete file="${target-package-dir}/TokenMgrError.java" />


        <replace file="${target-package-dir}/JJTJavaParserState.java">
            <replacefilter token="/*" value="/**"/>
            <replacetoken><![CDATA[  /* Pushes a node on to the stack. */]]></replacetoken>
            <replacevalue>
                <![CDATA[
 /**
  * Extend the number of children of the current node of one to the left.
  * If the node is closed, one additional node from the stack will be popped
  * and added to its children. This allows mimicking "left-recursive" nodes,
  * while keeping the parsing iterative.
  *
  * <p>Note that when the total number of children is definitely known, you
  * can use "definite nodes", ie write the expected number of children (including
  * the ones to the left) in the JJTree annotation (eg {@code #AdditiveExpression(2)}).
  * So this is only useful when the number of children of the current node is not certain.
  *
  * <p>This method does not affect the stack unless the current jjtThis is
  * closed in the future.
  */
  public void extendLeft() {
    mk--;
  }

  /**
   * Peek the nth node from the top of the stack.
   * peekNode(0) == peekNode()
   */
  public Node peekNode(int n) {
    return nodes.get(nodes.size() - n - 1);
  }

  public boolean isInjectionPending() {
    return numPendingInjection > 0;
  }

  /** If non-zero, then the top "n" nodes of the stack will be injected as the first children of the next
    * node to be opened. This is not very flexible, but it's enough. The grammar needs to take
    * care of the order in which nodes are opened in a few places, in most cases this just means using
    * eg A() B() #N(2) instead of (A() B()) #N, so as not to open N before A.
    */
  private int numPendingInjection;

  public void injectRight(int n) {
       numPendingInjection = n;
  }

  /* Pushes a node on to the stack. */]]>
            </replacevalue>
        </replace>

        <replace file="${target-package-dir}/JJTJavaParserState.java">
<!--  This is in openNodeScope.                                      -->
<!--  If injection is pending, we bump the arity of the opened node. -->
<!--  When it's closed, it will enclose the injected node.           -->
            <replacetoken><![CDATA[mk = sp;]]></replacetoken>
            <replacevalue><![CDATA[
    mk = sp;
    if (isInjectionPending()) {
        mk -= numPendingInjection;
        numPendingInjection = 0;
    }]]>
            </replacevalue>
        </replace>


        <replace file="${target-package-dir}/JavaParserTokenManager.java"
                 token="class JavaParserTokenManager"
                 value="class JavaParserTokenManager extends net.sourceforge.pmd.lang.ast.AbstractTokenManager" />
        <replace file="${target-package-dir}/JavaParser.java"
                 token="throw new Error"
                 value="throw new RuntimeException" />
        <replace file="${target-package-dir}/ParseException.java"
                 token="extends Exception"
                 value="extends net.sourceforge.pmd.lang.ast.ParseException" />

        <!-- VISITORS -->


        <!-- Base visitor with Object everywhere -->
        <!-- We perform most changes like adding default methods, etc on this one -->
        <!-- Changes are then copied on other visitors -->
        <replace file="${base-visitor-interface-file}">
            <replacefilter token="public interface" value="
public interface" />
            <replacefilter token="JavaParserVisitor" value="${base-visitor-interface-name}" />
            <replacefilter token="SimpleNode" value="JavaNode" />
            <!-- Default methods -->
            <replacefilter token="public Object visit(" value="default Object visit(" />
            <replacefilter token=");" value=") { return visit((JavaNode) node, data); }" />
            <replacefilter token="default Object visit(JavaNode node, Object data) { return visit((JavaNode) node, data); }"
                           value="default Object visit(JavaNode node, Object data) { return node.childrenAccept(this, data); }" />
        </replace>

        <!-- Deprecated nodes -->
        <replaceregexp file="${base-visitor-interface-file}"
                       match="default Object visit\((${deprecated-nodes-pattern})"
                       byline="true"
                       replace="@Deprecated \0" />

        <!-- Side effecting visitor, no return type, one generic parameter -->
        <copy file="${base-visitor-interface-file}" tofile="${generic-sideeffect-visitor-interface-file}" />
        <replace file="${generic-sideeffect-visitor-interface-file}">
            <replacefilter token="${base-visitor-interface-name}" value="${generic-sideeffect-visitor-interface-name}&lt;T>" />

            <replacefilter token="Object" value="T" />
            <replacefilter token="T visit" value="void visit" />
            <replacefilter token="return data;" value="" />
            <replacefilter token="return " value="" />
        </replace>

        <replace file="${target-package-dir}/JJTJavaParserState.java">
            <replacetoken>public class</replacetoken>
            <replacevalue><![CDATA[import net.sourceforge.pmd.lang.ast.Node;

public class]]></replacevalue>
        </replace>

        <replace file="${target-package-dir}/Token.java">
            <replacetoken><![CDATA[      default : return new Token(ofKind, image);
    }
  }
]]></replacetoken>
            <replacevalue><![CDATA[      case JavaParserConstants.RUNSIGNEDSHIFT :
      case JavaParserConstants.RSIGNEDSHIFT :
      case JavaParserConstants.GT:
        return new GTToken(ofKind, image);
      default : return new Token(ofKind, image);
    }
  }

  public static final class GTToken extends Token {
    public int realKind = JavaParserConstants.GT;
    public GTToken(int ofKind, String image) {
       super(ofKind, image);
    }
  }
]]></replacevalue>
        </replace>

        <replace file="${target-package-dir}/Token.java">
            <replacetoken>public class Token implements java.io.Serializable</replacetoken>
            <replacevalue><![CDATA[import net.sourceforge.pmd.lang.ast.GenericToken;

public class Token implements GenericToken, java.io.Serializable]]></replacevalue>
        </replace>

        <!--Add implementation methods of GenericToken-->
        <replace file="${target-package-dir}/Token.java">
            <replacetoken>public Token specialToken;</replacetoken>
            <replacevalue><![CDATA[public Token specialToken;

  @Override
  public GenericToken getNext() {
    return next;
  }

  @Override
  public GenericToken getPreviousComment() {
    return specialToken;
  }

  @Override
  public String getImage() {
    return image;
  }

  @Override
  public int getBeginLine() {
    return beginLine;
  }

  @Override
  public int getEndLine() {
    return endLine;
  }

  @Override
  public int getBeginColumn() {
    return beginColumn;
  }

  @Override
  public int getEndColumn() {
    return endColumn;
  }

]]></replacevalue>
        </replace>

        <delete>
            <fileset dir="${target-package-dir}">
                <include name="AST*.java" />
            </fileset>
        </delete>
    </target>
</project>
