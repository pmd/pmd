/* Generated By:JJTree&JavaCC: Do not edit this line. PLSQLParser.java */
/* Copyright (C) 2002 Albert Tumanov

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

*/

package net.sourceforge.pmd.lang.plsql.ast;

import java.io.*;

public class PLSQLParser/*@bgen(jjtree)*/implements PLSQLParserTreeConstants, PLSQLParserConstants {/*@bgen(jjtree)*/
  protected JJTPLSQLParserState jjtree = new JJTPLSQLParserState();
  /**
   * main method, for testing only.
   * @param args
   */
  public static void main(String[] args)
      throws ParseException {

    PLSQLParser parser = new PLSQLParser(System.in);
    SimpleNode simpleNode = parser.Input();

    String s;
    s = "qwerty";
//    System.err.println(s + " -> " + parser.purifyIdentifier(s));
    s = "\u005c"qwerty\u005c"";
//    System.err.println(s + " -> " + parser.purifyIdentifier(s));
    s = "\u005c"qwerty\u005c".uiop";
//    System.err.println(s + " -> " + parser.purifyIdentifier(s));
    s = "\u005c"qwerty\u005c".\u005c"uiop\u005c"";
//    System.err.println(s + " -> " + parser.purifyIdentifier(s));
  }

    /** Act on the Node when opening scope. 
    */
    void jjtreeOpenNodeScope(Node n)
    {
    }

    /** Act on the Node when closing scope. 
    */
    void jjtreeCloseNodeScope(Node n)
    {
      //Set the Nodes' beginLine,beginColumn,endLine,endColumn fields from the generic 
        Token firstToken = ((SimpleNode) n).jjtGetFirstToken();
       /*
         The generated code sets the last token after closing the scope, so getLastToken 
         cannot be used to identify the last Token: use getToken(0) instead. 
         <code>
	      jjtreeCloseNodeScope(jjtn000);
	      jjtn000.jjtSetLastToken(getToken(0));
         </code>
        Token lastToken  = ((SimpleNode) n).jjtGetLastToken();
        */
        Token lastToken  = getToken(0);


        ((SimpleNode) n).testingOnly__setBeginLine(firstToken.beginLine);
        ((SimpleNode) n).testingOnly__setBeginColumn(firstToken.beginColumn);
        ((SimpleNode) n).testingOnly__setEndLine((null==lastToken) ? firstToken.endLine : lastToken.endLine);
        ((SimpleNode) n).testingOnly__setEndColumn((null==lastToken) ? firstToken.endColumn : lastToken.endColumn);
    }

/**
 * 2006-05-22 - Matthias Hendler - Added parsing of triggers and global functions/procedures
 *                                 Refactored printing of custom tags into the XML/DOM.
 *                                 Custom tags are language independent. Reserved tags are linked
 *                                 to the documented language like RETURN, PARAM and THROWS.
 */

/**
 * 2006-05-22 - Matthias Hendler - added globalBody()
 */
  final public ASTInput Input() throws ParseException {
                    /*@bgen(jjtree) Input */
  ASTInput jjtn000 = new ASTInput(this, JJTINPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      label_1:
      while (true) {
        switch (jj_nt.kind) {
        case 2:
        case 3:
        case ALTER:
        case BEGIN:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONNECT:
        case CREATE:
        case DECLARE:
        case DELETE:
        case DROP:
        case EXECUTE:
        case EXIT:
        case FUNCTION:
        case GRANT:
        case INSERT:
        case LOCK:
        case MERGE:
        case PACKAGE:
        case PROMPT:
        case PROCEDURE:
        case REVOKE:
        case ROLLBACK:
        case SAVEPOINT:
        case SELECT:
        case SET:
        case START:
        case TRIGGER:
        case TYPE:
        case SHOW:
        case SPOOL:
        case UPDATE:
        case WITH:
        case ACCEPT:
        case COPY:
        case DEFINE:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        if (jj_2_1(6)) {
          PackageSpecification();
        } else if (jj_2_2(6)) {
          PackageBody();
        } else if (jj_2_3(6)) {
          TypeSpecification();
        } else if (jj_2_4(6)) {
          Table();
        } else if (jj_2_5(6)) {
          View();
        } else if (jj_2_6(6)) {
          TriggerUnit();
        } else {
          switch (jj_nt.kind) {
          case ALTER:
            AlterTrigger();
            break;
          case BEGIN:
          case CREATE:
          case DECLARE:
          case FUNCTION:
          case PROCEDURE:
            Global();
            break;
          case 2:
          case 3:
          case COLUMN:
          case COMMENT:
          case CONNECT:
          case DROP:
          case EXECUTE:
          case EXIT:
          case GRANT:
          case PROMPT:
          case REVOKE:
          case SET:
          case START:
          case SHOW:
          case SPOOL:
          case ACCEPT:
          case COPY:
          case DEFINE:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case IDENTIFIER:
            SqlPlusCommand();
            break;
          case COMMIT:
          case DELETE:
          case INSERT:
          case LOCK:
          case MERGE:
          case ROLLBACK:
          case SAVEPOINT:
          case SELECT:
          case UPDATE:
          case WITH:
            switch (jj_nt.kind) {
            case SELECT:
              jj_consume_token(SELECT);
              break;
            case UPDATE:
              jj_consume_token(UPDATE);
              break;
            case INSERT:
              jj_consume_token(INSERT);
              break;
            case DELETE:
              jj_consume_token(DELETE);
              break;
            case COMMIT:
              jj_consume_token(COMMIT);
              break;
            case ROLLBACK:
              jj_consume_token(ROLLBACK);
              break;
            case SAVEPOINT:
              jj_consume_token(SAVEPOINT);
              break;
            case LOCK:
              jj_consume_token(LOCK);
              jj_consume_token(TABLE);
              break;
            case MERGE:
              jj_consume_token(MERGE);
              break;
            case WITH:
              jj_consume_token(WITH);
              break;
            default:
              jj_la1[1] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            SkipPastNextTokenOccurrence(SQLPLUS_TERMINATOR);
            break;
          default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        label_2:
        while (true) {
          switch (jj_nt.kind) {
          case 1:
            ;
            break;
          default:
            jj_la1[3] = jj_gen;
            break label_2;
          }
          jj_consume_token(1);
        }
      }
      jj_consume_token(0);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTSqlPlusCommand SqlPlusCommand() throws ParseException {
                                      /*@bgen(jjtree) SqlPlusCommand */
  ASTSqlPlusCommand jjtn000 = new ASTSqlPlusCommand(this, JJTSQLPLUSCOMMAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case 2:
        jj_consume_token(2);
        break;
      case ACCEPT:
        jj_consume_token(ACCEPT);
        break;
      case COLUMN:
        jj_consume_token(COLUMN);
        break;
      case CONNECT:
        jj_consume_token(CONNECT);
        break;
      case COPY:
        jj_consume_token(COPY);
        break;
      case DEFINE:
        jj_consume_token(DEFINE);
        break;
      case DISCONNECT:
        jj_consume_token(DISCONNECT);
        break;
      case EXECUTE:
        jj_consume_token(EXECUTE);
        break;
      case EXIT:
        jj_consume_token(EXIT);
        break;
      case HOST:
        jj_consume_token(HOST);
        break;
      case PRINT:
        jj_consume_token(PRINT);
        break;
      case PROMPT:
        jj_consume_token(PROMPT);
        break;
      case QUIT:
        jj_consume_token(QUIT);
        break;
      case REMARK:
        jj_consume_token(REMARK);
        break;
      case SET:
        jj_consume_token(SET);
        break;
      case SHOW:
        jj_consume_token(SHOW);
        break;
      case SPOOL:
        jj_consume_token(SPOOL);
        break;
      case START:
        jj_consume_token(START);
        break;
      case UNDEFINE:
        jj_consume_token(UNDEFINE);
        break;
      case VARIABLE:
        jj_consume_token(VARIABLE);
        break;
      case WHENEVER:
        jj_consume_token(WHENEVER);
        break;
      case COMMENT:
        jj_consume_token(COMMENT);
        break;
      case GRANT:
        jj_consume_token(GRANT);
        break;
      case REVOKE:
        jj_consume_token(REVOKE);
        break;
      case DROP:
        jj_consume_token(DROP);
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case 3:
        jj_consume_token(3);
        jj_consume_token(ATTACH);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Skip2NextTokenOccurrence(EOL);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
      {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/*
SRT 2011-04-17 This syntax breaks the parser when fields of record.attach* are referenced  in PL/SQL 
void attachLibrary() :
{}
{
	<".attach"> <IDENTIFIER> <IDENTIFIER> <END> <IDENTIFIER>
}
*/

/**
 * All global definitions of triggers, functions and procedures are evaluated here.
 * Every occurence goes under a new PACKAGE-Node in the XML document.
 * This happens, cause a global "block" does not have a definied start and end token 
 * like a package specification or a package body.
 * Thats why every construct is handled like a new part of the global package.
 * To overcome this problem, I could use an infinity lookahead - which should solve the problem 
 * and slow down the whole parsing.
 * Another idea would be to lookahead the next tokens and decide wether they belong to a package definition or not.
 * Then I could decide to stay in this global parsing state. By now lookahead gives the parser a hint to
 * choose the correct way on a given base. So we can't negate it easily.
 * On the other hand I could also hold the global state in a global variable. 
 * But this does not seems the correct way to solve the problem, I think.
 *
 * 2006-05-17 - Matthias Hendler - added
 */
  final public ASTGlobal Global() throws ParseException {
 /*@bgen(jjtree) Global */
  ASTGlobal jjtn000 = new ASTGlobal(this, JJTGLOBAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      if (jj_2_7(2147483647)) {
        Block();
        jj_consume_token(4);
      } else if (jj_2_8(4)) {
        ProgramUnit();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTBlock Block() throws ParseException {
 /*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(this, JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case DECLARE:
        jj_consume_token(DECLARE);
        DeclarativeSection();
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(BEGIN);
      label_3:
      while (true) {
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
        Statement();
      }
      switch (jj_nt.kind) {
      case EXCEPTION:
        ExceptionHandler();
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      jj_consume_token(END);
      switch (jj_nt.kind) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
      {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTPackageSpecification PackageSpecification() throws ParseException {
 /*@bgen(jjtree) PackageSpecification */
 ASTPackageSpecification jjtn000 = new ASTPackageSpecification(this, JJTPACKAGESPECIFICATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      switch (jj_nt.kind) {
      case CREATE:
        jj_consume_token(CREATE);
        switch (jj_nt.kind) {
        case OR:
          jj_consume_token(OR);
          jj_consume_token(REPLACE);
          break;
        default:
          jj_la1[9] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      jj_consume_token(PACKAGE);
      simpleNode = ObjectNameDeclaration();
      switch (jj_nt.kind) {
      case AUTHID:
        jj_consume_token(AUTHID);
        switch (jj_nt.kind) {
        case CURRENT_USER:
          jj_consume_token(CURRENT_USER);
          break;
        case DEFINER:
          jj_consume_token(DEFINER);
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case WRAPPED:
        WrappedObject();
        break;
      case AS:
      case IS:
        switch (jj_nt.kind) {
        case IS:
          jj_consume_token(IS);
          break;
        case AS:
          jj_consume_token(AS);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        DeclarativeSection();
        jj_consume_token(END);
        switch (jj_nt.kind) {
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case SERIALLY_REUSABLE:
        case RESTRICT_REFERENCES:
        case EXCEPTION_INIT:
        case AUTONOMOUS_TRANSACTION:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ALL:
        case ALTER:
        case AND:
        case ANY:
        case ARRAY:
        case AS:
        case ASC:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case AVG:
        case BETWEEN:
        case BINARY_INTEGER:
        case BODY:
        case BOOLEAN:
        case BULK:
        case BY:
        case BYTE:
        case CASCADE:
        case CASE:
        case CHAR:
        case CHAR_BASE:
        case CHECK:
        case CLOSE:
        case CLUSTER:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case COMPRESS:
        case CONNECT:
        case CONSTANT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CREATE:
        case CURRENT:
        case CURRVAL:
        case CURSOR:
        case DATA:
        case DATE:
        case DAY:
        case DECLARE:
        case DECIMAL:
        case _DEFAULT:
        case DELETE:
        case DESC:
        case DISABLE:
        case DISTINCT:
        case DO:
        case DROP:
        case ELEMENT:
        case ELSE:
        case ELSIF:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTION:
        case EXCEPTIONS:
        case EXCLUSIVE:
        case EXECUTE:
        case EXISTS:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FLOAT:
        case FOR:
        case FORALL:
        case FORCE:
        case FROM:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case GROUP:
        case HASH:
        case HAVING:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case IN:
        case INDEX:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTEGER:
        case INTERFACE:
        case INTERSECT:
        case INTERVAL:
        case INTO:
        case INVALIDATE:
        case IS:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIKE:
        case LIMIT:
        case LIMITED:
        case LOCK:
        case LONG:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUS:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MODE:
        case MONTH:
        case NATURAL:
        case NATURALN:
        case NEW:
        case NEXTVAL:
        case NO:
        case NOCOPY:
        case NOT:
        case NOWAIT:
        case NULL:
        case NULLIF:
        case NUMBER:
        case BFILE_BASE:
        case BLOB_BASE:
        case CLOB_BASE:
        case DATE_BASE:
        case NUMBER_BASE:
        case OBJECT:
        case OCIROWID:
        case OF:
        case OID:
        case ON:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case OPTION:
        case OR:
        case ORDER:
        case ORGANIZATION:
        case OTHERS:
        case OUT:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PCTFREE:
        case PLS_INTEGER:
        case POSITIVE:
        case POSITIVEN:
        case PRESERVE:
        case PRIOR:
        case PROMPT:
        case PRIVATE:
        case PROCEDURE:
        case PUBLIC:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELEASE:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case ROWTYPE:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SEPARATE:
        case SET:
        case SHARE:
        case SMALLINT:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case START:
        case STATIC:
        case STDDEV:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SUM:
        case SYNONYM:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TABLE:
        case TEMPORARY:
        case THEN:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TO:
        case TRANSACTION:
        case TRIGGER:
        case TRUE:
        case TYPE:
        case UI:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case VARCHAR:
        case VARCHAR2:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case SIGNTYPE:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case QUOTED_LITERAL:
        case SQLDATA_CLASS:
        case CUSTOMDATUM_CLASS:
        case ORADATA_CLASS:
        case JAVA_INTERFACE_CLASS:
          ID();
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        jj_consume_token(4);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
        }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTPackageBody PackageBody() throws ParseException {
 /*@bgen(jjtree) PackageBody */
 ASTPackageBody jjtn000 = new ASTPackageBody(this, JJTPACKAGEBODY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      switch (jj_nt.kind) {
      case CREATE:
        jj_consume_token(CREATE);
        switch (jj_nt.kind) {
        case OR:
          jj_consume_token(OR);
          jj_consume_token(REPLACE);
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case PACKAGE:
        jj_consume_token(PACKAGE);
        break;
      case TYPE:
        jj_consume_token(TYPE);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(BODY);
      simpleNode = ObjectNameDeclaration();
      switch (jj_nt.kind) {
      case WRAPPED:
        WrappedObject();
        break;
      case AS:
      case IS:
        switch (jj_nt.kind) {
        case IS:
          jj_consume_token(IS);
          break;
        case AS:
          jj_consume_token(AS);
          break;
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        DeclarativeSection();
        switch (jj_nt.kind) {
        case BEGIN:
          jj_consume_token(BEGIN);
          label_4:
          while (true) {
            switch (jj_nt.kind) {
            case 5:
            case 16:
            case 17:
            case 21:
            case REPLACE:
            case DEFINER:
            case CURRENT_USER:
            case LANGUAGE:
            case ADD:
            case AGGREGATE:
            case ARRAY:
            case AT:
            case ATTRIBUTE:
            case AUTHID:
            case BEGIN:
            case BODY:
            case BULK:
            case BYTE:
            case CASCADE:
            case CASE:
            case CLOSE:
            case COALESCE:
            case COLLECT:
            case COLUMN:
            case COMMENT:
            case COMMIT:
            case CONSTRUCTOR:
            case CONTINUE:
            case CONVERT:
            case CURRENT:
            case CURSOR:
            case DATA:
            case DAY:
            case DECLARE:
            case DELETE:
            case DISABLE:
            case ELEMENT:
            case ENABLE:
            case ESCAPE:
            case EXCEPT:
            case EXCEPTIONS:
            case EXECUTE:
            case EXIT:
            case EXTERNAL:
            case EXTENDS:
            case EXTRACT:
            case FALSE:
            case FETCH:
            case FINAL:
            case FOR:
            case FORALL:
            case FORCE:
            case FUNCTION:
            case GLOBAL:
            case GOTO:
            case HASH:
            case HEAP:
            case HOUR:
            case IF:
            case IMMEDIATE:
            case INDICES:
            case INDEXTYPE:
            case INDICATOR:
            case INSERT:
            case INSTANTIABLE:
            case INTERVAL:
            case INVALIDATE:
            case ISOLATION:
            case JAVA:
            case LEVEL:
            case LIMIT:
            case LOCK:
            case LOOP:
            case MAP:
            case MAX:
            case MEMBER:
            case MERGE:
            case MIN:
            case MINUTE:
            case MLSLABEL:
            case MODIFY:
            case MOD:
            case MONTH:
            case NATURAL:
            case NEW:
            case NEW_DOT:
            case NO:
            case NOT:
            case NULL:
            case OBJECT:
            case OID:
            case OPAQUE:
            case OPEN:
            case OPERATOR:
            case ORGANIZATION:
            case OTHERS:
            case OVERRIDING:
            case PACKAGE:
            case PARTITION:
            case PIPE:
            case PRESERVE:
            case PRIVATE:
            case PROCEDURE:
            case RAISE:
            case RANGE:
            case RAW:
            case REAL:
            case RECORD:
            case REF:
            case RELIES_ON:
            case RESULT:
            case RETURN:
            case REVERSE:
            case ROLLBACK:
            case ROW:
            case ROWS:
            case ROWID:
            case ROWNUM:
            case SAVE:
            case SAVEPOINT:
            case SECOND:
            case SELECT:
            case SELF:
            case SET:
            case SPACE:
            case SQL:
            case SQLCODE:
            case SQLERRM:
            case STATIC:
            case SUBTYPE:
            case SUBSTITUTABLE:
            case SUCCESSFUL:
            case SYSDATE:
            case SYS_REFCURSOR:
            case TEMPORARY:
            case TIME:
            case TIMESTAMP:
            case TIMEZONE_REGION:
            case TIMEZONE_ABBR:
            case TIMEZONE_MINUTE:
            case TIMEZONE_HOUR:
            case TRANSACTION:
            case TRUE:
            case TYPE:
            case UNDER:
            case USING:
            case WHILE:
            case YES:
            case SHOW:
            case A:
            case UPDATE:
            case DOUBLE:
            case DEC:
            case PRECISION:
            case INT:
            case NUMERIC:
            case NCHAR:
            case NVARCHAR2:
            case STRING:
            case UROWID:
            case VARRAY:
            case VARYING:
            case BFILE:
            case BLOB:
            case CLOB:
            case NCLOB:
            case YEAR:
            case LOCAL:
            case WITH:
            case ZONE:
            case CHARACTER:
            case AFTER:
            case BEFORE:
            case OLD:
            case PARENT:
            case CC_IF:
            case CC_ERROR:
            case ANALYZE:
            case ASSOCIATE:
            case AUDIT:
            case COMPOUND:
            case DATABASE:
            case CALL:
            case DDL:
            case DISASSOCIATE:
            case EACH:
            case FOLLOWS:
            case LOGOFF:
            case LOGON:
            case NESTED:
            case NOAUDIT:
            case SCHEMA:
            case SERVERERROR:
            case SHUTDOWN:
            case STARTUP:
            case STATEMENT:
            case STATISTICS:
            case SUSPEND:
            case TRUNCATE:
            case WRAPPED:
            case LIBRARY:
            case NAME:
            case STRUCT:
            case CONTEXT:
            case PARAMETERS:
            case LENGTH:
            case TDO:
            case MAXLEN:
            case CHARSETID:
            case CHARSETFORM:
            case ACCEPT:
            case COPY:
            case DISCONNECT:
            case HOST:
            case PRINT:
            case QUIT:
            case REMARK:
            case UNDEFINE:
            case VARIABLE:
            case WHENEVER:
            case ATTACH:
            case CAST:
            case TREAT:
            case TRIM:
            case LEFT:
            case RIGHT:
            case BOTH:
            case EMPTY:
            case MULTISET:
            case SUBMULTISET:
            case LEADING:
            case TRAILING:
            case CHAR_CS:
            case NCHAR_CS:
            case DBTIMEZONE:
            case SESSIONTIMEZONE:
            case IDENTIFIER:
            case UNSIGNED_NUMERIC_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case QUOTED_LITERAL:
              ;
              break;
            default:
              jj_la1[20] = jj_gen;
              break label_4;
            }
            Statement();
          }
          switch (jj_nt.kind) {
          case EXCEPTION:
            ExceptionHandler();
            break;
          default:
            jj_la1[21] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
        jj_consume_token(END);
        switch (jj_nt.kind) {
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case SERIALLY_REUSABLE:
        case RESTRICT_REFERENCES:
        case EXCEPTION_INIT:
        case AUTONOMOUS_TRANSACTION:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ALL:
        case ALTER:
        case AND:
        case ANY:
        case ARRAY:
        case AS:
        case ASC:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case AVG:
        case BETWEEN:
        case BINARY_INTEGER:
        case BODY:
        case BOOLEAN:
        case BULK:
        case BY:
        case BYTE:
        case CASCADE:
        case CASE:
        case CHAR:
        case CHAR_BASE:
        case CHECK:
        case CLOSE:
        case CLUSTER:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case COMPRESS:
        case CONNECT:
        case CONSTANT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CREATE:
        case CURRENT:
        case CURRVAL:
        case CURSOR:
        case DATA:
        case DATE:
        case DAY:
        case DECLARE:
        case DECIMAL:
        case _DEFAULT:
        case DELETE:
        case DESC:
        case DISABLE:
        case DISTINCT:
        case DO:
        case DROP:
        case ELEMENT:
        case ELSE:
        case ELSIF:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTION:
        case EXCEPTIONS:
        case EXCLUSIVE:
        case EXECUTE:
        case EXISTS:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FLOAT:
        case FOR:
        case FORALL:
        case FORCE:
        case FROM:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case GROUP:
        case HASH:
        case HAVING:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case IN:
        case INDEX:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTEGER:
        case INTERFACE:
        case INTERSECT:
        case INTERVAL:
        case INTO:
        case INVALIDATE:
        case IS:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIKE:
        case LIMIT:
        case LIMITED:
        case LOCK:
        case LONG:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUS:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MODE:
        case MONTH:
        case NATURAL:
        case NATURALN:
        case NEW:
        case NEXTVAL:
        case NO:
        case NOCOPY:
        case NOT:
        case NOWAIT:
        case NULL:
        case NULLIF:
        case NUMBER:
        case BFILE_BASE:
        case BLOB_BASE:
        case CLOB_BASE:
        case DATE_BASE:
        case NUMBER_BASE:
        case OBJECT:
        case OCIROWID:
        case OF:
        case OID:
        case ON:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case OPTION:
        case OR:
        case ORDER:
        case ORGANIZATION:
        case OTHERS:
        case OUT:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PCTFREE:
        case PLS_INTEGER:
        case POSITIVE:
        case POSITIVEN:
        case PRESERVE:
        case PRIOR:
        case PROMPT:
        case PRIVATE:
        case PROCEDURE:
        case PUBLIC:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELEASE:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case ROWTYPE:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SEPARATE:
        case SET:
        case SHARE:
        case SMALLINT:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case START:
        case STATIC:
        case STDDEV:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SUM:
        case SYNONYM:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TABLE:
        case TEMPORARY:
        case THEN:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TO:
        case TRANSACTION:
        case TRIGGER:
        case TRUE:
        case TYPE:
        case UI:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case VARCHAR:
        case VARCHAR2:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case SIGNTYPE:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case QUOTED_LITERAL:
        case SQLDATA_CLASS:
        case CUSTOMDATUM_CLASS:
        case ORADATA_CLASS:
        case JAVA_INTERFACE_CLASS:
          ID();
          break;
        default:
          jj_la1[23] = jj_gen;
          ;
        }
        jj_consume_token(4);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
      jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTDeclarativeUnit DeclarativeUnit() throws ParseException {
 /*@bgen(jjtree) DeclarativeUnit */
  ASTDeclarativeUnit jjtn000 = new ASTDeclarativeUnit(this, JJTDECLARATIVEUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case PRAGMA:
        Pragma();
        break;
      default:
        jj_la1[25] = jj_gen;
        if (jj_2_9(2)) {
          ExceptionDeclaration();
        } else if (jj_2_10(2147483647)) {
          SubTypeDefinition();
        } else if (jj_2_11(2147483647)) {
          ProgramUnit();
        } else if (jj_2_12(4)) {
          VariableOrConstantDeclaration();
        } else if (jj_2_13(2)) {
          CursorSpecification();
        } else {
          switch (jj_nt.kind) {
          case CURSOR:
            CursorBody();
            break;
          case IDENTIFIER:
            CollectionDeclaration();
            break;
          case CONSTRUCTOR:
          case CREATE:
          case FINAL:
          case FUNCTION:
          case INSTANTIABLE:
          case MAP:
          case MEMBER:
          case NOT:
          case ORDER:
          case OVERRIDING:
          case PROCEDURE:
          case STATIC:
            MethodDeclaration();
            break;
          case CC_IF:
            CompilationDeclarationFragment();
            break;
          default:
            jj_la1[26] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
      {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTDeclarativeSection DeclarativeSection() throws ParseException {
 /*@bgen(jjtree) DeclarativeSection */
  ASTDeclarativeSection jjtn000 = new ASTDeclarativeSection(this, JJTDECLARATIVESECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      label_5:
      while (true) {
        switch (jj_nt.kind) {
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case SERIALLY_REUSABLE:
        case RESTRICT_REFERENCES:
        case EXCEPTION_INIT:
        case AUTONOMOUS_TRANSACTION:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ALL:
        case ALTER:
        case AND:
        case ANY:
        case ARRAY:
        case AS:
        case ASC:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case AVG:
        case BETWEEN:
        case BINARY_INTEGER:
        case BODY:
        case BOOLEAN:
        case BULK:
        case BY:
        case BYTE:
        case CASCADE:
        case CASE:
        case CHAR:
        case CHAR_BASE:
        case CHECK:
        case CLOSE:
        case CLUSTER:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case COMPRESS:
        case CONNECT:
        case CONSTANT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CREATE:
        case CURRENT:
        case CURRVAL:
        case CURSOR:
        case DATA:
        case DATE:
        case DAY:
        case DECLARE:
        case DECIMAL:
        case _DEFAULT:
        case DELETE:
        case DESC:
        case DISABLE:
        case DISTINCT:
        case DO:
        case DROP:
        case ELEMENT:
        case ELSE:
        case ELSIF:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTION:
        case EXCEPTIONS:
        case EXCLUSIVE:
        case EXECUTE:
        case EXISTS:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FLOAT:
        case FOR:
        case FORALL:
        case FORCE:
        case FROM:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case GROUP:
        case HASH:
        case HAVING:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case IN:
        case INDEX:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTEGER:
        case INTERFACE:
        case INTERSECT:
        case INTERVAL:
        case INTO:
        case INVALIDATE:
        case IS:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIKE:
        case LIMIT:
        case LIMITED:
        case LOCK:
        case LONG:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUS:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MODE:
        case MONTH:
        case NATURAL:
        case NATURALN:
        case NEW:
        case NEXTVAL:
        case NO:
        case NOCOPY:
        case NOT:
        case NOWAIT:
        case NULL:
        case NULLIF:
        case NUMBER:
        case BFILE_BASE:
        case BLOB_BASE:
        case CLOB_BASE:
        case DATE_BASE:
        case NUMBER_BASE:
        case OBJECT:
        case OCIROWID:
        case OF:
        case OID:
        case ON:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case OPTION:
        case OR:
        case ORDER:
        case ORGANIZATION:
        case OTHERS:
        case OUT:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PCTFREE:
        case PLS_INTEGER:
        case POSITIVE:
        case POSITIVEN:
        case PRAGMA:
        case PRESERVE:
        case PRIOR:
        case PROMPT:
        case PRIVATE:
        case PROCEDURE:
        case PUBLIC:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELEASE:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case ROWTYPE:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SEPARATE:
        case SET:
        case SHARE:
        case SMALLINT:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case START:
        case STATIC:
        case STDDEV:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SUM:
        case SYNONYM:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TABLE:
        case TEMPORARY:
        case THEN:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TO:
        case TRANSACTION:
        case TRIGGER:
        case TRUE:
        case TYPE:
        case UI:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case VARCHAR:
        case VARCHAR2:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case SIGNTYPE:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case QUOTED_LITERAL:
        case SQLDATA_CLASS:
        case CUSTOMDATUM_CLASS:
        case ORADATA_CLASS:
        case JAVA_INTERFACE_CLASS:
          ;
          break;
        default:
          jj_la1[27] = jj_gen;
          break label_5;
        }
        DeclarativeUnit();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCompilationDeclarationFragment CompilationDeclarationFragment() throws ParseException {
 /*@bgen(jjtree) CompilationDeclarationFragment */
  ASTCompilationDeclarationFragment jjtn000 = new ASTCompilationDeclarationFragment(this, JJTCOMPILATIONDECLARATIONFRAGMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(CC_IF);
      ConditionalOrExpression();
      jj_consume_token(CC_THEN);
      label_6:
      while (true) {
        switch (jj_nt.kind) {
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case SERIALLY_REUSABLE:
        case RESTRICT_REFERENCES:
        case EXCEPTION_INIT:
        case AUTONOMOUS_TRANSACTION:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ALL:
        case ALTER:
        case AND:
        case ANY:
        case ARRAY:
        case AS:
        case ASC:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case AVG:
        case BETWEEN:
        case BINARY_INTEGER:
        case BODY:
        case BOOLEAN:
        case BULK:
        case BY:
        case BYTE:
        case CASCADE:
        case CASE:
        case CHAR:
        case CHAR_BASE:
        case CHECK:
        case CLOSE:
        case CLUSTER:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case COMPRESS:
        case CONNECT:
        case CONSTANT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CREATE:
        case CURRENT:
        case CURRVAL:
        case CURSOR:
        case DATA:
        case DATE:
        case DAY:
        case DECLARE:
        case DECIMAL:
        case _DEFAULT:
        case DELETE:
        case DESC:
        case DISABLE:
        case DISTINCT:
        case DO:
        case DROP:
        case ELEMENT:
        case ELSE:
        case ELSIF:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTION:
        case EXCEPTIONS:
        case EXCLUSIVE:
        case EXECUTE:
        case EXISTS:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FLOAT:
        case FOR:
        case FORALL:
        case FORCE:
        case FROM:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case GROUP:
        case HASH:
        case HAVING:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case IN:
        case INDEX:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTEGER:
        case INTERFACE:
        case INTERSECT:
        case INTERVAL:
        case INTO:
        case INVALIDATE:
        case IS:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIKE:
        case LIMIT:
        case LIMITED:
        case LOCK:
        case LONG:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUS:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MODE:
        case MONTH:
        case NATURAL:
        case NATURALN:
        case NEW:
        case NEXTVAL:
        case NO:
        case NOCOPY:
        case NOT:
        case NOWAIT:
        case NULL:
        case NULLIF:
        case NUMBER:
        case BFILE_BASE:
        case BLOB_BASE:
        case CLOB_BASE:
        case DATE_BASE:
        case NUMBER_BASE:
        case OBJECT:
        case OCIROWID:
        case OF:
        case OID:
        case ON:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case OPTION:
        case OR:
        case ORDER:
        case ORGANIZATION:
        case OTHERS:
        case OUT:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PCTFREE:
        case PLS_INTEGER:
        case POSITIVE:
        case POSITIVEN:
        case PRAGMA:
        case PRESERVE:
        case PRIOR:
        case PROMPT:
        case PRIVATE:
        case PROCEDURE:
        case PUBLIC:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELEASE:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case ROWTYPE:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SEPARATE:
        case SET:
        case SHARE:
        case SMALLINT:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case START:
        case STATIC:
        case STDDEV:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SUM:
        case SYNONYM:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TABLE:
        case TEMPORARY:
        case THEN:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TO:
        case TRANSACTION:
        case TRIGGER:
        case TRUE:
        case TYPE:
        case UI:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case VARCHAR:
        case VARCHAR2:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case SIGNTYPE:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case QUOTED_LITERAL:
        case SQLDATA_CLASS:
        case CUSTOMDATUM_CLASS:
        case ORADATA_CLASS:
        case JAVA_INTERFACE_CLASS:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_6;
        }
        switch (jj_nt.kind) {
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case SERIALLY_REUSABLE:
        case RESTRICT_REFERENCES:
        case EXCEPTION_INIT:
        case AUTONOMOUS_TRANSACTION:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ALL:
        case ALTER:
        case AND:
        case ANY:
        case ARRAY:
        case AS:
        case ASC:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case AVG:
        case BETWEEN:
        case BINARY_INTEGER:
        case BODY:
        case BOOLEAN:
        case BULK:
        case BY:
        case BYTE:
        case CASCADE:
        case CASE:
        case CHAR:
        case CHAR_BASE:
        case CHECK:
        case CLOSE:
        case CLUSTER:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case COMPRESS:
        case CONNECT:
        case CONSTANT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CREATE:
        case CURRENT:
        case CURRVAL:
        case CURSOR:
        case DATA:
        case DATE:
        case DAY:
        case DECLARE:
        case DECIMAL:
        case _DEFAULT:
        case DELETE:
        case DESC:
        case DISABLE:
        case DISTINCT:
        case DO:
        case DROP:
        case ELEMENT:
        case ELSE:
        case ELSIF:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTION:
        case EXCEPTIONS:
        case EXCLUSIVE:
        case EXECUTE:
        case EXISTS:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FLOAT:
        case FOR:
        case FORALL:
        case FORCE:
        case FROM:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case GROUP:
        case HASH:
        case HAVING:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case IN:
        case INDEX:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTEGER:
        case INTERFACE:
        case INTERSECT:
        case INTERVAL:
        case INTO:
        case INVALIDATE:
        case IS:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIKE:
        case LIMIT:
        case LIMITED:
        case LOCK:
        case LONG:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUS:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MODE:
        case MONTH:
        case NATURAL:
        case NATURALN:
        case NEW:
        case NEXTVAL:
        case NO:
        case NOCOPY:
        case NOT:
        case NOWAIT:
        case NULL:
        case NULLIF:
        case NUMBER:
        case BFILE_BASE:
        case BLOB_BASE:
        case CLOB_BASE:
        case DATE_BASE:
        case NUMBER_BASE:
        case OBJECT:
        case OCIROWID:
        case OF:
        case OID:
        case ON:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case OPTION:
        case OR:
        case ORDER:
        case ORGANIZATION:
        case OTHERS:
        case OUT:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PCTFREE:
        case PLS_INTEGER:
        case POSITIVE:
        case POSITIVEN:
        case PRAGMA:
        case PRESERVE:
        case PRIOR:
        case PROMPT:
        case PRIVATE:
        case PROCEDURE:
        case PUBLIC:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELEASE:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case ROWTYPE:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SEPARATE:
        case SET:
        case SHARE:
        case SMALLINT:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case START:
        case STATIC:
        case STDDEV:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SUM:
        case SYNONYM:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TABLE:
        case TEMPORARY:
        case THEN:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TO:
        case TRANSACTION:
        case TRIGGER:
        case TRUE:
        case TYPE:
        case UI:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case VARCHAR:
        case VARCHAR2:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case SIGNTYPE:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case QUOTED_LITERAL:
        case SQLDATA_CLASS:
        case CUSTOMDATUM_CLASS:
        case ORADATA_CLASS:
        case JAVA_INTERFACE_CLASS:
          DeclarativeUnit();
          break;
        case CC_ERROR:
          jj_consume_token(CC_ERROR);
          Expression();
          jj_consume_token(CC_END);
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_7:
      while (true) {
        switch (jj_nt.kind) {
        case CC_ELSIF:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_7;
        }
        jj_consume_token(CC_ELSIF);
        ConditionalOrExpression();
        jj_consume_token(CC_THEN);
        label_8:
        while (true) {
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRAGMA:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case CC_ERROR:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            ;
            break;
          default:
            jj_la1[31] = jj_gen;
            break label_8;
          }
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRAGMA:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            DeclarativeUnit();
            break;
          case CC_ERROR:
            jj_consume_token(CC_ERROR);
            Expression();
            jj_consume_token(CC_END);
            break;
          default:
            jj_la1[32] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      label_9:
      while (true) {
        switch (jj_nt.kind) {
        case CC_ELSE:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_9;
        }
        jj_consume_token(CC_ELSE);
        label_10:
        while (true) {
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRAGMA:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case CC_ERROR:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            ;
            break;
          default:
            jj_la1[34] = jj_gen;
            break label_10;
          }
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRAGMA:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            DeclarativeUnit();
            break;
          case CC_ERROR:
            jj_consume_token(CC_ERROR);
            Expression();
            jj_consume_token(CC_END);
            break;
          default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      jj_consume_token(CC_END);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 2006-05-22 - Matthias Hendler - Printing of custom tag "@deprecated" removed.
 *                                 Printing of any custom tag added. Now user can define his own
 *								   custom tags which he can evaluate in the XSLT.
 *                                 This methode also documents global functions/procedures.
 */
  final public ASTProgramUnit ProgramUnit() throws ParseException {
 /*@bgen(jjtree) ProgramUnit */
  ASTProgramUnit jjtn000 = new ASTProgramUnit(this, JJTPROGRAMUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case CREATE:
        jj_consume_token(CREATE);
        switch (jj_nt.kind) {
        case OR:
          jj_consume_token(OR);
          jj_consume_token(REPLACE);
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      MethodDeclarator();
      switch (jj_nt.kind) {
      case WRAPPED:
        WrappedObject();
        break;
      case 4:
      case AGGREGATE:
      case AS:
      case AUTHID:
      case DETERMINISTIC:
      case IS:
      case PARALLEL_ENABLE:
      case PIPELINED:
      case RESULT_CACHE:
        label_11:
        while (true) {
          switch (jj_nt.kind) {
          case AUTHID:
          case DETERMINISTIC:
          case PARALLEL_ENABLE:
          case PIPELINED:
          case RESULT_CACHE:
            ;
            break;
          default:
            jj_la1[38] = jj_gen;
            break label_11;
          }
          switch (jj_nt.kind) {
          case AUTHID:
            jj_consume_token(AUTHID);
            switch (jj_nt.kind) {
            case CURRENT_USER:
              jj_consume_token(CURRENT_USER);
              break;
            case DEFINER:
              jj_consume_token(DEFINER);
              break;
            default:
              jj_la1[39] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          case DETERMINISTIC:
            jj_consume_token(DETERMINISTIC);
            break;
          case PARALLEL_ENABLE:
            jj_consume_token(PARALLEL_ENABLE);
            switch (jj_nt.kind) {
            case 5:
              ParallelClause();
              break;
            default:
              jj_la1[40] = jj_gen;
              ;
            }
            switch (jj_nt.kind) {
            case USING:
              jj_consume_token(USING);
              ID();
              switch (jj_nt.kind) {
              case 3:
                jj_consume_token(3);
                ID();
                break;
              default:
                jj_la1[41] = jj_gen;
                ;
              }
              break;
            default:
              jj_la1[42] = jj_gen;
              ;
            }
            break;
          case PIPELINED:
            jj_consume_token(PIPELINED);
            switch (jj_nt.kind) {
            case CLUSTER:
            case ORDER:
            case USING:
              switch (jj_nt.kind) {
              case USING:
                jj_consume_token(USING);
                ID();
                switch (jj_nt.kind) {
                case 3:
                  jj_consume_token(3);
                  ID();
                  break;
                default:
                  jj_la1[43] = jj_gen;
                  ;
                }
                break;
              case CLUSTER:
              case ORDER:
                switch (jj_nt.kind) {
                case ORDER:
                  jj_consume_token(ORDER);
                  break;
                case CLUSTER:
                  jj_consume_token(CLUSTER);
                  break;
                default:
                  jj_la1[44] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
                switch (jj_nt.kind) {
                case REPLACE:
                case DEFINER:
                case CURRENT_USER:
                case SERIALLY_REUSABLE:
                case RESTRICT_REFERENCES:
                case EXCEPTION_INIT:
                case AUTONOMOUS_TRANSACTION:
                case LANGUAGE:
                case ADD:
                case AGGREGATE:
                case ALL:
                case ALTER:
                case AND:
                case ANY:
                case ARRAY:
                case AS:
                case ASC:
                case AT:
                case ATTRIBUTE:
                case AUTHID:
                case AVG:
                case BETWEEN:
                case BINARY_INTEGER:
                case BODY:
                case BOOLEAN:
                case BULK:
                case BY:
                case BYTE:
                case CASCADE:
                case CASE:
                case CHAR:
                case CHAR_BASE:
                case CHECK:
                case CLOSE:
                case CLUSTER:
                case COALESCE:
                case COLLECT:
                case COLUMN:
                case COMMENT:
                case COMMIT:
                case COMPRESS:
                case CONNECT:
                case CONSTANT:
                case CONSTRUCTOR:
                case CONTINUE:
                case CONVERT:
                case CREATE:
                case CURRENT:
                case CURRVAL:
                case CURSOR:
                case DATA:
                case DATE:
                case DAY:
                case DECLARE:
                case DECIMAL:
                case _DEFAULT:
                case DELETE:
                case DESC:
                case DISABLE:
                case DISTINCT:
                case DO:
                case DROP:
                case ELEMENT:
                case ELSE:
                case ELSIF:
                case ENABLE:
                case ESCAPE:
                case EXCEPT:
                case EXCEPTION:
                case EXCEPTIONS:
                case EXCLUSIVE:
                case EXECUTE:
                case EXISTS:
                case EXIT:
                case EXTERNAL:
                case EXTENDS:
                case EXTRACT:
                case FALSE:
                case FETCH:
                case FINAL:
                case FLOAT:
                case FOR:
                case FORALL:
                case FORCE:
                case FROM:
                case FUNCTION:
                case GLOBAL:
                case GOTO:
                case GROUP:
                case HASH:
                case HAVING:
                case HEAP:
                case HOUR:
                case IF:
                case IMMEDIATE:
                case IN:
                case INDEX:
                case INDICES:
                case INDEXTYPE:
                case INDICATOR:
                case INSERT:
                case INSTANTIABLE:
                case INTEGER:
                case INTERFACE:
                case INTERSECT:
                case INTERVAL:
                case INTO:
                case INVALIDATE:
                case IS:
                case ISOLATION:
                case JAVA:
                case LEVEL:
                case LIKE:
                case LIMIT:
                case LIMITED:
                case LOCK:
                case LONG:
                case LOOP:
                case MAP:
                case MAX:
                case MEMBER:
                case MERGE:
                case MIN:
                case MINUS:
                case MINUTE:
                case MLSLABEL:
                case MODIFY:
                case MOD:
                case MODE:
                case MONTH:
                case NATURAL:
                case NATURALN:
                case NEW:
                case NEXTVAL:
                case NO:
                case NOCOPY:
                case NOT:
                case NOWAIT:
                case NULL:
                case NULLIF:
                case NUMBER:
                case BFILE_BASE:
                case BLOB_BASE:
                case CLOB_BASE:
                case DATE_BASE:
                case NUMBER_BASE:
                case OBJECT:
                case OCIROWID:
                case OF:
                case OID:
                case ON:
                case OPAQUE:
                case OPEN:
                case OPERATOR:
                case OPTION:
                case OR:
                case ORDER:
                case ORGANIZATION:
                case OTHERS:
                case OUT:
                case OVERRIDING:
                case PACKAGE:
                case PARTITION:
                case PCTFREE:
                case PLS_INTEGER:
                case POSITIVE:
                case POSITIVEN:
                case PRESERVE:
                case PRIOR:
                case PROMPT:
                case PRIVATE:
                case PROCEDURE:
                case PUBLIC:
                case RAISE:
                case RANGE:
                case RAW:
                case REAL:
                case RECORD:
                case REF:
                case RELEASE:
                case RELIES_ON:
                case RESULT:
                case RETURN:
                case REVERSE:
                case ROLLBACK:
                case ROW:
                case ROWS:
                case ROWID:
                case ROWNUM:
                case ROWTYPE:
                case SAVE:
                case SAVEPOINT:
                case SECOND:
                case SELECT:
                case SELF:
                case SEPARATE:
                case SET:
                case SHARE:
                case SMALLINT:
                case SPACE:
                case SQL:
                case SQLCODE:
                case SQLERRM:
                case START:
                case STATIC:
                case STDDEV:
                case SUBTYPE:
                case SUBSTITUTABLE:
                case SUCCESSFUL:
                case SUM:
                case SYNONYM:
                case SYSDATE:
                case SYS_REFCURSOR:
                case TABLE:
                case TEMPORARY:
                case THEN:
                case TIME:
                case TIMESTAMP:
                case TIMEZONE_REGION:
                case TIMEZONE_ABBR:
                case TIMEZONE_MINUTE:
                case TIMEZONE_HOUR:
                case TO:
                case TRANSACTION:
                case TRIGGER:
                case TRUE:
                case TYPE:
                case UI:
                case UNDER:
                case USING:
                case WHILE:
                case YES:
                case SHOW:
                case A:
                case UPDATE:
                case VARCHAR:
                case VARCHAR2:
                case DOUBLE:
                case DEC:
                case PRECISION:
                case INT:
                case NUMERIC:
                case SIGNTYPE:
                case NCHAR:
                case NVARCHAR2:
                case STRING:
                case UROWID:
                case VARRAY:
                case VARYING:
                case BFILE:
                case BLOB:
                case CLOB:
                case NCLOB:
                case YEAR:
                case LOCAL:
                case WITH:
                case ZONE:
                case CHARACTER:
                case AFTER:
                case BEFORE:
                case OLD:
                case PARENT:
                case ANALYZE:
                case ASSOCIATE:
                case AUDIT:
                case COMPOUND:
                case DATABASE:
                case CALL:
                case DDL:
                case DISASSOCIATE:
                case EACH:
                case FOLLOWS:
                case LOGOFF:
                case LOGON:
                case NESTED:
                case NOAUDIT:
                case SCHEMA:
                case SERVERERROR:
                case SHUTDOWN:
                case STARTUP:
                case STATEMENT:
                case STATISTICS:
                case SUSPEND:
                case TRUNCATE:
                case WRAPPED:
                case LIBRARY:
                case NAME:
                case STRUCT:
                case CONTEXT:
                case PARAMETERS:
                case LENGTH:
                case TDO:
                case MAXLEN:
                case CHARSETID:
                case CHARSETFORM:
                case ACCEPT:
                case COPY:
                case DISCONNECT:
                case HOST:
                case PRINT:
                case QUIT:
                case REMARK:
                case UNDEFINE:
                case VARIABLE:
                case WHENEVER:
                case ATTACH:
                case CAST:
                case TREAT:
                case TRIM:
                case LEFT:
                case RIGHT:
                case BOTH:
                case EMPTY:
                case MULTISET:
                case SUBMULTISET:
                case LEADING:
                case TRAILING:
                case CHAR_CS:
                case NCHAR_CS:
                case DBTIMEZONE:
                case SESSIONTIMEZONE:
                case IDENTIFIER:
                case QUOTED_LITERAL:
                case SQLDATA_CLASS:
                case CUSTOMDATUM_CLASS:
                case ORADATA_CLASS:
                case JAVA_INTERFACE_CLASS:
                  ID();
                  break;
                default:
                  jj_la1[45] = jj_gen;
                  ;
                }
                jj_consume_token(BY);
                jj_consume_token(5);
                ID();
                label_12:
                while (true) {
                  switch (jj_nt.kind) {
                  case 6:
                    ;
                    break;
                  default:
                    jj_la1[46] = jj_gen;
                    break label_12;
                  }
                  jj_consume_token(6);
                  ID();
                }
                jj_consume_token(7);
                break;
              default:
                jj_la1[47] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
            default:
              jj_la1[48] = jj_gen;
              ;
            }
            break;
          case RESULT_CACHE:
            jj_consume_token(RESULT_CACHE);
            switch (jj_nt.kind) {
            case RELIES_ON:
              jj_consume_token(RELIES_ON);
              jj_consume_token(5);
              ID();
              switch (jj_nt.kind) {
              case 3:
                jj_consume_token(3);
                ID();
                break;
              default:
                jj_la1[49] = jj_gen;
                ;
              }
              label_13:
              while (true) {
                switch (jj_nt.kind) {
                case 6:
                  ;
                  break;
                default:
                  jj_la1[50] = jj_gen;
                  break label_13;
                }
                jj_consume_token(6);
                ID();
                switch (jj_nt.kind) {
                case 3:
                  jj_consume_token(3);
                  ID();
                  break;
                default:
                  jj_la1[51] = jj_gen;
                  ;
                }
              }
              jj_consume_token(7);
              break;
            default:
              jj_la1[52] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[53] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        switch (jj_nt.kind) {
        case AGGREGATE:
          jj_consume_token(AGGREGATE);
          jj_consume_token(USING);
          ID();
          break;
        default:
          jj_la1[54] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case AS:
        case IS:
          switch (jj_nt.kind) {
          case IS:
            jj_consume_token(IS);
            break;
          case AS:
            jj_consume_token(AS);
            break;
          default:
            jj_la1[55] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          if (jj_2_14(2)) {
            CallSpecTail();
          } else {
            switch (jj_nt.kind) {
            case REPLACE:
            case DEFINER:
            case CURRENT_USER:
            case SERIALLY_REUSABLE:
            case RESTRICT_REFERENCES:
            case EXCEPTION_INIT:
            case AUTONOMOUS_TRANSACTION:
            case LANGUAGE:
            case ADD:
            case AGGREGATE:
            case ALL:
            case ALTER:
            case AND:
            case ANY:
            case ARRAY:
            case AS:
            case ASC:
            case AT:
            case ATTRIBUTE:
            case AUTHID:
            case AVG:
            case BEGIN:
            case BETWEEN:
            case BINARY_INTEGER:
            case BODY:
            case BOOLEAN:
            case BULK:
            case BY:
            case BYTE:
            case CASCADE:
            case CASE:
            case CHAR:
            case CHAR_BASE:
            case CHECK:
            case CLOSE:
            case CLUSTER:
            case COALESCE:
            case COLLECT:
            case COLUMN:
            case COMMENT:
            case COMMIT:
            case COMPRESS:
            case CONNECT:
            case CONSTANT:
            case CONSTRUCTOR:
            case CONTINUE:
            case CONVERT:
            case CREATE:
            case CURRENT:
            case CURRVAL:
            case CURSOR:
            case DATA:
            case DATE:
            case DAY:
            case DECLARE:
            case DECIMAL:
            case _DEFAULT:
            case DELETE:
            case DESC:
            case DISABLE:
            case DISTINCT:
            case DO:
            case DROP:
            case ELEMENT:
            case ELSE:
            case ELSIF:
            case ENABLE:
            case ESCAPE:
            case EXCEPT:
            case EXCEPTION:
            case EXCEPTIONS:
            case EXCLUSIVE:
            case EXECUTE:
            case EXISTS:
            case EXIT:
            case EXTERNAL:
            case EXTENDS:
            case EXTRACT:
            case FALSE:
            case FETCH:
            case FINAL:
            case FLOAT:
            case FOR:
            case FORALL:
            case FORCE:
            case FROM:
            case FUNCTION:
            case GLOBAL:
            case GOTO:
            case GROUP:
            case HASH:
            case HAVING:
            case HEAP:
            case HOUR:
            case IF:
            case IMMEDIATE:
            case IN:
            case INDEX:
            case INDICES:
            case INDEXTYPE:
            case INDICATOR:
            case INSERT:
            case INSTANTIABLE:
            case INTEGER:
            case INTERFACE:
            case INTERSECT:
            case INTERVAL:
            case INTO:
            case INVALIDATE:
            case IS:
            case ISOLATION:
            case JAVA:
            case LEVEL:
            case LIKE:
            case LIMIT:
            case LIMITED:
            case LOCK:
            case LONG:
            case LOOP:
            case MAP:
            case MAX:
            case MEMBER:
            case MERGE:
            case MIN:
            case MINUS:
            case MINUTE:
            case MLSLABEL:
            case MODIFY:
            case MOD:
            case MODE:
            case MONTH:
            case NATURAL:
            case NATURALN:
            case NEW:
            case NEXTVAL:
            case NO:
            case NOCOPY:
            case NOT:
            case NOWAIT:
            case NULL:
            case NULLIF:
            case NUMBER:
            case BFILE_BASE:
            case BLOB_BASE:
            case CLOB_BASE:
            case DATE_BASE:
            case NUMBER_BASE:
            case OBJECT:
            case OCIROWID:
            case OF:
            case OID:
            case ON:
            case OPAQUE:
            case OPEN:
            case OPERATOR:
            case OPTION:
            case OR:
            case ORDER:
            case ORGANIZATION:
            case OTHERS:
            case OUT:
            case OVERRIDING:
            case PACKAGE:
            case PARTITION:
            case PCTFREE:
            case PLS_INTEGER:
            case POSITIVE:
            case POSITIVEN:
            case PRAGMA:
            case PRESERVE:
            case PRIOR:
            case PROMPT:
            case PRIVATE:
            case PROCEDURE:
            case PUBLIC:
            case RAISE:
            case RANGE:
            case RAW:
            case REAL:
            case RECORD:
            case REF:
            case RELEASE:
            case RELIES_ON:
            case RESULT:
            case RETURN:
            case REVERSE:
            case ROLLBACK:
            case ROW:
            case ROWS:
            case ROWID:
            case ROWNUM:
            case ROWTYPE:
            case SAVE:
            case SAVEPOINT:
            case SECOND:
            case SELECT:
            case SELF:
            case SEPARATE:
            case SET:
            case SHARE:
            case SMALLINT:
            case SPACE:
            case SQL:
            case SQLCODE:
            case SQLERRM:
            case START:
            case STATIC:
            case STDDEV:
            case SUBTYPE:
            case SUBSTITUTABLE:
            case SUCCESSFUL:
            case SUM:
            case SYNONYM:
            case SYSDATE:
            case SYS_REFCURSOR:
            case TABLE:
            case TEMPORARY:
            case THEN:
            case TIME:
            case TIMESTAMP:
            case TIMEZONE_REGION:
            case TIMEZONE_ABBR:
            case TIMEZONE_MINUTE:
            case TIMEZONE_HOUR:
            case TO:
            case TRANSACTION:
            case TRIGGER:
            case TRUE:
            case TYPE:
            case UI:
            case UNDER:
            case USING:
            case WHILE:
            case YES:
            case SHOW:
            case A:
            case UPDATE:
            case VARCHAR:
            case VARCHAR2:
            case DOUBLE:
            case DEC:
            case PRECISION:
            case INT:
            case NUMERIC:
            case SIGNTYPE:
            case NCHAR:
            case NVARCHAR2:
            case STRING:
            case UROWID:
            case VARRAY:
            case VARYING:
            case BFILE:
            case BLOB:
            case CLOB:
            case NCLOB:
            case YEAR:
            case LOCAL:
            case WITH:
            case ZONE:
            case CHARACTER:
            case AFTER:
            case BEFORE:
            case OLD:
            case PARENT:
            case CC_IF:
            case ANALYZE:
            case ASSOCIATE:
            case AUDIT:
            case COMPOUND:
            case DATABASE:
            case CALL:
            case DDL:
            case DISASSOCIATE:
            case EACH:
            case FOLLOWS:
            case LOGOFF:
            case LOGON:
            case NESTED:
            case NOAUDIT:
            case SCHEMA:
            case SERVERERROR:
            case SHUTDOWN:
            case STARTUP:
            case STATEMENT:
            case STATISTICS:
            case SUSPEND:
            case TRUNCATE:
            case WRAPPED:
            case LIBRARY:
            case NAME:
            case STRUCT:
            case CONTEXT:
            case PARAMETERS:
            case LENGTH:
            case TDO:
            case MAXLEN:
            case CHARSETID:
            case CHARSETFORM:
            case ACCEPT:
            case COPY:
            case DISCONNECT:
            case HOST:
            case PRINT:
            case QUIT:
            case REMARK:
            case UNDEFINE:
            case VARIABLE:
            case WHENEVER:
            case ATTACH:
            case CAST:
            case TREAT:
            case TRIM:
            case LEFT:
            case RIGHT:
            case BOTH:
            case EMPTY:
            case MULTISET:
            case SUBMULTISET:
            case LEADING:
            case TRAILING:
            case CHAR_CS:
            case NCHAR_CS:
            case DBTIMEZONE:
            case SESSIONTIMEZONE:
            case IDENTIFIER:
            case QUOTED_LITERAL:
            case SQLDATA_CLASS:
            case CUSTOMDATUM_CLASS:
            case ORADATA_CLASS:
            case JAVA_INTERFACE_CLASS:
              DeclarativeSection();
              jj_consume_token(BEGIN);
              label_14:
              while (true) {
                switch (jj_nt.kind) {
                case 5:
                case 16:
                case 17:
                case 21:
                case REPLACE:
                case DEFINER:
                case CURRENT_USER:
                case LANGUAGE:
                case ADD:
                case AGGREGATE:
                case ARRAY:
                case AT:
                case ATTRIBUTE:
                case AUTHID:
                case BEGIN:
                case BODY:
                case BULK:
                case BYTE:
                case CASCADE:
                case CASE:
                case CLOSE:
                case COALESCE:
                case COLLECT:
                case COLUMN:
                case COMMENT:
                case COMMIT:
                case CONSTRUCTOR:
                case CONTINUE:
                case CONVERT:
                case CURRENT:
                case CURSOR:
                case DATA:
                case DAY:
                case DECLARE:
                case DELETE:
                case DISABLE:
                case ELEMENT:
                case ENABLE:
                case ESCAPE:
                case EXCEPT:
                case EXCEPTIONS:
                case EXECUTE:
                case EXIT:
                case EXTERNAL:
                case EXTENDS:
                case EXTRACT:
                case FALSE:
                case FETCH:
                case FINAL:
                case FOR:
                case FORALL:
                case FORCE:
                case FUNCTION:
                case GLOBAL:
                case GOTO:
                case HASH:
                case HEAP:
                case HOUR:
                case IF:
                case IMMEDIATE:
                case INDICES:
                case INDEXTYPE:
                case INDICATOR:
                case INSERT:
                case INSTANTIABLE:
                case INTERVAL:
                case INVALIDATE:
                case ISOLATION:
                case JAVA:
                case LEVEL:
                case LIMIT:
                case LOCK:
                case LOOP:
                case MAP:
                case MAX:
                case MEMBER:
                case MERGE:
                case MIN:
                case MINUTE:
                case MLSLABEL:
                case MODIFY:
                case MOD:
                case MONTH:
                case NATURAL:
                case NEW:
                case NEW_DOT:
                case NO:
                case NOT:
                case NULL:
                case OBJECT:
                case OID:
                case OPAQUE:
                case OPEN:
                case OPERATOR:
                case ORGANIZATION:
                case OTHERS:
                case OVERRIDING:
                case PACKAGE:
                case PARTITION:
                case PIPE:
                case PRESERVE:
                case PRIVATE:
                case PROCEDURE:
                case RAISE:
                case RANGE:
                case RAW:
                case REAL:
                case RECORD:
                case REF:
                case RELIES_ON:
                case RESULT:
                case RETURN:
                case REVERSE:
                case ROLLBACK:
                case ROW:
                case ROWS:
                case ROWID:
                case ROWNUM:
                case SAVE:
                case SAVEPOINT:
                case SECOND:
                case SELECT:
                case SELF:
                case SET:
                case SPACE:
                case SQL:
                case SQLCODE:
                case SQLERRM:
                case STATIC:
                case SUBTYPE:
                case SUBSTITUTABLE:
                case SUCCESSFUL:
                case SYSDATE:
                case SYS_REFCURSOR:
                case TEMPORARY:
                case TIME:
                case TIMESTAMP:
                case TIMEZONE_REGION:
                case TIMEZONE_ABBR:
                case TIMEZONE_MINUTE:
                case TIMEZONE_HOUR:
                case TRANSACTION:
                case TRUE:
                case TYPE:
                case UNDER:
                case USING:
                case WHILE:
                case YES:
                case SHOW:
                case A:
                case UPDATE:
                case DOUBLE:
                case DEC:
                case PRECISION:
                case INT:
                case NUMERIC:
                case NCHAR:
                case NVARCHAR2:
                case STRING:
                case UROWID:
                case VARRAY:
                case VARYING:
                case BFILE:
                case BLOB:
                case CLOB:
                case NCLOB:
                case YEAR:
                case LOCAL:
                case WITH:
                case ZONE:
                case CHARACTER:
                case AFTER:
                case BEFORE:
                case OLD:
                case PARENT:
                case CC_IF:
                case CC_ERROR:
                case ANALYZE:
                case ASSOCIATE:
                case AUDIT:
                case COMPOUND:
                case DATABASE:
                case CALL:
                case DDL:
                case DISASSOCIATE:
                case EACH:
                case FOLLOWS:
                case LOGOFF:
                case LOGON:
                case NESTED:
                case NOAUDIT:
                case SCHEMA:
                case SERVERERROR:
                case SHUTDOWN:
                case STARTUP:
                case STATEMENT:
                case STATISTICS:
                case SUSPEND:
                case TRUNCATE:
                case WRAPPED:
                case LIBRARY:
                case NAME:
                case STRUCT:
                case CONTEXT:
                case PARAMETERS:
                case LENGTH:
                case TDO:
                case MAXLEN:
                case CHARSETID:
                case CHARSETFORM:
                case ACCEPT:
                case COPY:
                case DISCONNECT:
                case HOST:
                case PRINT:
                case QUIT:
                case REMARK:
                case UNDEFINE:
                case VARIABLE:
                case WHENEVER:
                case ATTACH:
                case CAST:
                case TREAT:
                case TRIM:
                case LEFT:
                case RIGHT:
                case BOTH:
                case EMPTY:
                case MULTISET:
                case SUBMULTISET:
                case LEADING:
                case TRAILING:
                case CHAR_CS:
                case NCHAR_CS:
                case DBTIMEZONE:
                case SESSIONTIMEZONE:
                case IDENTIFIER:
                case UNSIGNED_NUMERIC_LITERAL:
                case CHARACTER_LITERAL:
                case STRING_LITERAL:
                case QUOTED_LITERAL:
                  ;
                  break;
                default:
                  jj_la1[56] = jj_gen;
                  break label_14;
                }
                Statement();
              }
              switch (jj_nt.kind) {
              case EXCEPTION:
                ExceptionHandler();
                break;
              default:
                jj_la1[57] = jj_gen;
                ;
              }
              jj_consume_token(END);
              switch (jj_nt.kind) {
              case REPLACE:
              case DEFINER:
              case CURRENT_USER:
              case SERIALLY_REUSABLE:
              case RESTRICT_REFERENCES:
              case EXCEPTION_INIT:
              case AUTONOMOUS_TRANSACTION:
              case LANGUAGE:
              case ADD:
              case AGGREGATE:
              case ALL:
              case ALTER:
              case AND:
              case ANY:
              case ARRAY:
              case AS:
              case ASC:
              case AT:
              case ATTRIBUTE:
              case AUTHID:
              case AVG:
              case BETWEEN:
              case BINARY_INTEGER:
              case BODY:
              case BOOLEAN:
              case BULK:
              case BY:
              case BYTE:
              case CASCADE:
              case CASE:
              case CHAR:
              case CHAR_BASE:
              case CHECK:
              case CLOSE:
              case CLUSTER:
              case COALESCE:
              case COLLECT:
              case COLUMN:
              case COMMENT:
              case COMMIT:
              case COMPRESS:
              case CONNECT:
              case CONSTANT:
              case CONSTRUCTOR:
              case CONTINUE:
              case CONVERT:
              case CREATE:
              case CURRENT:
              case CURRVAL:
              case CURSOR:
              case DATA:
              case DATE:
              case DAY:
              case DECLARE:
              case DECIMAL:
              case _DEFAULT:
              case DELETE:
              case DESC:
              case DISABLE:
              case DISTINCT:
              case DO:
              case DROP:
              case ELEMENT:
              case ELSE:
              case ELSIF:
              case ENABLE:
              case ESCAPE:
              case EXCEPT:
              case EXCEPTION:
              case EXCEPTIONS:
              case EXCLUSIVE:
              case EXECUTE:
              case EXISTS:
              case EXIT:
              case EXTERNAL:
              case EXTENDS:
              case EXTRACT:
              case FALSE:
              case FETCH:
              case FINAL:
              case FLOAT:
              case FOR:
              case FORALL:
              case FORCE:
              case FROM:
              case FUNCTION:
              case GLOBAL:
              case GOTO:
              case GROUP:
              case HASH:
              case HAVING:
              case HEAP:
              case HOUR:
              case IF:
              case IMMEDIATE:
              case IN:
              case INDEX:
              case INDICES:
              case INDEXTYPE:
              case INDICATOR:
              case INSERT:
              case INSTANTIABLE:
              case INTEGER:
              case INTERFACE:
              case INTERSECT:
              case INTERVAL:
              case INTO:
              case INVALIDATE:
              case IS:
              case ISOLATION:
              case JAVA:
              case LEVEL:
              case LIKE:
              case LIMIT:
              case LIMITED:
              case LOCK:
              case LONG:
              case LOOP:
              case MAP:
              case MAX:
              case MEMBER:
              case MERGE:
              case MIN:
              case MINUS:
              case MINUTE:
              case MLSLABEL:
              case MODIFY:
              case MOD:
              case MODE:
              case MONTH:
              case NATURAL:
              case NATURALN:
              case NEW:
              case NEXTVAL:
              case NO:
              case NOCOPY:
              case NOT:
              case NOWAIT:
              case NULL:
              case NULLIF:
              case NUMBER:
              case BFILE_BASE:
              case BLOB_BASE:
              case CLOB_BASE:
              case DATE_BASE:
              case NUMBER_BASE:
              case OBJECT:
              case OCIROWID:
              case OF:
              case OID:
              case ON:
              case OPAQUE:
              case OPEN:
              case OPERATOR:
              case OPTION:
              case OR:
              case ORDER:
              case ORGANIZATION:
              case OTHERS:
              case OUT:
              case OVERRIDING:
              case PACKAGE:
              case PARTITION:
              case PCTFREE:
              case PLS_INTEGER:
              case POSITIVE:
              case POSITIVEN:
              case PRESERVE:
              case PRIOR:
              case PROMPT:
              case PRIVATE:
              case PROCEDURE:
              case PUBLIC:
              case RAISE:
              case RANGE:
              case RAW:
              case REAL:
              case RECORD:
              case REF:
              case RELEASE:
              case RELIES_ON:
              case RESULT:
              case RETURN:
              case REVERSE:
              case ROLLBACK:
              case ROW:
              case ROWS:
              case ROWID:
              case ROWNUM:
              case ROWTYPE:
              case SAVE:
              case SAVEPOINT:
              case SECOND:
              case SELECT:
              case SELF:
              case SEPARATE:
              case SET:
              case SHARE:
              case SMALLINT:
              case SPACE:
              case SQL:
              case SQLCODE:
              case SQLERRM:
              case START:
              case STATIC:
              case STDDEV:
              case SUBTYPE:
              case SUBSTITUTABLE:
              case SUCCESSFUL:
              case SUM:
              case SYNONYM:
              case SYSDATE:
              case SYS_REFCURSOR:
              case TABLE:
              case TEMPORARY:
              case THEN:
              case TIME:
              case TIMESTAMP:
              case TIMEZONE_REGION:
              case TIMEZONE_ABBR:
              case TIMEZONE_MINUTE:
              case TIMEZONE_HOUR:
              case TO:
              case TRANSACTION:
              case TRIGGER:
              case TRUE:
              case TYPE:
              case UI:
              case UNDER:
              case USING:
              case WHILE:
              case YES:
              case SHOW:
              case A:
              case UPDATE:
              case VARCHAR:
              case VARCHAR2:
              case DOUBLE:
              case DEC:
              case PRECISION:
              case INT:
              case NUMERIC:
              case SIGNTYPE:
              case NCHAR:
              case NVARCHAR2:
              case STRING:
              case UROWID:
              case VARRAY:
              case VARYING:
              case BFILE:
              case BLOB:
              case CLOB:
              case NCLOB:
              case YEAR:
              case LOCAL:
              case WITH:
              case ZONE:
              case CHARACTER:
              case AFTER:
              case BEFORE:
              case OLD:
              case PARENT:
              case ANALYZE:
              case ASSOCIATE:
              case AUDIT:
              case COMPOUND:
              case DATABASE:
              case CALL:
              case DDL:
              case DISASSOCIATE:
              case EACH:
              case FOLLOWS:
              case LOGOFF:
              case LOGON:
              case NESTED:
              case NOAUDIT:
              case SCHEMA:
              case SERVERERROR:
              case SHUTDOWN:
              case STARTUP:
              case STATEMENT:
              case STATISTICS:
              case SUSPEND:
              case TRUNCATE:
              case WRAPPED:
              case LIBRARY:
              case NAME:
              case STRUCT:
              case CONTEXT:
              case PARAMETERS:
              case LENGTH:
              case TDO:
              case MAXLEN:
              case CHARSETID:
              case CHARSETFORM:
              case ACCEPT:
              case COPY:
              case DISCONNECT:
              case HOST:
              case PRINT:
              case QUIT:
              case REMARK:
              case UNDEFINE:
              case VARIABLE:
              case WHENEVER:
              case ATTACH:
              case CAST:
              case TREAT:
              case TRIM:
              case LEFT:
              case RIGHT:
              case BOTH:
              case EMPTY:
              case MULTISET:
              case SUBMULTISET:
              case LEADING:
              case TRAILING:
              case CHAR_CS:
              case NCHAR_CS:
              case DBTIMEZONE:
              case SESSIONTIMEZONE:
              case IDENTIFIER:
              case QUOTED_LITERAL:
              case SQLDATA_CLASS:
              case CUSTOMDATUM_CLASS:
              case ORADATA_CLASS:
              case JAVA_INTERFACE_CLASS:
                ID();
                break;
              default:
                jj_la1[58] = jj_gen;
                ;
              }
              break;
            default:
              jj_la1[59] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[60] = jj_gen;
          ;
        }
        jj_consume_token(4);
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTObjectNameDeclaration ObjectNameDeclaration() throws ParseException {
 /*@bgen(jjtree) ObjectNameDeclaration */
 ASTObjectNameDeclaration jjtn000 = new ASTObjectNameDeclaration(this, JJTOBJECTNAMEDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode schemaName = null, objectName = null ;
    try {
      if (jj_2_15(2)) {
        schemaName = ID();
        jj_consume_token(3);
      } else {
        ;
      }
      objectName = ID();
    jjtn000.setImage(  (null == schemaName) ?  objectName.getImage() : (schemaName.getImage() + "." + objectName.getImage() )  )  ;
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTFormalParameter FormalParameter() throws ParseException {
 /*@bgen(jjtree) FormalParameter */
 ASTFormalParameter jjtn000 = new ASTFormalParameter(this, JJTFORMALPARAMETER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      simpleNode = ID();
      if (jj_2_18(2)) {
        if (jj_2_17(2)) {
          switch (jj_nt.kind) {
          case OUT:
            jj_consume_token(OUT);
            break;
          case IN:
            jj_consume_token(IN);
            jj_consume_token(OUT);
            break;
          default:
            jj_la1[62] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          if (jj_2_16(2)) {
            jj_consume_token(NOCOPY);
          } else {
            ;
          }
        } else {
          switch (jj_nt.kind) {
          case IN:
            jj_consume_token(IN);
            break;
          default:
            jj_la1[63] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } else {
        ;
      }
      switch (jj_nt.kind) {
      case 8:
        jj_consume_token(8);
        break;
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BINARY_INTEGER:
      case BODY:
      case BOOLEAN:
      case BULK:
      case BYTE:
      case CASCADE:
      case CHAR:
      case CHAR_BASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DATE:
      case DAY:
      case DECIMAL:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTEGER:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LONG:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NATURALN:
      case NEW:
      case NO:
      case NUMBER:
      case BFILE_BASE:
      case BLOB_BASE:
      case CLOB_BASE:
      case DATE_BASE:
      case NUMBER_BASE:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PLS_INTEGER:
      case POSITIVE:
      case POSITIVEN:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELF:
      case SET:
      case SMALLINT:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case VARCHAR:
      case VARCHAR2:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case SIGNTYPE:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case CC_IF:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case QUOTED_LITERAL:
        Datatype();
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 9:
      case _DEFAULT:
        switch (jj_nt.kind) {
        case 9:
          jj_consume_token(9);
          jj_consume_token(10);
          break;
        case _DEFAULT:
          jj_consume_token(_DEFAULT);
          break;
        default:
          jj_la1[65] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
     jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
       jjtn000.jjtSetLastToken(getToken(0));
     }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTMethodDeclaration MethodDeclaration() throws ParseException {
 /*@bgen(jjtree) MethodDeclaration */
  ASTMethodDeclaration jjtn000 = new ASTMethodDeclaration(this, JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case CREATE:
      case FUNCTION:
      case PROCEDURE:
        ProgramUnit();
        break;
      case CONSTRUCTOR:
      case FINAL:
      case INSTANTIABLE:
      case MAP:
      case MEMBER:
      case NOT:
      case ORDER:
      case OVERRIDING:
      case STATIC:
        TypeMethod();
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTMethodDeclarator MethodDeclarator() throws ParseException {
 /*@bgen(jjtree) MethodDeclarator */
 ASTMethodDeclarator jjtn000 = new ASTMethodDeclarator(this, JJTMETHODDECLARATOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      switch (jj_nt.kind) {
      case FUNCTION:
        jj_consume_token(FUNCTION);
        simpleNode = ObjectNameDeclaration();
        switch (jj_nt.kind) {
        case 5:
          FormalParameters();
          break;
        default:
          jj_la1[68] = jj_gen;
          ;
        }
        Token nextToken;
        nextToken = getToken(1); //ReadAhead
        if (!nextToken.image.equalsIgnoreCase("WRAPPED")
            &&
            !nextToken.image.equalsIgnoreCase("RETURN")
           )
        {
          {if (true) throw new ParseException("FUNCTION must RETURN a value or must be WRAPPED : found \u005c""
                                              + nextToken.image
                                              + "\u005c" at line "+nextToken.beginLine
                                              + ", column "+nextToken.beginColumn
                                             );}
        }
        switch (jj_nt.kind) {
        case RETURN:
          jj_consume_token(RETURN);
          Datatype();
          break;
        default:
          jj_la1[69] = jj_gen;
          ;
        }
        break;
      case PROCEDURE:
        jj_consume_token(PROCEDURE);
        simpleNode = ObjectNameDeclaration();
        switch (jj_nt.kind) {
        case 5:
          FormalParameters();
          break;
        default:
          jj_la1[70] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[71] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTFormalParameters FormalParameters() throws ParseException {
 /*@bgen(jjtree) FormalParameters */
 ASTFormalParameters jjtn000 = new ASTFormalParameters(this, JJTFORMALPARAMETERS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
 StringBuffer sb = new StringBuffer();
    try {
      jj_consume_token(5);
        sb.append("(");
      switch (jj_nt.kind) {
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case SERIALLY_REUSABLE:
      case RESTRICT_REFERENCES:
      case EXCEPTION_INIT:
      case AUTONOMOUS_TRANSACTION:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ALL:
      case ALTER:
      case AND:
      case ANY:
      case ARRAY:
      case AS:
      case ASC:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case AVG:
      case BETWEEN:
      case BINARY_INTEGER:
      case BODY:
      case BOOLEAN:
      case BULK:
      case BY:
      case BYTE:
      case CASCADE:
      case CASE:
      case CHAR:
      case CHAR_BASE:
      case CHECK:
      case CLOSE:
      case CLUSTER:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case COMPRESS:
      case CONNECT:
      case CONSTANT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CREATE:
      case CURRENT:
      case CURRVAL:
      case CURSOR:
      case DATA:
      case DATE:
      case DAY:
      case DECLARE:
      case DECIMAL:
      case _DEFAULT:
      case DELETE:
      case DESC:
      case DISABLE:
      case DISTINCT:
      case DO:
      case DROP:
      case ELEMENT:
      case ELSE:
      case ELSIF:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTION:
      case EXCEPTIONS:
      case EXCLUSIVE:
      case EXECUTE:
      case EXISTS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FETCH:
      case FINAL:
      case FLOAT:
      case FOR:
      case FORALL:
      case FORCE:
      case FROM:
      case FUNCTION:
      case GLOBAL:
      case GOTO:
      case GROUP:
      case HASH:
      case HAVING:
      case HEAP:
      case HOUR:
      case IF:
      case IMMEDIATE:
      case IN:
      case INDEX:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSERT:
      case INSTANTIABLE:
      case INTEGER:
      case INTERFACE:
      case INTERSECT:
      case INTERVAL:
      case INTO:
      case INVALIDATE:
      case IS:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIKE:
      case LIMIT:
      case LIMITED:
      case LOCK:
      case LONG:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUS:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MODE:
      case MONTH:
      case NATURAL:
      case NATURALN:
      case NEW:
      case NEXTVAL:
      case NO:
      case NOCOPY:
      case NOT:
      case NOWAIT:
      case NULL:
      case NULLIF:
      case NUMBER:
      case BFILE_BASE:
      case BLOB_BASE:
      case CLOB_BASE:
      case DATE_BASE:
      case NUMBER_BASE:
      case OBJECT:
      case OCIROWID:
      case OF:
      case OID:
      case ON:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case OPTION:
      case OR:
      case ORDER:
      case ORGANIZATION:
      case OTHERS:
      case OUT:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PCTFREE:
      case PLS_INTEGER:
      case POSITIVE:
      case POSITIVEN:
      case PRESERVE:
      case PRIOR:
      case PROMPT:
      case PRIVATE:
      case PROCEDURE:
      case PUBLIC:
      case RAISE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELEASE:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case ROWTYPE:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SEPARATE:
      case SET:
      case SHARE:
      case SMALLINT:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case START:
      case STATIC:
      case STDDEV:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SUM:
      case SYNONYM:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TABLE:
      case TEMPORARY:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TO:
      case TRANSACTION:
      case TRIGGER:
      case TRUE:
      case TYPE:
      case UI:
      case UNDER:
      case USING:
      case WHILE:
      case YES:
      case SHOW:
      case A:
      case UPDATE:
      case VARCHAR:
      case VARCHAR2:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case SIGNTYPE:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case QUOTED_LITERAL:
      case SQLDATA_CLASS:
      case CUSTOMDATUM_CLASS:
      case ORADATA_CLASS:
      case JAVA_INTERFACE_CLASS:
        simpleNode = FormalParameter();
                                         sb.append(simpleNode.getImage());
        label_15:
        while (true) {
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[72] = jj_gen;
            break label_15;
          }
          jj_consume_token(6);
          simpleNode = FormalParameter();
                                               sb.append(","+simpleNode.getImage());
        }
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
      jj_consume_token(7);
       sb.append(")");
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.setImage(sb.toString()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTVariableOrConstantDeclarator VariableOrConstantDeclarator() throws ParseException {
 /*@bgen(jjtree) VariableOrConstantDeclarator */
 ASTVariableOrConstantDeclarator jjtn000 = new ASTVariableOrConstantDeclarator(this, JJTVARIABLEORCONSTANTDECLARATOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
 StringBuffer sb = new StringBuffer();
    try {
      simpleNode = VariableOrConstantDeclaratorId();
                                                  sb.append(simpleNode.getImage());
      if (jj_2_19(2)) {
        jj_consume_token(CONSTANT);
                            sb.append(" " + token.image);
      } else {
        ;
      }
      simpleNode = Datatype();
                                                                                       sb.append(" " + simpleNode.getImage());
      switch (jj_nt.kind) {
      case NOT:
      case NULL:
        switch (jj_nt.kind) {
        case NOT:
          jj_consume_token(NOT);
           sb.append(" " + token.image);
          break;
        default:
          jj_la1[74] = jj_gen;
          ;
        }
        jj_consume_token(NULL);
                                                    sb.append(" " + token.image);
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case 9:
      case _DEFAULT:
        switch (jj_nt.kind) {
        case 9:
          jj_consume_token(9);
          jj_consume_token(10);
               sb.append(" :=");
          break;
        case _DEFAULT:
          jj_consume_token(_DEFAULT);
                                               sb.append(" " + token.image);
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        simpleNode = VariableOrConstantInitializer();
                                                   sb.append(" " + simpleNode.getImage());
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.setImage(sb.toString()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTVariableOrConstantDeclaratorId VariableOrConstantDeclaratorId() throws ParseException {
 /*@bgen(jjtree) VariableOrConstantDeclaratorId */
 ASTVariableOrConstantDeclaratorId jjtn000 = new ASTVariableOrConstantDeclaratorId(this, JJTVARIABLEORCONSTANTDECLARATORID);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      simpleNode = ID();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTVariableOrConstantInitializer VariableOrConstantInitializer() throws ParseException {
 /*@bgen(jjtree) VariableOrConstantInitializer */
 ASTVariableOrConstantInitializer jjtn000 = new ASTVariableOrConstantInitializer(this, JJTVARIABLEORCONSTANTINITIALIZER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      simpleNode = Expression();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTDatatype Datatype() throws ParseException {
 /*@bgen(jjtree) Datatype */
 ASTDatatype jjtn000 = new ASTDatatype(this, JJTDATATYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
 StringBuffer sb = new StringBuffer();
    try {
      switch (jj_nt.kind) {
      case CC_IF:
        // this should be first
                        simpleNode = CompilationDataType();
                                                    sb.append(simpleNode.getImage());
        break;
      default:
        jj_la1[81] = jj_gen;
        if (jj_2_21(2)) {
          simpleNode = ScalarDataTypeName();
                                                                sb.append(simpleNode.getImage());
        } else {
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ARRAY:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case BODY:
          case BULK:
          case BYTE:
          case CASCADE:
          case CLOSE:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CURRENT:
          case CURSOR:
          case DATA:
          case DAY:
          case DISABLE:
          case ELEMENT:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTIONS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FINAL:
          case FORCE:
          case FUNCTION:
          case GLOBAL:
          case HASH:
          case HEAP:
          case HOUR:
          case IMMEDIATE:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSTANTIABLE:
          case INTERVAL:
          case INVALIDATE:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIMIT:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MONTH:
          case NATURAL:
          case NEW:
          case NO:
          case OBJECT:
          case OID:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case ORGANIZATION:
          case OTHERS:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PRESERVE:
          case PRIVATE:
          case PROCEDURE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELF:
          case SET:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case STATIC:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TEMPORARY:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TRANSACTION:
          case TRUE:
          case TYPE:
          case UNDER:
          case USING:
          case YES:
          case SHOW:
          case A:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
            if (jj_2_20(2)) {
              jj_consume_token(REF);
                                          sb.append(token.image);
            } else {
              ;
            }
            simpleNode = QualifiedName();
                                                                                                    sb.append(simpleNode.getImage());
            switch (jj_nt.kind) {
            case 2:
              jj_consume_token(2);
              simpleNode = QualifiedName();
                                                       sb.append("@"+simpleNode.getImage());
              break;
            default:
              jj_la1[78] = jj_gen;
              ;
            }
            switch (jj_nt.kind) {
            case 11:
              jj_consume_token(11);
              switch (jj_nt.kind) {
              case TYPE:
                jj_consume_token(TYPE);
                break;
              case ROWTYPE:
                jj_consume_token(ROWTYPE);
                break;
              default:
                jj_la1[79] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
                                            sb.append("%"+token.image);
              break;
            default:
              jj_la1[80] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[82] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(sb.toString()) ;  {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCompilationDataType CompilationDataType() throws ParseException {
 /*@bgen(jjtree) CompilationDataType */
  ASTCompilationDataType jjtn000 = new ASTCompilationDataType(this, JJTCOMPILATIONDATATYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
  StringBuffer sb = new StringBuffer() ;
    try {
      jj_consume_token(CC_IF);
                   sb.append(" "); sb.append(token.image) ;
      simpleNode = ConditionalOrExpression();
                                                 sb.append(" "); sb.append(simpleNode.getImage());
      jj_consume_token(CC_THEN);
                     sb.append(" "); sb.append(token.image);
      simpleNode = Datatype();
                                   sb.append(" "); sb.append(simpleNode.getImage());
      label_16:
      while (true) {
        switch (jj_nt.kind) {
        case CC_ELSIF:
          ;
          break;
        default:
          jj_la1[83] = jj_gen;
          break label_16;
        }
        jj_consume_token(CC_ELSIF);
                        sb.append(" "); sb.append(token.image);
        simpleNode = ConditionalOrExpression();
                                                    sb.append(" "); sb.append(simpleNode.getImage());
        jj_consume_token(CC_THEN);
                       sb.append(" "); sb.append(token.image);
        simpleNode = Datatype();
                                     sb.append(" "); sb.append(simpleNode.getImage());
      }
      label_17:
      while (true) {
        switch (jj_nt.kind) {
        case CC_ELSE:
          ;
          break;
        default:
          jj_la1[84] = jj_gen;
          break label_17;
        }
        jj_consume_token(CC_ELSE);
                       sb.append(" "); sb.append(token.image);
        simpleNode = Datatype();
                                      sb.append(" "); sb.append(simpleNode.getImage());
      }
      jj_consume_token(CC_END);
                    sb.append(" "); sb.append(token.image);
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()) ;  {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCollectionTypeName CollectionTypeName() throws ParseException {
 /*@bgen(jjtree) CollectionTypeName */
  ASTCollectionTypeName jjtn000 = new ASTCollectionTypeName(this, JJTCOLLECTIONTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode size=null, precision=null;
        StringBuffer sb = new StringBuffer();
    try {
      switch (jj_nt.kind) {
      case TABLE:
        jj_consume_token(TABLE);
        break;
      case VARRAY:
        jj_consume_token(VARRAY);
        break;
      case VARYING:
        jj_consume_token(VARYING);
        jj_consume_token(ARRAY);
                                                sb.append( "VARYING ARRAY") ;
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (sb.length() ==  0) {
        sb.append(token.toString());
      }
      if (jj_2_22(2)) {
        jj_consume_token(5);
        size = NumericLiteral();
                                                 sb.append( "(" + size);
        switch (jj_nt.kind) {
        case 6:
          jj_consume_token(6);
          precision = NumericLiteral();
                                                 sb.append( "," + precision);
          break;
        default:
          jj_la1[86] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case CHAR:
          jj_consume_token(CHAR);
                          sb.append( " CHAR") ;
          break;
        default:
          jj_la1[87] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case BYTE:
          jj_consume_token(BYTE);
                          sb.append( " BYTE") ;
          break;
        default:
          jj_la1[88] = jj_gen;
          ;
        }
        jj_consume_token(7);
             sb.append( ")");
      } else {
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(sb.toString()) ;  {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         {if (true) throw (RuntimeException)jjte000;}
       }
       if (jjte000 instanceof ParseException) {
         {if (true) throw (ParseException)jjte000;}
       }
       {if (true) throw (Error)jjte000;}
    } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
         jjtreeCloseNodeScope(jjtn000);
         jjtn000.jjtSetLastToken(getToken(0));
       }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTScalarDataTypeName ScalarDataTypeName() throws ParseException {
 /*@bgen(jjtree) ScalarDataTypeName */
  ASTScalarDataTypeName jjtn000 = new ASTScalarDataTypeName(this, JJTSCALARDATATYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode size=null, precision=null ;
        StringBuffer name = new StringBuffer();
        SimpleNode characterSet = null;
    try {
      switch (jj_nt.kind) {
      case BFILE_BASE:
        jj_consume_token(BFILE_BASE);
        break;
      case BLOB_BASE:
        jj_consume_token(BLOB_BASE);
        break;
      case CHAR_BASE:
        jj_consume_token(CHAR_BASE);
        break;
      case CLOB_BASE:
        jj_consume_token(CLOB_BASE);
        break;
      case DATE_BASE:
        jj_consume_token(DATE_BASE);
        break;
      case NUMBER_BASE:
        jj_consume_token(NUMBER_BASE);
        break;
      case BINARY_INTEGER:
        jj_consume_token(BINARY_INTEGER);
        break;
      case DEC:
        jj_consume_token(DEC);
        break;
      case DECIMAL:
        jj_consume_token(DECIMAL);
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
        jj_consume_token(PRECISION);
                                                                     name.append("DOUBLE PRECISION");
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
        break;
      case INT:
        jj_consume_token(INT);
        break;
      case INTEGER:
        jj_consume_token(INTEGER);
        break;
      case NATURAL:
        jj_consume_token(NATURAL);
        break;
      case NATURALN:
        jj_consume_token(NATURALN);
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      case NUMERIC:
        jj_consume_token(NUMERIC);
        break;
      case PLS_INTEGER:
        jj_consume_token(PLS_INTEGER);
        break;
      case POSITIVE:
        jj_consume_token(POSITIVE);
        break;
      case POSITIVEN:
        jj_consume_token(POSITIVEN);
        break;
      case REAL:
        jj_consume_token(REAL);
        break;
      case SIGNTYPE:
        jj_consume_token(SIGNTYPE);
        break;
      case SMALLINT:
        jj_consume_token(SMALLINT);
        break;
      case CHAR:
      case LONG:
      case RAW:
      case ROWID:
      case VARCHAR:
      case VARCHAR2:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case CLOB:
      case NCLOB:
      case CHARACTER:
        switch (jj_nt.kind) {
        case CHAR:
          jj_consume_token(CHAR);
          break;
        case CHARACTER:
          jj_consume_token(CHARACTER);
          break;
        default:
          jj_la1[89] = jj_gen;
          if (jj_2_23(2)) {
            jj_consume_token(LONG);
            jj_consume_token(RAW);
                                       name.append("LONG RAW");
          } else {
            switch (jj_nt.kind) {
            case LONG:
              jj_consume_token(LONG);
              break;
            case NCHAR:
              jj_consume_token(NCHAR);
              break;
            case NVARCHAR2:
              jj_consume_token(NVARCHAR2);
              break;
            case RAW:
              jj_consume_token(RAW);
              break;
            case ROWID:
              jj_consume_token(ROWID);
              break;
            case STRING:
              jj_consume_token(STRING);
              break;
            case UROWID:
              jj_consume_token(UROWID);
              break;
            case VARCHAR:
              jj_consume_token(VARCHAR);
              break;
            case VARCHAR2:
              jj_consume_token(VARCHAR2);
              break;
            case CLOB:
              jj_consume_token(CLOB);
              break;
            case NCLOB:
              jj_consume_token(NCLOB);
              break;
            default:
              jj_la1[90] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
        break;
      case BFILE:
        jj_consume_token(BFILE);
        break;
      case BLOB:
        jj_consume_token(BLOB);
        break;
      case SYS_REFCURSOR:
        jj_consume_token(SYS_REFCURSOR);
        break;
      case REF:
        jj_consume_token(REF);
        jj_consume_token(CURSOR);
                        name.append("REF CURSOR");
        break;
      case DATE:
        jj_consume_token(DATE);
        break;
      default:
        jj_la1[91] = jj_gen;
        if (jj_2_24(2)) {
          jj_consume_token(INTERVAL);
          jj_consume_token(YEAR);
                                        name.append("INTERVAL YEAR");
        } else if (jj_2_25(2)) {
          jj_consume_token(INTERVAL);
          jj_consume_token(DAY);
                                       name.append("INTERVAL DAY");
        } else {
          switch (jj_nt.kind) {
          case TIME:
            jj_consume_token(TIME);
            break;
          case TIMESTAMP:
            jj_consume_token(TIMESTAMP);
            break;
          case SELF:
            jj_consume_token(SELF);
            jj_consume_token(AS);
            jj_consume_token(RESULT);
                             name.append("SELF AS RESULT");
            break;
          default:
            jj_la1[92] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      if (name.length() == 0 ) {
        name.append(token.toString());
      }
      if (jj_2_26(2)) {
        jj_consume_token(5);
        size = NumericLiteral();
                                                 name.append("("); name.append(size.getImage()) ;
        switch (jj_nt.kind) {
        case 6:
          jj_consume_token(6);
          precision = UnaryExpression(true);
                                                      name.append(",") ; name.append(precision.getImage()) ;
          break;
        default:
          jj_la1[93] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case CHAR:
          jj_consume_token(CHAR);
                          name.append(" CHAR") ;
          break;
        default:
          jj_la1[94] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case BYTE:
          jj_consume_token(BYTE);
                          name.append(" BYTE") ;
          break;
        default:
          jj_la1[95] = jj_gen;
          ;
        }
        jj_consume_token(7);
             name.append( ")") ;
      } else {
        ;
      }
      switch (jj_nt.kind) {
      case TO:
      case WITH:
      case CHARACTER:
        switch (jj_nt.kind) {
        case CHARACTER:
          jj_consume_token(CHARACTER);
          jj_consume_token(SET);
          characterSet = Name();
                                              name.append( " CHARACTER SET ") ;  name.append(characterSet.getImage()) ;
          break;
        default:
          jj_la1[96] = jj_gen;
          if (jj_2_28(4)) {
            jj_consume_token(WITH);
            jj_consume_token(LOCAL);
            jj_consume_token(TIME);
            jj_consume_token(ZONE);
                                             name.append(" WITH LOCAL TIME ZONE");
          } else if (jj_2_29(3)) {
            jj_consume_token(WITH);
            jj_consume_token(TIME);
            jj_consume_token(ZONE);
                                      name.append( " WITH TIME ZONE");
          } else if (jj_2_30(2)) {
            jj_consume_token(TO);
            jj_consume_token(MONTH);
                               name.append( " TO MONTH");
          } else if (jj_2_31(2)) {
            jj_consume_token(TO);
            jj_consume_token(SECOND);
                                name.append( " TO SECOND");
            if (jj_2_27(2)) {
              jj_consume_token(5);
              precision = NumericLiteral();
                                                                       name.append( "(" + precision) ;
              jj_consume_token(7);
                                             name.append( ")");
            } else {
              ;
            }
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[97] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(name.toString()) ;  {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTDateTimeLiteral DateTimeLiteral() throws ParseException {
 /*@bgen(jjtree) DateTimeLiteral */
 ASTDateTimeLiteral jjtn000 = new ASTDateTimeLiteral(this, JJTDATETIMELITERAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t = null ;
 SimpleNode simpleNode = null ;
 StringBuffer sb = new StringBuffer() ;
    try {
      switch (jj_nt.kind) {
      case INTERVAL:
        jj_consume_token(INTERVAL);
        break;
      case TIMESTAMP:
        jj_consume_token(TIMESTAMP);
        break;
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          sb.append(token.image);
      switch (jj_nt.kind) {
      case CHARACTER_LITERAL:
        jj_consume_token(CHARACTER_LITERAL);
                                sb.append(" ");  sb.append(token.image);
        break;
      case STRING_LITERAL:
        simpleNode = StringLiteral();
                                        sb.append(" ");  sb.append(simpleNode.getImage());
        break;
      default:
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case DAY:
      case HOUR:
      case MINUTE:
      case MONTH:
      case SECOND:
      case YEAR:
        switch (jj_nt.kind) {
        case YEAR:
          jj_consume_token(YEAR);
          break;
        case MONTH:
          jj_consume_token(MONTH);
          break;
        case DAY:
          jj_consume_token(DAY);
          break;
        case HOUR:
          jj_consume_token(HOUR);
          break;
        case MINUTE:
          jj_consume_token(MINUTE);
          break;
        case SECOND:
          jj_consume_token(SECOND);
          break;
        default:
          jj_la1[100] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[101] = jj_gen;
        ;
      }
           if (null != t)
           {
            sb.append(" ");  sb.append(token.image);
            t = null;
           }
      if (jj_2_32(2)) {
        jj_consume_token(5);
        simpleNode = NumericLiteral();
                                                           sb.append("(");  sb.append(simpleNode.getImage());
        jj_consume_token(7);
               sb.append("}");
      } else {
        ;
      }
      switch (jj_nt.kind) {
      case TO:
      case WITH:
        switch (jj_nt.kind) {
        case WITH:
          jj_consume_token(WITH);
              sb.append(" "); sb.append(token.toString()) ;
          switch (jj_nt.kind) {
          case LOCAL:
            jj_consume_token(LOCAL);
                  sb.append(" "); sb.append(token.toString()) ;
            break;
          default:
            jj_la1[102] = jj_gen;
            ;
          }
          jj_consume_token(TIME);
          jj_consume_token(ZONE);
                    sb.append(" "); sb.append("TIME ZONE") ;
          break;
        case TO:
          jj_consume_token(TO);
            sb.append(" "); sb.append(token.toString()) ;
          switch (jj_nt.kind) {
          case YEAR:
            jj_consume_token(YEAR);
            break;
          case MONTH:
            jj_consume_token(MONTH);
            break;
          case DAY:
            jj_consume_token(DAY);
            break;
          case HOUR:
            jj_consume_token(HOUR);
            break;
          case MINUTE:
            jj_consume_token(MINUTE);
            break;
          case SECOND:
            jj_consume_token(SECOND);
            break;
          default:
            jj_la1[103] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          sb.append(token.image);
          if (jj_2_33(2)) {
            jj_consume_token(5);
            simpleNode = NumericLiteral();
                                                           sb.append("(");  sb.append(simpleNode.getImage());
            jj_consume_token(7);
                sb.append("}");
          } else {
            ;
          }
          break;
        default:
          jj_la1[104] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[105] = jj_gen;
        ;
      }
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.setImage(sb.toString()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTExceptionHandler ExceptionHandler() throws ParseException {
 /*@bgen(jjtree) ExceptionHandler */
  ASTExceptionHandler jjtn000 = new ASTExceptionHandler(this, JJTEXCEPTIONHANDLER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(EXCEPTION);
      label_18:
      while (true) {
        if (jj_2_34(2)) {
          ;
        } else {
          break label_18;
        }
        jj_consume_token(WHEN);
        QualifiedName();
        label_19:
        while (true) {
          switch (jj_nt.kind) {
          case OR:
            ;
            break;
          default:
            jj_la1[106] = jj_gen;
            break label_19;
          }
          jj_consume_token(OR);
          QualifiedName();
        }
        jj_consume_token(THEN);
        label_20:
        while (true) {
          Statement();
          switch (jj_nt.kind) {
          case 5:
          case 16:
          case 17:
          case 21:
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ARRAY:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case BEGIN:
          case BODY:
          case BULK:
          case BYTE:
          case CASCADE:
          case CASE:
          case CLOSE:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CURRENT:
          case CURSOR:
          case DATA:
          case DAY:
          case DECLARE:
          case DELETE:
          case DISABLE:
          case ELEMENT:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTIONS:
          case EXECUTE:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FOR:
          case FORALL:
          case FORCE:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case HASH:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTERVAL:
          case INVALIDATE:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIMIT:
          case LOCK:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MONTH:
          case NATURAL:
          case NEW:
          case NEW_DOT:
          case NO:
          case NOT:
          case NULL:
          case OBJECT:
          case OID:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case ORGANIZATION:
          case OTHERS:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PIPE:
          case PRESERVE:
          case PRIVATE:
          case PROCEDURE:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SET:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case STATIC:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TEMPORARY:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TRANSACTION:
          case TRUE:
          case TYPE:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case CC_ERROR:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case UNSIGNED_NUMERIC_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case QUOTED_LITERAL:
            ;
            break;
          default:
            jj_la1[107] = jj_gen;
            break label_20;
          }
        }
      }
      switch (jj_nt.kind) {
      case WHEN:
        jj_consume_token(WHEN);
        jj_consume_token(OTHERS);
        jj_consume_token(THEN);
        label_21:
        while (true) {
          Statement();
          switch (jj_nt.kind) {
          case 5:
          case 16:
          case 17:
          case 21:
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ARRAY:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case BEGIN:
          case BODY:
          case BULK:
          case BYTE:
          case CASCADE:
          case CASE:
          case CLOSE:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CURRENT:
          case CURSOR:
          case DATA:
          case DAY:
          case DECLARE:
          case DELETE:
          case DISABLE:
          case ELEMENT:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTIONS:
          case EXECUTE:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FOR:
          case FORALL:
          case FORCE:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case HASH:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTERVAL:
          case INVALIDATE:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIMIT:
          case LOCK:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MONTH:
          case NATURAL:
          case NEW:
          case NEW_DOT:
          case NO:
          case NOT:
          case NULL:
          case OBJECT:
          case OID:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case ORGANIZATION:
          case OTHERS:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PIPE:
          case PRESERVE:
          case PRIVATE:
          case PROCEDURE:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SET:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case STATIC:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TEMPORARY:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TRANSACTION:
          case TRUE:
          case TYPE:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case CC_ERROR:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case UNSIGNED_NUMERIC_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case QUOTED_LITERAL:
            ;
            break;
          default:
            jj_la1[108] = jj_gen;
            break label_21;
          }
        }
        break;
      default:
        jj_la1[109] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
        }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Skip2NextTerminator(String initiator,String terminator) throws ParseException {
 /*@bgen(jjtree) Skip2NextTerminator */
  ASTSkip2NextTerminator jjtn000 = new ASTSkip2NextTerminator(this, JJTSKIP2NEXTTERMINATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t = getToken(1);
  int count = (initiator == null) ? 0 : 1;
  if(t.image.equals(initiator)) count++;
  while (count > 0 || !t.image.equals(terminator))
  {
    t = getNextToken();
    t = getToken(1);
          if(t.image.equals(initiator)) count++;
          if(t.image.equals(terminator)) count--;
  }
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
  }

/*
 Read Tokens up to but not including the target String. 
*/
  final public void Skip2NextOccurrence(String target) throws ParseException {
 /*@bgen(jjtree) Skip2NextOccurrence */
  ASTSkip2NextOccurrence jjtn000 = new ASTSkip2NextOccurrence(this, JJTSKIP2NEXTOCCURRENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token nextToken = getToken(1);
  while (!nextToken.image.equals(target)
         && (null == nextToken.specialToken || !nextToken.specialToken.image.equals(target) ) //In case the target is a Special Token
         && nextToken.kind!=EOF //SRT 20110521 - Prevent endless loop when target does not exist in the input stream
        )
  {
    nextToken = getNextToken();
    nextToken = getToken(1);
  }
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
  }

/*
 Read Tokens up to and including the target String. 
*/
  final public void SkipPastNextOccurrence(String target) throws ParseException {
 /*@bgen(jjtree) SkipPastNextOccurrence */
  ASTSkipPastNextOccurrence jjtn000 = new ASTSkipPastNextOccurrence(this, JJTSKIPPASTNEXTOCCURRENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t = null;
  Skip2NextOccurrence(target) ;
  t = getNextToken();
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
  }

/*
 Read Tokens up to but not including the target Token.kind. 
*/
  final public void Skip2NextTokenOccurrence(int target) throws ParseException {
 /*@bgen(jjtree) Skip2NextTokenOccurrence */
  ASTSkip2NextTokenOccurrence jjtn000 = new ASTSkip2NextTokenOccurrence(this, JJTSKIP2NEXTTOKENOCCURRENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token nextToken = getToken(1);
  while (nextToken.kind!=target
         && (null == nextToken.specialToken || nextToken.specialToken.kind!=target ) //In case the target is a Special Token
         && nextToken.kind!=EOF //SRT 20110521 - Prevent endless loop when target does not exist in the input stream
        )
  {
    nextToken = getNextToken();
    nextToken = getToken(1);
  }
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
  }

/*
 Read Tokens up to and including the target Token.kind. 
*/
  final public void SkipPastNextTokenOccurrence(int target) throws ParseException {
 /*@bgen(jjtree) SkipPastNextTokenOccurrence */
  ASTSkipPastNextTokenOccurrence jjtn000 = new ASTSkipPastNextTokenOccurrence(this, JJTSKIPPASTNEXTTOKENOCCURRENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t = null;
  Skip2NextTokenOccurrence(target) ;
  t = getNextToken();
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
  }

/*
 Read Tokens up to but not including the target String. 
*/
  final public ASTRead2NextOccurrence Read2NextOccurrence(String target) throws ParseException {
 /*@bgen(jjtree) Read2NextOccurrence */
  ASTRead2NextOccurrence jjtn000 = new ASTRead2NextOccurrence(this, JJTREAD2NEXTOCCURRENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));StringBuffer sb = new StringBuffer();
  Token nextToken = getToken(1);
  while (!nextToken.image.equals(target)
         && nextToken.kind!=EOF
        )
  {
    nextToken = getNextToken();
    sb.append(nextToken.image);
    nextToken = getToken(1);
  }
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(sb.toString()) ;  jjtn000.value = sb.toString(); {if (true) return jjtn000 ;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/*
 Read Tokens up to and including the target String. 
*/
  final public ASTReadPastNextOccurrence ReadPastNextOccurrence(String target) throws ParseException {
 /*@bgen(jjtree) ReadPastNextOccurrence */
  ASTReadPastNextOccurrence jjtn000 = new ASTReadPastNextOccurrence(this, JJTREADPASTNEXTOCCURRENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));StringBuffer sb = new StringBuffer();
  Token t = null;
  sb.append(Read2NextOccurrence(target)) ;
  t = getNextToken(); // Chomp this one 
  sb.append(t.image);
    try {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(sb.toString()) ;  jjtn000.value = sb.toString(); {if (true) return jjtn000 ;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 2006-05-24 - Matthias Hendler - added MERGE
 */
  final public ASTSqlStatement SqlStatement(String initiator, String terminator) throws ParseException {
 /*@bgen(jjtree) SqlStatement */
  ASTSqlStatement jjtn000 = new ASTSqlStatement(this, JJTSQLSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case SELECT:
        jj_consume_token(SELECT);
        break;
      case UPDATE:
        jj_consume_token(UPDATE);
        break;
      case INSERT:
        jj_consume_token(INSERT);
        break;
      case DELETE:
        jj_consume_token(DELETE);
        break;
      case COMMIT:
        jj_consume_token(COMMIT);
        break;
      case ROLLBACK:
        jj_consume_token(ROLLBACK);
        break;
      case SAVEPOINT:
        jj_consume_token(SAVEPOINT);
        break;
      case EXECUTE:
        jj_consume_token(EXECUTE);
        break;
      case SET:
        jj_consume_token(SET);
        jj_consume_token(TRANSACTION);
        break;
      case LOCK:
        jj_consume_token(LOCK);
        jj_consume_token(TABLE);
        break;
      case MERGE:
        jj_consume_token(MERGE);
        break;
      case WITH:
        jj_consume_token(WITH);
        break;
      default:
        jj_la1[110] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Skip2NextTerminator(initiator,terminator);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 2011-05-15 - SRT - Added to cope with wrapped objects
  A wrapped function looks like this (always terminated by one or more equals signs "="):-
  "  CREATE OR REPLACE FUNCTION "TESTUSER"."GET_DATE_STRING"
/ ** Return SYSDATE formatted using the provided template.
 *
 *
 *  @param p_date_format normal TO_CHARE/TO_DATE date template
 *  @return formatted datestring
 *  @see http://www.oracle-base.com/articles/10g/WrapAndDBMS_DDL_10gR2.php#dbms_ddl
 * /
wrapped
a000000
369
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
8
89 b6
/SBrhM8+1iUO4QAih+qD2SK8kSowg8eZgcfLCNL+XlquYvSuoVah8JbRPpdHDLHn479SdFLw
v04omzJ0zOfHdMAzuHQlw+fAsr2ym9YI8I521pRTbnFVAHOOUw4JqPkIyj7wj4VwyL17nhYb
3qPVuL6SvhZTmEBnRtaErHpzaDuIpqZ0G4s=
  "
 */
  final public void WrappedObject() throws ParseException {
 /*@bgen(jjtree) WrappedObject */
  ASTWrappedObject jjtn000 = new ASTWrappedObject(this, JJTWRAPPEDOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(WRAPPED);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
           Token nextToken;

                nextToken = getToken(1); //ReadAhead
                while (
                     null != nextToken && nextToken.kind!=EOF
                     )
                {
                        nextToken = getNextToken();

                        //Execute manual readahead 
                        nextToken = getToken(1); //ReadAhead 1 Token 
                }
                {if (true) return;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
  }

// ============================================================================
// S T A T E M E N T S
// ============================================================================

/**
 * 2006-05-24 - Matthias Hendler - added MERGE, EXECUTE choice and LOOKAHEAD at <LOOP>
 */
  final public ASTUnlabelledStatement UnlabelledStatement() throws ParseException {
 /*@bgen(jjtree) UnlabelledStatement */
  ASTUnlabelledStatement jjtn000 = new ASTUnlabelledStatement(this, JJTUNLABELLEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      if (jj_2_35(2147483647)) {
        SqlStatement(null,";");
        switch (jj_nt.kind) {
        case 4:
          jj_consume_token(4);
          break;
        default:
          jj_la1[111] = jj_gen;
          ;
        }
      } else if (jj_2_36(3)) {
        ContinueStatement();
        jj_consume_token(4);
      } else {
        switch (jj_nt.kind) {
        case CASE:
          CaseStatement();
          jj_consume_token(4);
          break;
        case IF:
          IfStatement();
          jj_consume_token(4);
          break;
        case FOR:
          ForStatement();
          jj_consume_token(4);
          break;
        case FORALL:
          ForAllStatement();
          jj_consume_token(4);
          break;
        case LOOP:
          LoopStatement();
          jj_consume_token(4);
          break;
        case WHILE:
          WhileStatement();
          jj_consume_token(4);
          break;
        case GOTO:
          GotoStatement();
          jj_consume_token(4);
          break;
        case RETURN:
          ReturnStatement();
          jj_consume_token(4);
          break;
        case EXIT:
          ExitStatement();
          jj_consume_token(4);
          break;
        case RAISE:
          RaiseStatement();
          jj_consume_token(4);
          break;
        case CLOSE:
          CloseStatement();
          jj_consume_token(4);
          break;
        case OPEN:
          OpenStatement();
          jj_consume_token(4);
          break;
        case FETCH:
          FetchStatement();
          jj_consume_token(4);
          break;
        case BEGIN:
        case DECLARE:
          Block();
          jj_consume_token(4);
          break;
        case EXECUTE:
          EmbeddedSqlStatement();
          jj_consume_token(4);
          break;
        case PIPE:
          PipelineStatement();
          jj_consume_token(4);
          break;
        case CC_IF:
        case CC_ERROR:
          ConditionalCompilationStatement();
          break;
        case 5:
        case 16:
        case 17:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FINAL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case HASH:
        case HEAP:
        case HOUR:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case YES:
        case SHOW:
        case A:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          Expression();
          jj_consume_token(4);
          break;
        default:
          jj_la1[112] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           {if (true) throw (RuntimeException)jjte000;}
         }
         if (jjte000 instanceof ParseException) {
           {if (true) throw (ParseException)jjte000;}
         }
         {if (true) throw (Error)jjte000;}
    } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.jjtSetLastToken(getToken(0));
         }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTStatement Statement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(this, JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case 21:
        LabelledStatement();
        break;
      case 5:
      case 16:
      case 17:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BEGIN:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DECLARE:
      case DELETE:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXECUTE:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FETCH:
      case FINAL:
      case FOR:
      case FORALL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case GOTO:
      case HASH:
      case HEAP:
      case HOUR:
      case IF:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSERT:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOCK:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NOT:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PIPE:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RAISE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case WHILE:
      case YES:
      case SHOW:
      case A:
      case UPDATE:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case CC_IF:
      case CC_ERROR:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        UnlabelledStatement();
        break;
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
        }
    }
    throw new Error("Missing return statement in function");
  }

/*
LabelledStatement created solely to conform with PMD Java AST (for PMD DataFlow Analysis - DFA)
N.B. equivalent Java AST* class is ASTLabeledStatement (single "l" rather than double "ll")
*/
  final public ASTLabelledStatement LabelledStatement() throws ParseException {
 /*@bgen(jjtree) LabelledStatement */
ASTLabelledStatement jjtn000 = new ASTLabelledStatement(this, JJTLABELLEDSTATEMENT);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
jjtreeOpenNodeScope(jjtn000);
jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      label_22:
      while (true) {
        simpleNode = Label();
        switch (jj_nt.kind) {
        case 21:
          ;
          break;
        default:
          jj_la1[114] = jj_gen;
          break label_22;
        }
      }
      UnlabelledStatement();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage( simpleNode.getImage() ) ;
       {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
        }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCaseStatement CaseStatement() throws ParseException {
 /*@bgen(jjtree) CaseStatement */
  ASTCaseStatement jjtn000 = new ASTCaseStatement(this, JJTCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(CASE);
      switch (jj_nt.kind) {
      case 5:
      case 16:
      case 17:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NOT:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case CC_IF:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        Expression();
        break;
      default:
        jj_la1[115] = jj_gen;
        ;
      }
      label_23:
      while (true) {
        switch (jj_nt.kind) {
        case WHEN:
          ;
          break;
        default:
          jj_la1[116] = jj_gen;
          break label_23;
        }
        CaseWhenClause();
      }
      switch (jj_nt.kind) {
      case ELSE:
        ElseClause();
        break;
      default:
        jj_la1[117] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(CASE);
      switch (jj_nt.kind) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[118] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           {if (true) throw (RuntimeException)jjte000;}
         }
         if (jjte000 instanceof ParseException) {
           {if (true) throw (ParseException)jjte000;}
         }
         {if (true) throw (Error)jjte000;}
    } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.jjtSetLastToken(getToken(0));
         }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCaseWhenClause CaseWhenClause() throws ParseException {
 /*@bgen(jjtree) CaseWhenClause */
  ASTCaseWhenClause jjtn000 = new ASTCaseWhenClause(this, JJTCASEWHENCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(WHEN);
      Expression();
      jj_consume_token(THEN);
      label_24:
      while (true) {
        Statement();
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[119] = jj_gen;
          break label_24;
        }
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTElseClause ElseClause() throws ParseException {
 /*@bgen(jjtree) ElseClause */
  ASTElseClause jjtn000 = new ASTElseClause(this, JJTELSECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(ELSE);
      label_25:
      while (true) {
        Statement();
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[120] = jj_gen;
          break label_25;
        }
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTElsifClause ElsifClause() throws ParseException {
 /*@bgen(jjtree) ElsifClause */
  ASTElsifClause jjtn000 = new ASTElsifClause(this, JJTELSIFCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(ELSIF);
      Expression();
      jj_consume_token(THEN);
      label_26:
      while (true) {
        Statement();
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[121] = jj_gen;
          break label_26;
        }
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
        }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTLoopStatement LoopStatement() throws ParseException {
 /*@bgen(jjtree) LoopStatement */
  ASTLoopStatement jjtn000 = new ASTLoopStatement(this, JJTLOOPSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(LOOP);
      label_27:
      while (true) {
        Statement();
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[122] = jj_gen;
          break label_27;
        }
      }
      jj_consume_token(END);
      jj_consume_token(LOOP);
      switch (jj_nt.kind) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[123] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           {if (true) throw (RuntimeException)jjte000;}
         }
         if (jjte000 instanceof ParseException) {
           {if (true) throw (ParseException)jjte000;}
         }
         {if (true) throw (Error)jjte000;}
    } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.jjtSetLastToken(getToken(0));
         }
    }
    throw new Error("Missing return statement in function");
  }

/** Scope rule: the loop index only exists within the Loop */
  final public ASTForStatement ForStatement() throws ParseException {
 /*@bgen(jjtree) ForStatement */
  ASTForStatement jjtn000 = new ASTForStatement(this, JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(FOR);
      ForIndex();
      jj_consume_token(IN);
      switch (jj_nt.kind) {
      case REVERSE:
        jj_consume_token(REVERSE);
        break;
      default:
        jj_la1[124] = jj_gen;
        ;
      }
      Expression();
      switch (jj_nt.kind) {
      case 12:
        jj_consume_token(12);
        Expression();
        break;
      default:
        jj_la1[125] = jj_gen;
        ;
      }
      jj_consume_token(LOOP);
      label_28:
      while (true) {
        Statement();
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[126] = jj_gen;
          break label_28;
        }
      }
      jj_consume_token(END);
      jj_consume_token(LOOP);
      switch (jj_nt.kind) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[127] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             {if (true) throw (RuntimeException)jjte000;}
           }
           if (jjte000 instanceof ParseException) {
             {if (true) throw (ParseException)jjte000;}
           }
           {if (true) throw (Error)jjte000;}
    } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.jjtSetLastToken(getToken(0));
           }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTWhileStatement WhileStatement() throws ParseException {
 /*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(this, JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(WHILE);
      Expression();
      jj_consume_token(LOOP);
      label_29:
      while (true) {
        Statement();
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[128] = jj_gen;
          break label_29;
        }
      }
      jj_consume_token(END);
      jj_consume_token(LOOP);
      switch (jj_nt.kind) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[129] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             {if (true) throw (RuntimeException)jjte000;}
           }
           if (jjte000 instanceof ParseException) {
             {if (true) throw (ParseException)jjte000;}
           }
           {if (true) throw (Error)jjte000;}
    } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.jjtSetLastToken(getToken(0));
           }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTIfStatement IfStatement() throws ParseException {
 /*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(IF);
      Expression();
      jj_consume_token(THEN);
      label_30:
      while (true) {
        Statement();
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[130] = jj_gen;
          break label_30;
        }
      }
      label_31:
      while (true) {
        switch (jj_nt.kind) {
        case ELSIF:
          ;
          break;
        default:
          jj_la1[131] = jj_gen;
          break label_31;
        }
        ElsifClause();
                         jjtn000.setHasElse();
      }
      switch (jj_nt.kind) {
      case ELSE:
        ElseClause();
                        jjtn000.setHasElse();
        break;
      default:
        jj_la1[132] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(IF);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/** Scope rule: the loop index only exists within the statement */
/**
ForIndex is declared implicitly, unlike most variables or constants.
*/
  final public ASTForIndex ForIndex() throws ParseException {
 /*@bgen(jjtree) ForIndex */
 ASTForIndex jjtn000 = new ASTForIndex(this, JJTFORINDEX);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      simpleNode = ID();
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
   jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

/**
ForAllIndex is declared implicitly, unlike most variables or constants.
*/
  final public ASTForAllIndex ForAllIndex() throws ParseException {
 /*@bgen(jjtree) ForAllIndex */
 ASTForAllIndex jjtn000 = new ASTForAllIndex(this, JJTFORALLINDEX);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
    try {
      simpleNode = ID();
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
   jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTForAllStatement ForAllStatement() throws ParseException {
 /*@bgen(jjtree) ForAllStatement */
  ASTForAllStatement jjtn000 = new ASTForAllStatement(this, JJTFORALLSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(FORALL);
      ForAllIndex();
      jj_consume_token(IN);
      switch (jj_nt.kind) {
      case INDICES:
      case VALUES:
        switch (jj_nt.kind) {
        case INDICES:
          jj_consume_token(INDICES);
          break;
        case VALUES:
          jj_consume_token(VALUES);
          break;
        default:
          jj_la1[133] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(OF);
        Expression();
        break;
      case 5:
      case 16:
      case 17:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NOT:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case CC_IF:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        Expression();
        switch (jj_nt.kind) {
        case 12:
          jj_consume_token(12);
          Expression();
          break;
        default:
          jj_la1[134] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[135] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case SAVE:
        jj_consume_token(SAVE);
        jj_consume_token(EXCEPTIONS);
        break;
      default:
        jj_la1[136] = jj_gen;
        ;
      }
      SqlStatement(null,";");
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             {if (true) throw (RuntimeException)jjte000;}
           }
           if (jjte000 instanceof ParseException) {
             {if (true) throw (ParseException)jjte000;}
           }
           {if (true) throw (Error)jjte000;}
    } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.jjtSetLastToken(getToken(0));
           }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTGotoStatement GotoStatement() throws ParseException {
 /*@bgen(jjtree) GotoStatement */
 ASTGotoStatement jjtn000 = new ASTGotoStatement(this, JJTGOTOSTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode label = null ;
    try {
      jj_consume_token(GOTO);
      label = QualifiedName();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(label.getImage()) ; {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTReturnStatement ReturnStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  ASTReturnStatement jjtn000 = new ASTReturnStatement(this, JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(RETURN);
      switch (jj_nt.kind) {
      case 5:
      case 16:
      case 17:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NOT:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case CC_IF:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        Expression();
        break;
      default:
        jj_la1[137] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTContinueStatement ContinueStatement() throws ParseException {
 /*@bgen(jjtree) ContinueStatement */
 ASTContinueStatement jjtn000 = new ASTContinueStatement(this, JJTCONTINUESTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode label = null ;
    try {
      jj_consume_token(CONTINUE);
      switch (jj_nt.kind) {
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NO:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case QUOTED_LITERAL:
        label = UnqualifiedID();
        break;
      default:
        jj_la1[138] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case WHEN:
        jj_consume_token(WHEN);
        Expression();
        break;
      default:
        jj_la1[139] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        if (null != label) { jjtn000.setImage(label.getImage()) ; } {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTExitStatement ExitStatement() throws ParseException {
 /*@bgen(jjtree) ExitStatement */
 ASTExitStatement jjtn000 = new ASTExitStatement(this, JJTEXITSTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode label = null ;
    try {
      jj_consume_token(EXIT);
      switch (jj_nt.kind) {
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NO:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case QUOTED_LITERAL:
        label = UnqualifiedID();
        break;
      default:
        jj_la1[140] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case WHEN:
        jj_consume_token(WHEN);
        Expression();
        break;
      default:
        jj_la1[141] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        if (null != label) { jjtn000.setImage(label.getImage()) ; } {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTRaiseStatement RaiseStatement() throws ParseException {
 /*@bgen(jjtree) RaiseStatement */
 ASTRaiseStatement jjtn000 = new ASTRaiseStatement(this, JJTRAISESTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode exception = null ;
    try {
      jj_consume_token(RAISE);
      switch (jj_nt.kind) {
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NO:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case QUOTED_LITERAL:
        exception = QualifiedName();
        break;
      default:
        jj_la1[142] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        if (null != exception) { jjtn000.setImage(exception.getImage()) ; }  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           {if (true) throw (RuntimeException)jjte000;}
         }
         if (jjte000 instanceof ParseException) {
           {if (true) throw (ParseException)jjte000;}
         }
         {if (true) throw (Error)jjte000;}
    } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.jjtSetLastToken(getToken(0));
         }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCloseStatement CloseStatement() throws ParseException {
 /*@bgen(jjtree) CloseStatement */
 ASTCloseStatement jjtn000 = new ASTCloseStatement(this, JJTCLOSESTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode cursor = null ;
    try {
      jj_consume_token(CLOSE);
      cursor = QualifiedName();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(cursor.getImage()) ; {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
        }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTOpenStatement OpenStatement() throws ParseException {
 /*@bgen(jjtree) OpenStatement */
  ASTOpenStatement jjtn000 = new ASTOpenStatement(this, JJTOPENSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(OPEN);
      switch (jj_nt.kind) {
      case 5:
      case 16:
      case 17:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NOT:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case CC_IF:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        Expression();
        break;
      default:
        jj_la1[143] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case FOR:
        jj_consume_token(FOR);
        Expression();
        switch (jj_nt.kind) {
        case USING:
          jj_consume_token(USING);
          Expression();
          label_32:
          while (true) {
            switch (jj_nt.kind) {
            case 6:
              ;
              break;
            default:
              jj_la1[144] = jj_gen;
              break label_32;
            }
            jj_consume_token(6);
            Expression();
          }
          break;
        default:
          jj_la1[145] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[146] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             {if (true) throw (RuntimeException)jjte000;}
           }
           if (jjte000 instanceof ParseException) {
             {if (true) throw (ParseException)jjte000;}
           }
           {if (true) throw (Error)jjte000;}
    } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.jjtSetLastToken(getToken(0));
           }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTFetchStatement FetchStatement() throws ParseException {
 /*@bgen(jjtree) FetchStatement */
  ASTFetchStatement jjtn000 = new ASTFetchStatement(this, JJTFETCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(FETCH);
      QualifiedName();
      switch (jj_nt.kind) {
      case BULK:
        jj_consume_token(BULK);
        jj_consume_token(COLLECT);
        break;
      default:
        jj_la1[147] = jj_gen;
        ;
      }
      jj_consume_token(INTO);
      Expression();
      label_33:
      while (true) {
        switch (jj_nt.kind) {
        case 6:
          ;
          break;
        default:
          jj_la1[148] = jj_gen;
          break label_33;
        }
        jj_consume_token(6);
        Expression();
      }
      switch (jj_nt.kind) {
      case LIMIT:
        jj_consume_token(LIMIT);
        Expression();
        break;
      default:
        jj_la1[149] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             {if (true) throw (RuntimeException)jjte000;}
           }
           if (jjte000 instanceof ParseException) {
             {if (true) throw (ParseException)jjte000;}
           }
           {if (true) throw (Error)jjte000;}
    } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.jjtSetLastToken(getToken(0));
           }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTEmbeddedSqlStatement EmbeddedSqlStatement() throws ParseException {
 /*@bgen(jjtree) EmbeddedSqlStatement */
  ASTEmbeddedSqlStatement jjtn000 = new ASTEmbeddedSqlStatement(this, JJTEMBEDDEDSQLSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(EXECUTE);
      jj_consume_token(IMMEDIATE);
      StringLiteral();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
       jjtn000.jjtSetLastToken(getToken(0));
     }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTPipelineStatement PipelineStatement() throws ParseException {
 /*@bgen(jjtree) PipelineStatement */
  ASTPipelineStatement jjtn000 = new ASTPipelineStatement(this, JJTPIPELINESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(PIPE);
      jj_consume_token(ROW);
      Expression();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTConditionalCompilationStatement ConditionalCompilationStatement() throws ParseException {
 /*@bgen(jjtree) ConditionalCompilationStatement */
  ASTConditionalCompilationStatement jjtn000 = new ASTConditionalCompilationStatement(this, JJTCONDITIONALCOMPILATIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case CC_IF:
        jj_consume_token(CC_IF);
        ConditionalOrExpression();
        jj_consume_token(CC_THEN);
        label_34:
        while (true) {
          switch (jj_nt.kind) {
          case 5:
          case 16:
          case 17:
          case 21:
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ARRAY:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case BEGIN:
          case BODY:
          case BULK:
          case BYTE:
          case CASCADE:
          case CASE:
          case CLOSE:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CURRENT:
          case CURSOR:
          case DATA:
          case DAY:
          case DECLARE:
          case DELETE:
          case DISABLE:
          case ELEMENT:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTIONS:
          case EXECUTE:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FOR:
          case FORALL:
          case FORCE:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case HASH:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTERVAL:
          case INVALIDATE:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIMIT:
          case LOCK:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MONTH:
          case NATURAL:
          case NEW:
          case NEW_DOT:
          case NO:
          case NOT:
          case NULL:
          case OBJECT:
          case OID:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case ORGANIZATION:
          case OTHERS:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PIPE:
          case PRESERVE:
          case PRIVATE:
          case PROCEDURE:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SET:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case STATIC:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TEMPORARY:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TRANSACTION:
          case TRUE:
          case TYPE:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case CC_ERROR:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case UNSIGNED_NUMERIC_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case QUOTED_LITERAL:
            ;
            break;
          default:
            jj_la1[150] = jj_gen;
            break label_34;
          }
          Statement();
        }
        label_35:
        while (true) {
          switch (jj_nt.kind) {
          case CC_ELSIF:
            ;
            break;
          default:
            jj_la1[151] = jj_gen;
            break label_35;
          }
          jj_consume_token(CC_ELSIF);
          ConditionalOrExpression();
          jj_consume_token(CC_THEN);
          label_36:
          while (true) {
            Statement();
            switch (jj_nt.kind) {
            case 5:
            case 16:
            case 17:
            case 21:
            case REPLACE:
            case DEFINER:
            case CURRENT_USER:
            case LANGUAGE:
            case ADD:
            case AGGREGATE:
            case ARRAY:
            case AT:
            case ATTRIBUTE:
            case AUTHID:
            case BEGIN:
            case BODY:
            case BULK:
            case BYTE:
            case CASCADE:
            case CASE:
            case CLOSE:
            case COALESCE:
            case COLLECT:
            case COLUMN:
            case COMMENT:
            case COMMIT:
            case CONSTRUCTOR:
            case CONTINUE:
            case CONVERT:
            case CURRENT:
            case CURSOR:
            case DATA:
            case DAY:
            case DECLARE:
            case DELETE:
            case DISABLE:
            case ELEMENT:
            case ENABLE:
            case ESCAPE:
            case EXCEPT:
            case EXCEPTIONS:
            case EXECUTE:
            case EXIT:
            case EXTERNAL:
            case EXTENDS:
            case EXTRACT:
            case FALSE:
            case FETCH:
            case FINAL:
            case FOR:
            case FORALL:
            case FORCE:
            case FUNCTION:
            case GLOBAL:
            case GOTO:
            case HASH:
            case HEAP:
            case HOUR:
            case IF:
            case IMMEDIATE:
            case INDICES:
            case INDEXTYPE:
            case INDICATOR:
            case INSERT:
            case INSTANTIABLE:
            case INTERVAL:
            case INVALIDATE:
            case ISOLATION:
            case JAVA:
            case LEVEL:
            case LIMIT:
            case LOCK:
            case LOOP:
            case MAP:
            case MAX:
            case MEMBER:
            case MERGE:
            case MIN:
            case MINUTE:
            case MLSLABEL:
            case MODIFY:
            case MOD:
            case MONTH:
            case NATURAL:
            case NEW:
            case NEW_DOT:
            case NO:
            case NOT:
            case NULL:
            case OBJECT:
            case OID:
            case OPAQUE:
            case OPEN:
            case OPERATOR:
            case ORGANIZATION:
            case OTHERS:
            case OVERRIDING:
            case PACKAGE:
            case PARTITION:
            case PIPE:
            case PRESERVE:
            case PRIVATE:
            case PROCEDURE:
            case RAISE:
            case RANGE:
            case RAW:
            case REAL:
            case RECORD:
            case REF:
            case RELIES_ON:
            case RESULT:
            case RETURN:
            case REVERSE:
            case ROLLBACK:
            case ROW:
            case ROWS:
            case ROWID:
            case ROWNUM:
            case SAVE:
            case SAVEPOINT:
            case SECOND:
            case SELECT:
            case SELF:
            case SET:
            case SPACE:
            case SQL:
            case SQLCODE:
            case SQLERRM:
            case STATIC:
            case SUBTYPE:
            case SUBSTITUTABLE:
            case SUCCESSFUL:
            case SYSDATE:
            case SYS_REFCURSOR:
            case TEMPORARY:
            case TIME:
            case TIMESTAMP:
            case TIMEZONE_REGION:
            case TIMEZONE_ABBR:
            case TIMEZONE_MINUTE:
            case TIMEZONE_HOUR:
            case TRANSACTION:
            case TRUE:
            case TYPE:
            case UNDER:
            case USING:
            case WHILE:
            case YES:
            case SHOW:
            case A:
            case UPDATE:
            case DOUBLE:
            case DEC:
            case PRECISION:
            case INT:
            case NUMERIC:
            case NCHAR:
            case NVARCHAR2:
            case STRING:
            case UROWID:
            case VARRAY:
            case VARYING:
            case BFILE:
            case BLOB:
            case CLOB:
            case NCLOB:
            case YEAR:
            case LOCAL:
            case WITH:
            case ZONE:
            case CHARACTER:
            case AFTER:
            case BEFORE:
            case OLD:
            case PARENT:
            case CC_IF:
            case CC_ERROR:
            case ANALYZE:
            case ASSOCIATE:
            case AUDIT:
            case COMPOUND:
            case DATABASE:
            case CALL:
            case DDL:
            case DISASSOCIATE:
            case EACH:
            case FOLLOWS:
            case LOGOFF:
            case LOGON:
            case NESTED:
            case NOAUDIT:
            case SCHEMA:
            case SERVERERROR:
            case SHUTDOWN:
            case STARTUP:
            case STATEMENT:
            case STATISTICS:
            case SUSPEND:
            case TRUNCATE:
            case WRAPPED:
            case LIBRARY:
            case NAME:
            case STRUCT:
            case CONTEXT:
            case PARAMETERS:
            case LENGTH:
            case TDO:
            case MAXLEN:
            case CHARSETID:
            case CHARSETFORM:
            case ACCEPT:
            case COPY:
            case DISCONNECT:
            case HOST:
            case PRINT:
            case QUIT:
            case REMARK:
            case UNDEFINE:
            case VARIABLE:
            case WHENEVER:
            case ATTACH:
            case CAST:
            case TREAT:
            case TRIM:
            case LEFT:
            case RIGHT:
            case BOTH:
            case EMPTY:
            case MULTISET:
            case SUBMULTISET:
            case LEADING:
            case TRAILING:
            case CHAR_CS:
            case NCHAR_CS:
            case DBTIMEZONE:
            case SESSIONTIMEZONE:
            case IDENTIFIER:
            case UNSIGNED_NUMERIC_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case QUOTED_LITERAL:
              ;
              break;
            default:
              jj_la1[152] = jj_gen;
              break label_36;
            }
          }
        }
        label_37:
        while (true) {
          switch (jj_nt.kind) {
          case CC_ELSE:
            ;
            break;
          default:
            jj_la1[153] = jj_gen;
            break label_37;
          }
          jj_consume_token(CC_ELSE);
          label_38:
          while (true) {
            Statement();
            switch (jj_nt.kind) {
            case 5:
            case 16:
            case 17:
            case 21:
            case REPLACE:
            case DEFINER:
            case CURRENT_USER:
            case LANGUAGE:
            case ADD:
            case AGGREGATE:
            case ARRAY:
            case AT:
            case ATTRIBUTE:
            case AUTHID:
            case BEGIN:
            case BODY:
            case BULK:
            case BYTE:
            case CASCADE:
            case CASE:
            case CLOSE:
            case COALESCE:
            case COLLECT:
            case COLUMN:
            case COMMENT:
            case COMMIT:
            case CONSTRUCTOR:
            case CONTINUE:
            case CONVERT:
            case CURRENT:
            case CURSOR:
            case DATA:
            case DAY:
            case DECLARE:
            case DELETE:
            case DISABLE:
            case ELEMENT:
            case ENABLE:
            case ESCAPE:
            case EXCEPT:
            case EXCEPTIONS:
            case EXECUTE:
            case EXIT:
            case EXTERNAL:
            case EXTENDS:
            case EXTRACT:
            case FALSE:
            case FETCH:
            case FINAL:
            case FOR:
            case FORALL:
            case FORCE:
            case FUNCTION:
            case GLOBAL:
            case GOTO:
            case HASH:
            case HEAP:
            case HOUR:
            case IF:
            case IMMEDIATE:
            case INDICES:
            case INDEXTYPE:
            case INDICATOR:
            case INSERT:
            case INSTANTIABLE:
            case INTERVAL:
            case INVALIDATE:
            case ISOLATION:
            case JAVA:
            case LEVEL:
            case LIMIT:
            case LOCK:
            case LOOP:
            case MAP:
            case MAX:
            case MEMBER:
            case MERGE:
            case MIN:
            case MINUTE:
            case MLSLABEL:
            case MODIFY:
            case MOD:
            case MONTH:
            case NATURAL:
            case NEW:
            case NEW_DOT:
            case NO:
            case NOT:
            case NULL:
            case OBJECT:
            case OID:
            case OPAQUE:
            case OPEN:
            case OPERATOR:
            case ORGANIZATION:
            case OTHERS:
            case OVERRIDING:
            case PACKAGE:
            case PARTITION:
            case PIPE:
            case PRESERVE:
            case PRIVATE:
            case PROCEDURE:
            case RAISE:
            case RANGE:
            case RAW:
            case REAL:
            case RECORD:
            case REF:
            case RELIES_ON:
            case RESULT:
            case RETURN:
            case REVERSE:
            case ROLLBACK:
            case ROW:
            case ROWS:
            case ROWID:
            case ROWNUM:
            case SAVE:
            case SAVEPOINT:
            case SECOND:
            case SELECT:
            case SELF:
            case SET:
            case SPACE:
            case SQL:
            case SQLCODE:
            case SQLERRM:
            case STATIC:
            case SUBTYPE:
            case SUBSTITUTABLE:
            case SUCCESSFUL:
            case SYSDATE:
            case SYS_REFCURSOR:
            case TEMPORARY:
            case TIME:
            case TIMESTAMP:
            case TIMEZONE_REGION:
            case TIMEZONE_ABBR:
            case TIMEZONE_MINUTE:
            case TIMEZONE_HOUR:
            case TRANSACTION:
            case TRUE:
            case TYPE:
            case UNDER:
            case USING:
            case WHILE:
            case YES:
            case SHOW:
            case A:
            case UPDATE:
            case DOUBLE:
            case DEC:
            case PRECISION:
            case INT:
            case NUMERIC:
            case NCHAR:
            case NVARCHAR2:
            case STRING:
            case UROWID:
            case VARRAY:
            case VARYING:
            case BFILE:
            case BLOB:
            case CLOB:
            case NCLOB:
            case YEAR:
            case LOCAL:
            case WITH:
            case ZONE:
            case CHARACTER:
            case AFTER:
            case BEFORE:
            case OLD:
            case PARENT:
            case CC_IF:
            case CC_ERROR:
            case ANALYZE:
            case ASSOCIATE:
            case AUDIT:
            case COMPOUND:
            case DATABASE:
            case CALL:
            case DDL:
            case DISASSOCIATE:
            case EACH:
            case FOLLOWS:
            case LOGOFF:
            case LOGON:
            case NESTED:
            case NOAUDIT:
            case SCHEMA:
            case SERVERERROR:
            case SHUTDOWN:
            case STARTUP:
            case STATEMENT:
            case STATISTICS:
            case SUSPEND:
            case TRUNCATE:
            case WRAPPED:
            case LIBRARY:
            case NAME:
            case STRUCT:
            case CONTEXT:
            case PARAMETERS:
            case LENGTH:
            case TDO:
            case MAXLEN:
            case CHARSETID:
            case CHARSETFORM:
            case ACCEPT:
            case COPY:
            case DISCONNECT:
            case HOST:
            case PRINT:
            case QUIT:
            case REMARK:
            case UNDEFINE:
            case VARIABLE:
            case WHENEVER:
            case ATTACH:
            case CAST:
            case TREAT:
            case TRIM:
            case LEFT:
            case RIGHT:
            case BOTH:
            case EMPTY:
            case MULTISET:
            case SUBMULTISET:
            case LEADING:
            case TRAILING:
            case CHAR_CS:
            case NCHAR_CS:
            case DBTIMEZONE:
            case SESSIONTIMEZONE:
            case IDENTIFIER:
            case UNSIGNED_NUMERIC_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case QUOTED_LITERAL:
              ;
              break;
            default:
              jj_la1[154] = jj_gen;
              break label_38;
            }
          }
        }
        jj_consume_token(CC_END);
        break;
      case CC_ERROR:
        jj_consume_token(CC_ERROR);
        Expression();
        jj_consume_token(CC_END);
        break;
      default:
        jj_la1[155] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTSubTypeDefinition SubTypeDefinition() throws ParseException {
 /*@bgen(jjtree) SubTypeDefinition */
        ASTSubTypeDefinition jjtn000 = new ASTSubTypeDefinition(this, JJTSUBTYPEDEFINITION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        jjtn000.jjtSetFirstToken(getToken(1));Token start, subtype_name=null, constraint=null, base_type=null;
        Token collection = null, collection2 = null;
        SimpleNode name = null;
        SimpleNode startElement = null, endElement = null;
        SimpleNode baseType = null, returnType = null, indexBy = null ;
        int lastField = 0;
    try {
      switch (jj_nt.kind) {
      case SUBTYPE:
        jj_consume_token(SUBTYPE);
        name = QualifiedID();
        jj_consume_token(IS);
        Datatype();
        switch (jj_nt.kind) {
        case 5:
        case RANGE:
          switch (jj_nt.kind) {
          case 5:
            jj_consume_token(5);
            jj_consume_token(IDENTIFIER);
            jj_consume_token(7);
            break;
          case RANGE:
            jj_consume_token(RANGE);
            UnaryExpression(true);
            jj_consume_token(12);
            UnaryExpression(true);
            break;
          default:
            jj_la1[156] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[157] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case NOT:
          jj_consume_token(NOT);
          jj_consume_token(NULL);
          break;
        default:
          jj_la1[158] = jj_gen;
          ;
        }
        break;
      case TYPE:
        jj_consume_token(TYPE);
        name = QualifiedID();
        switch (jj_nt.kind) {
        case IS:
          jj_consume_token(IS);
          break;
        case AS:
          jj_consume_token(AS);
          break;
        default:
          jj_la1[159] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        if (jj_2_37(2)) {
          jj_consume_token(NEW);
          switch (jj_nt.kind) {
          case CHAR_BASE:
            jj_consume_token(CHAR_BASE);
            break;
          case DATE_BASE:
            jj_consume_token(DATE_BASE);
            break;
          case CLOB_BASE:
            jj_consume_token(CLOB_BASE);
            break;
          case BLOB_BASE:
            jj_consume_token(BLOB_BASE);
            break;
          case BFILE_BASE:
            jj_consume_token(BFILE_BASE);
            break;
          case NUMBER_BASE:
            jj_consume_token(NUMBER_BASE);
            break;
          default:
            jj_la1[160] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          switch (jj_nt.kind) {
          case OBJECT:
            jj_consume_token(OBJECT);
            jj_consume_token(5);
            FieldDeclaration();
            label_39:
            while (true) {
              switch (jj_nt.kind) {
              case 6:
                ;
                break;
              default:
                jj_la1[161] = jj_gen;
                break label_39;
              }
              jj_consume_token(6);
              FieldDeclaration();
            }
            jj_consume_token(7);
            break;
          case RECORD:
            jj_consume_token(RECORD);
            jj_consume_token(5);
            FieldDeclaration();
            label_40:
            while (true) {
              switch (jj_nt.kind) {
              case 6:
                ;
                break;
              default:
                jj_la1[162] = jj_gen;
                break label_40;
              }
              jj_consume_token(6);
              FieldDeclaration();
            }
            jj_consume_token(7);
            break;
          case TABLE:
          case VARRAY:
          case VARYING:
            switch (jj_nt.kind) {
            case TABLE:
              jj_consume_token(TABLE);
              break;
            case VARRAY:
              jj_consume_token(VARRAY);
              break;
            case VARYING:
              jj_consume_token(VARYING);
              jj_consume_token(ARRAY);
              break;
            default:
              jj_la1[163] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch (jj_nt.kind) {
            case 5:
              jj_consume_token(5);
              NumericLiteral();
              jj_consume_token(7);
              break;
            default:
              jj_la1[164] = jj_gen;
              ;
            }
            jj_consume_token(OF);
            Datatype();
            switch (jj_nt.kind) {
            case NOT:
              jj_consume_token(NOT);
              jj_consume_token(NULL);
              break;
            default:
              jj_la1[165] = jj_gen;
              ;
            }
            switch (jj_nt.kind) {
            case INDEX:
              jj_consume_token(INDEX);
              jj_consume_token(BY);
              Datatype();
              break;
            default:
              jj_la1[166] = jj_gen;
              ;
            }
            break;
          case REF:
            jj_consume_token(REF);
            jj_consume_token(CURSOR);
            switch (jj_nt.kind) {
            case RETURN:
              jj_consume_token(RETURN);
              Datatype();
              break;
            default:
              jj_la1[167] = jj_gen;
              ;
            }
            break;
          case 5:
            jj_consume_token(5);
            Expression();
            label_41:
            while (true) {
              switch (jj_nt.kind) {
              case 6:
                ;
                break;
              default:
                jj_la1[168] = jj_gen;
                break label_41;
              }
              jj_consume_token(6);
              Expression();
            }
            jj_consume_token(7);
            break;
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ARRAY:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BYTE:
          case CASCADE:
          case CHAR:
          case CHAR_BASE:
          case CLOSE:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CURRENT:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECIMAL:
          case DISABLE:
          case ELEMENT:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTIONS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FINAL:
          case FLOAT:
          case FORCE:
          case FUNCTION:
          case GLOBAL:
          case HASH:
          case HEAP:
          case HOUR:
          case IMMEDIATE:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSTANTIABLE:
          case INTEGER:
          case INTERVAL:
          case INVALIDATE:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIMIT:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NO:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OID:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case ORGANIZATION:
          case OTHERS:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRESERVE:
          case PRIVATE:
          case PROCEDURE:
          case RANGE:
          case RAW:
          case REAL:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELF:
          case SET:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case STATIC:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TEMPORARY:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TRANSACTION:
          case TRUE:
          case TYPE:
          case UNDER:
          case USING:
          case YES:
          case SHOW:
          case A:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
            Datatype();
            break;
          default:
            jj_la1[169] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[170] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(4);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(name.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTFieldDeclaration FieldDeclaration() throws ParseException {
 /*@bgen(jjtree) FieldDeclaration */
        ASTFieldDeclaration jjtn000 = new ASTFieldDeclaration(this, JJTFIELDDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        jjtn000.jjtSetFirstToken(getToken(1));SimpleNode name;
        SimpleNode dataType;
        SimpleNode defaultValue = null;
    try {
      name = ID();
      Datatype();
      switch (jj_nt.kind) {
      case NOT:
      case NULL:
        switch (jj_nt.kind) {
        case NOT:
          jj_consume_token(NOT);
          break;
        default:
          jj_la1[171] = jj_gen;
          ;
        }
        jj_consume_token(NULL);
        break;
      default:
        jj_la1[172] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case 9:
      case _DEFAULT:
        switch (jj_nt.kind) {
        case 9:
          jj_consume_token(9);
          jj_consume_token(10);
          break;
        case _DEFAULT:
          jj_consume_token(_DEFAULT);
          break;
        default:
          jj_la1[173] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        break;
      default:
        jj_la1[174] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(name.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCollectionTypeDefinition CollectionTypeDefinition() throws ParseException {
                                                          /*@bgen(jjtree) CollectionTypeDefinition */
                                                          ASTCollectionTypeDefinition jjtn000 = new ASTCollectionTypeDefinition(this, JJTCOLLECTIONTYPEDEFINITION);
                                                          boolean jjtc000 = true;
                                                          jjtree.openNodeScope(jjtn000);
                                                          jjtreeOpenNodeScope(jjtn000);
                                                          jjtn000.jjtSetFirstToken(getToken(1));Token t = null ;
    try {
      t = jj_consume_token(IDENTIFIER);
                                                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                                                  jjtc000 = false;
                                                                                                  jjtreeCloseNodeScope(jjtn000);
                                                                                                  jjtn000.jjtSetLastToken(getToken(0));
                                                                                                  jjtn000.setImage(t.image) ;  {if (true) return jjtn000 ;}
    } finally {
                                                                                 if (jjtc000) {
                                                                                   jjtree.closeNodeScope(jjtn000, true);
                                                                                   jjtreeCloseNodeScope(jjtn000);
                                                                                   jjtn000.jjtSetLastToken(getToken(0));
                                                                                 }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCollectionDeclaration CollectionDeclaration() throws ParseException {
                                                    /*@bgen(jjtree) CollectionDeclaration */
                                                    ASTCollectionDeclaration jjtn000 = new ASTCollectionDeclaration(this, JJTCOLLECTIONDECLARATION);
                                                    boolean jjtc000 = true;
                                                    jjtree.openNodeScope(jjtn000);
                                                    jjtreeOpenNodeScope(jjtn000);
                                                    jjtn000.jjtSetFirstToken(getToken(1));Token t = null ;
    try {
      t = jj_consume_token(IDENTIFIER);
                                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                                            jjtc000 = false;
                                                                                            jjtreeCloseNodeScope(jjtn000);
                                                                                            jjtn000.jjtSetLastToken(getToken(0));
                                                                                            jjtn000.setImage(t.image) ;  {if (true) return jjtn000 ;}
    } finally {
                                                                           if (jjtc000) {
                                                                             jjtree.closeNodeScope(jjtn000, true);
                                                                             jjtreeCloseNodeScope(jjtn000);
                                                                             jjtn000.jjtSetLastToken(getToken(0));
                                                                           }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTObjectDeclaration ObjectDeclaration() throws ParseException {
                                            /*@bgen(jjtree) ObjectDeclaration */
                                            ASTObjectDeclaration jjtn000 = new ASTObjectDeclaration(this, JJTOBJECTDECLARATION);
                                            boolean jjtc000 = true;
                                            jjtree.openNodeScope(jjtn000);
                                            jjtreeOpenNodeScope(jjtn000);
                                            jjtn000.jjtSetFirstToken(getToken(1));Token t = null ;
    try {
      t = jj_consume_token(IDENTIFIER);
                                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                                    jjtc000 = false;
                                                                                    jjtreeCloseNodeScope(jjtn000);
                                                                                    jjtn000.jjtSetLastToken(getToken(0));
                                                                                    jjtn000.setImage(t.image) ;  {if (true) return jjtn000 ;}
    } finally {
                                                                   if (jjtc000) {
                                                                     jjtree.closeNodeScope(jjtn000, true);
                                                                     jjtreeCloseNodeScope(jjtn000);
                                                                     jjtn000.jjtSetLastToken(getToken(0));
                                                                   }
    }
    throw new Error("Missing return statement in function");
  }

/** Java stored procedure, external function*/
  final public ASTCallSpecTail CallSpecTail() throws ParseException {
                                  /*@bgen(jjtree) CallSpecTail */
  ASTCallSpecTail jjtn000 = new ASTCallSpecTail(this, JJTCALLSPECTAIL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case EXTERNAL:
        jj_consume_token(EXTERNAL);
        break;
      case LANGUAGE:
        jj_consume_token(LANGUAGE);
        switch (jj_nt.kind) {
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case JAVA:
          jj_consume_token(JAVA);
          break;
        default:
          jj_la1[175] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[176] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_42:
      while (true) {
        switch (jj_nt.kind) {
        case WITH:
        case LIBRARY:
        case NAME:
        case PARAMETERS:
          ;
          break;
        default:
          jj_la1[177] = jj_gen;
          break label_42;
        }
        switch (jj_nt.kind) {
        case LIBRARY:
          jj_consume_token(LIBRARY);
          switch (jj_nt.kind) {
          case IDENTIFIER:
            jj_consume_token(IDENTIFIER);
            break;
          case QUOTED_LITERAL:
            jj_consume_token(QUOTED_LITERAL);
            break;
          case STRING_LITERAL:
            StringLiteral();
            break;
          default:
            jj_la1[178] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch (jj_nt.kind) {
          case 3:
            jj_consume_token(3);
            switch (jj_nt.kind) {
            case IDENTIFIER:
              jj_consume_token(IDENTIFIER);
              break;
            case QUOTED_LITERAL:
              jj_consume_token(QUOTED_LITERAL);
              break;
            case STRING_LITERAL:
              StringLiteral();
              break;
            default:
              jj_la1[179] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[180] = jj_gen;
            ;
          }
          break;
        case NAME:
          jj_consume_token(NAME);
          switch (jj_nt.kind) {
          case IDENTIFIER:
            jj_consume_token(IDENTIFIER);
            break;
          case QUOTED_LITERAL:
            jj_consume_token(QUOTED_LITERAL);
            break;
          case STRING_LITERAL:
            StringLiteral();
            break;
          default:
            jj_la1[181] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case WITH:
          jj_consume_token(WITH);
          jj_consume_token(CONTEXT);
          break;
        case PARAMETERS:
          jj_consume_token(PARAMETERS);
          SkipPastNextOccurrence(")");
          break;
        default:
          jj_la1[182] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/** Cursor (common part of specification and body) */
  final public ASTCursorUnit CursorUnit() throws ParseException {
 /*@bgen(jjtree) CursorUnit */
 ASTCursorUnit jjtn000 = new ASTCursorUnit(this, JJTCURSORUNIT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      jj_consume_token(CURSOR);
      simpleNode = ID();
      switch (jj_nt.kind) {
      case 5:
        FormalParameters();
        break;
      default:
        jj_la1[183] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case RETURN:
        jj_consume_token(RETURN);
        Datatype();
        break;
      default:
        jj_la1[184] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case IS:
        jj_consume_token(IS);
        label_43:
        while (true) {
          switch (jj_nt.kind) {
          case 5:
            ;
            break;
          default:
            jj_la1[185] = jj_gen;
            break label_43;
          }
          jj_consume_token(5);
        }
        SqlStatement(null,";");
        break;
      default:
        jj_la1[186] = jj_gen;
        ;
      }
      jj_consume_token(4);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCursorSpecification CursorSpecification() throws ParseException {
                                                 /*@bgen(jjtree) CursorSpecification */
  ASTCursorSpecification jjtn000 = new ASTCursorSpecification(this, JJTCURSORSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      CursorUnit();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCursorBody CursorBody() throws ParseException {
                               /*@bgen(jjtree) CursorBody */
  ASTCursorBody jjtn000 = new ASTCursorBody(this, JJTCURSORBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      CursorUnit();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

// ============================================================================
// E X P R E S S I O N S
// ============================================================================

/*
String expression() :
{}
{
	"test"
	{ return ""; }
}
*/
  final public ASTExpression Expression() throws ParseException {
 /*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
  StringBuffer sb = new StringBuffer() ;
    try {
      if (jj_2_38(2147483647)) {
        simpleNode = Assignment();
                                                                              sb.append(simpleNode.getImage());
      } else {
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FINAL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case HASH:
        case HEAP:
        case HOUR:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case YES:
        case SHOW:
        case A:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          simpleNode = ConditionalOrExpression();
                                                      sb.append(simpleNode.getImage());
          break;
        case CC_IF:
          simpleNode = CompilationExpression();
                                                    sb.append(simpleNode.getImage());
          break;
        default:
          jj_la1[187] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCompilationExpression CompilationExpression() throws ParseException {
 /*@bgen(jjtree) CompilationExpression */
  ASTCompilationExpression jjtn000 = new ASTCompilationExpression(this, JJTCOMPILATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
  StringBuffer sb = new StringBuffer() ;
    try {
      jj_consume_token(CC_IF);
                   sb.append(" "); sb.append(token.image) ;
      simpleNode = ConditionalOrExpression();
                                                   sb.append(" "); sb.append(simpleNode.getImage());
      jj_consume_token(CC_THEN);
                     sb.append(" "); sb.append(token.image);
      simpleNode = Expression();
                                     sb.append(" "); sb.append(simpleNode.getImage());
      label_44:
      while (true) {
        switch (jj_nt.kind) {
        case CC_ELSIF:
          ;
          break;
        default:
          jj_la1[188] = jj_gen;
          break label_44;
        }
        jj_consume_token(CC_ELSIF);
                        sb.append(" "); sb.append(token.image);
        simpleNode = ConditionalOrExpression();
                                                    sb.append(" "); sb.append(simpleNode.getImage());
        jj_consume_token(CC_THEN);
                       sb.append(" "); sb.append(token.image);
        simpleNode = Expression();
                                       sb.append(" "); sb.append(simpleNode.getImage());
      }
      label_45:
      while (true) {
        switch (jj_nt.kind) {
        case CC_ELSE:
          ;
          break;
        default:
          jj_la1[189] = jj_gen;
          break label_45;
        }
        jj_consume_token(CC_ELSE);
                       sb.append(" "); sb.append(token.image);
        simpleNode = Expression();
                                        sb.append(" "); sb.append(simpleNode.getImage());
      }
      jj_consume_token(CC_END);
                    sb.append(" "); sb.append(token.image);
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTAssignment Assignment() throws ParseException {
 /*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(this, JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = PrimaryExpression();
                                       sb.append(simpleNode.getImage());
      jj_consume_token(9);
      jj_consume_token(10);
               sb.append(" := ");
      simpleNode = Expression();
                               sb.append(simpleNode.getImage());
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCaseExpression CaseExpression() throws ParseException {
 /*@bgen(jjtree) CaseExpression */
  ASTCaseExpression jjtn000 = new ASTCaseExpression(this, JJTCASEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token thisToken;  SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      thisToken = jj_consume_token(CASE);
                             sb.append(thisToken.image);
      switch (jj_nt.kind) {
      case 5:
      case 16:
      case 17:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NOT:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case CC_IF:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        simpleNode = Expression();
                                      sb.append(" "); sb.append(simpleNode.getImage());
        break;
      default:
        jj_la1[190] = jj_gen;
        ;
      }
      label_46:
      while (true) {
        thisToken = jj_consume_token(WHEN);
                                 sb.append("  "); sb.append(thisToken.image);
        simpleNode = Expression();
                                            sb.append(" "); sb.append(simpleNode.getImage());
        thisToken = jj_consume_token(THEN);
                                   sb.append(" "); sb.append(thisToken.image);
        Expression();
                                 sb.append(" "); sb.append(simpleNode.getImage());
        switch (jj_nt.kind) {
        case WHEN:
          ;
          break;
        default:
          jj_la1[191] = jj_gen;
          break label_46;
        }
      }
      switch (jj_nt.kind) {
      case ELSE:
        thisToken = jj_consume_token(ELSE);
                                 sb.append(" "); sb.append(thisToken.image);
        Expression();
                               sb.append(" "); sb.append(simpleNode.getImage());
        break;
      default:
        jj_la1[192] = jj_gen;
        ;
      }
      thisToken = jj_consume_token(END);
                              sb.append(" "); sb.append(thisToken.image);
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/*
LIKE ( Expression ) [ <ESCAPE> <STRINGLITERAL>
*/
  final public ASTLikeExpression LikeExpression() throws ParseException {
 /*@bgen(jjtree) LikeExpression */
  ASTLikeExpression jjtn000 = new ASTLikeExpression(this, JJTLIKEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token thisToken;  SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = PrimaryExpression();
                                           sb.append(" "); sb.append(simpleNode.getImage());
      thisToken = jj_consume_token(LIKE);
                                sb.append(thisToken.image);
      simpleNode = StringExpression();
                                            sb.append(" "); sb.append(simpleNode.getImage());
      switch (jj_nt.kind) {
      case ESCAPE:
        jj_consume_token(ESCAPE);
                   sb.append(" ESCAPE ");
        switch (jj_nt.kind) {
        case CHARACTER_LITERAL:
          jj_consume_token(CHARACTER_LITERAL);
                                sb.append(" "); sb.append(token.toString());
          break;
        case STRING_LITERAL:
          simpleNode = StringLiteral();
                                           sb.append(" "); sb.append(simpleNode.getImage());
          break;
        default:
          jj_la1[193] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[194] = jj_gen;
        ;
      }
      label_47:
      while (true) {
        switch (jj_nt.kind) {
        case 3:
          ;
          break;
        default:
          jj_la1[195] = jj_gen;
          break label_47;
        }
        jj_consume_token(3);
        simpleNode = Expression();
                                    sb.append("."); sb.append(simpleNode.getImage());
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTTrimExpression TrimExpression() throws ParseException {
 /*@bgen(jjtree) TrimExpression */
  ASTTrimExpression jjtn000 = new ASTTrimExpression(this, JJTTRIMEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token thisToken;  SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      thisToken = jj_consume_token(TRIM);
                                sb.append(thisToken.image);
      jj_consume_token(5);
              sb.append("(");
      switch (jj_nt.kind) {
      case BOTH:
      case LEADING:
      case TRAILING:
        switch (jj_nt.kind) {
        case LEADING:
          jj_consume_token(LEADING);
          break;
        case TRAILING:
          jj_consume_token(TRAILING);
          break;
        case BOTH:
          jj_consume_token(BOTH);
          break;
        default:
          jj_la1[196] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                sb.append(" "); sb.append(token.toString());
        break;
      default:
        jj_la1[197] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case 5:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        simpleNode = StringExpression();
                                             sb.append(" "); sb.append(simpleNode.getImage());
        break;
      default:
        jj_la1[198] = jj_gen;
        ;
      }
      jj_consume_token(FROM);
                        sb.append(thisToken.image);
      simpleNode = StringExpression();
                                           sb.append(" "); sb.append(simpleNode.getImage());
      jj_consume_token(7);
              sb.append(")");
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/*
TREAT ( Expression AS datatype)
CAST ( Expression AS datatype)
*/
  final public ASTObjectExpression ObjectExpression() throws ParseException {
 /*@bgen(jjtree) ObjectExpression */
  ASTObjectExpression jjtn000 = new ASTObjectExpression(this, JJTOBJECTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token thisToken;  SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      switch (jj_nt.kind) {
      case CAST:
        thisToken = jj_consume_token(CAST);
        break;
      case TREAT:
        thisToken = jj_consume_token(TREAT);
        break;
      default:
        jj_la1[199] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                      sb.append(thisToken.image);
      jj_consume_token(5);
              sb.append("(");
      simpleNode = Expression();
                                      sb.append(" "); sb.append(simpleNode.getImage());
      switch (jj_nt.kind) {
      case AT:
        jj_consume_token(AT);
        jj_consume_token(TIME);
        jj_consume_token(ZONE);
        simpleNode = PrimaryExpression();
                                                               sb.append(" AT TIME ZONE "); sb.append(simpleNode.getImage());
        break;
      default:
        jj_la1[200] = jj_gen;
        ;
      }
      jj_consume_token(AS);
               sb.append(" AS ");
      simpleNode = Datatype();
                                    sb.append(" "); sb.append(simpleNode.getImage());
      jj_consume_token(7);
              sb.append(")");
      label_48:
      while (true) {
        switch (jj_nt.kind) {
        case 3:
          ;
          break;
        default:
          jj_la1[201] = jj_gen;
          break label_48;
        }
        jj_consume_token(3);
        Expression();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTConditionalOrExpression ConditionalOrExpression() throws ParseException {
 /*@bgen(jjtree) ConditionalOrExpression */
  ASTConditionalOrExpression jjtn000 = new ASTConditionalOrExpression(this, JJTCONDITIONALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = ConditionalAndExpression();
                                               sb.append(simpleNode.getImage());
      label_49:
      while (true) {
        switch (jj_nt.kind) {
        case OR:
          ;
          break;
        default:
          jj_la1[202] = jj_gen;
          break label_49;
        }
        jj_consume_token(OR);
            sb.append(" OR ");
        simpleNode = ConditionalAndExpression();
                                                sb.append(simpleNode.getImage());
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTConditionalAndExpression ConditionalAndExpression() throws ParseException {
 /*@bgen(jjtree) ConditionalAndExpression */
  ASTConditionalAndExpression jjtn000 = new ASTConditionalAndExpression(this, JJTCONDITIONALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = EqualityExpression();
                                          sb.append(simpleNode.getImage());
      label_50:
      while (true) {
        switch (jj_nt.kind) {
        case AND:
          ;
          break;
        default:
          jj_la1[203] = jj_gen;
          break label_50;
        }
        jj_consume_token(AND);
               sb.append(" AND ");
        simpleNode = EqualityExpression();
                                            sb.append(simpleNode.getImage());
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTEqualityExpression EqualityExpression() throws ParseException {
 /*@bgen(jjtree) EqualityExpression */
  ASTEqualityExpression jjtn000 = new ASTEqualityExpression(this, JJTEQUALITYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = RelationalExpression();
             sb.append(simpleNode.getImage());
      label_51:
      while (true) {
        switch (jj_nt.kind) {
        case 10:
        case 13:
        case IS:
          ;
          break;
        default:
          jj_la1[204] = jj_gen;
          break label_51;
        }
        switch (jj_nt.kind) {
        case 10:
          jj_consume_token(10);
                     sb.append(" = ");
          break;
        case 13:
          jj_consume_token(13);
          jj_consume_token(10);
                         sb.append(" != ");
          break;
        case IS:
          jj_consume_token(IS);
                     sb.append(" IS ");
          break;
        default:
          jj_la1[205] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        simpleNode = RelationalExpression();
              sb.append(simpleNode.getImage());
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 2006-05-23 - Matthias Hendler - added FROM
 */
  final public ASTRelationalExpression RelationalExpression() throws ParseException {
 /*@bgen(jjtree) RelationalExpression */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(this, JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = AdditiveExpression();
                                         sb.append(simpleNode.getImage());
      label_52:
      while (true) {
        switch (jj_nt.kind) {
        case 14:
        case 15:
        case BETWEEN:
        case FROM:
        case IN:
        case LIKE:
        case MEMBER:
        case NOT:
        case MULTISET:
        case SUBMULTISET:
          ;
          break;
        default:
          jj_la1[206] = jj_gen;
          break label_52;
        }
        switch (jj_nt.kind) {
        case 14:
        case 15:
          switch (jj_nt.kind) {
          case 14:
            jj_consume_token(14);
                      sb.append("<");
            switch (jj_nt.kind) {
            case 15:
              jj_consume_token(15);
                     sb.append(">");
              break;
            default:
              jj_la1[207] = jj_gen;
              ;
            }
            break;
          case 15:
            jj_consume_token(15);
                     sb.append(">");
            break;
          default:
            jj_la1[208] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch (jj_nt.kind) {
          case 10:
            jj_consume_token(10);
                   sb.append("=");
            break;
          default:
            jj_la1[209] = jj_gen;
            ;
          }
        sb.append(" ");
          break;
        case BETWEEN:
        case FROM:
        case IN:
        case LIKE:
        case MEMBER:
        case NOT:
        case SUBMULTISET:
          switch (jj_nt.kind) {
          case NOT:
            jj_consume_token(NOT);
                sb.append(" NOT ");
            break;
          default:
            jj_la1[210] = jj_gen;
            ;
          }
          switch (jj_nt.kind) {
          case IN:
            jj_consume_token(IN);
               sb.append(" IN ");
            break;
          case BETWEEN:
            jj_consume_token(BETWEEN);
                      sb.append(" BETWEEN ");
            break;
          case LIKE:
            jj_consume_token(LIKE);
                   sb.append(" LIKE ");
            break;
          case FROM:
            jj_consume_token(FROM);
                  sb.append(" FROM ");
            break;
          case MEMBER:
          case SUBMULTISET:
            switch (jj_nt.kind) {
            case MEMBER:
              jj_consume_token(MEMBER);
                        sb.append(" MEMBER ");
              break;
            case SUBMULTISET:
              jj_consume_token(SUBMULTISET);
                             sb.append(" SUBMULTISET ");
              break;
            default:
              jj_la1[211] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch (jj_nt.kind) {
            case OF:
              jj_consume_token(OF);
                  sb.append(" OF ");
              break;
            default:
              jj_la1[212] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[213] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case MULTISET:
          jj_consume_token(MULTISET);
                    sb.append (" MULTISET " );
          switch (jj_nt.kind) {
          case EXCEPT:
            jj_consume_token(EXCEPT);
                       sb.append (" EXCEPT " );
            break;
          case INTERSECT:
            jj_consume_token(INTERSECT);
                          sb.append (" INTERSECT " );
            break;
          case UNION:
            jj_consume_token(UNION);
                      sb.append (" UNION " );
            break;
          default:
            jj_la1[214] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch (jj_nt.kind) {
          case ALL:
          case DISTINCT:
            switch (jj_nt.kind) {
            case DISTINCT:
              jj_consume_token(DISTINCT);
                         sb.append (" DISTINCT " );
              break;
            case ALL:
              jj_consume_token(ALL);
                    sb.append (" ALL " );
              break;
            default:
              jj_la1[215] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[216] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[217] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        AdditiveExpression();
                             sb.append(simpleNode.getImage());
        switch (jj_nt.kind) {
        case ESCAPE:
          jj_consume_token(ESCAPE);
                   sb.append(" ESCAPE ");
          switch (jj_nt.kind) {
          case CHARACTER_LITERAL:
            jj_consume_token(CHARACTER_LITERAL);
                                sb.append(" "); sb.append(token.toString());
            break;
          case STRING_LITERAL:
            simpleNode = StringLiteral();
                                           sb.append(" "); sb.append(simpleNode.getImage());
            break;
          default:
            jj_la1[218] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[219] = jj_gen;
          ;
        }
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTAdditiveExpression AdditiveExpression() throws ParseException {
 /*@bgen(jjtree) AdditiveExpression */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(this, JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = MultiplicativeExpression();
                                               sb.append(simpleNode.getImage());
      label_53:
      while (true) {
        switch (jj_nt.kind) {
        case 16:
        case 17:
        case 18:
          ;
          break;
        default:
          jj_la1[220] = jj_gen;
          break label_53;
        }
        switch (jj_nt.kind) {
        case 16:
          jj_consume_token(16);
               sb.append(" + ");
          break;
        case 17:
          jj_consume_token(17);
               sb.append(" - ");
          break;
        case 18:
          jj_consume_token(18);
                sb.append(" || ");
          break;
        default:
          jj_la1[221] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        simpleNode = MultiplicativeExpression();
                                                 sb.append(simpleNode.getImage());
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTStringExpression StringExpression() throws ParseException {
 /*@bgen(jjtree) StringExpression */
  ASTStringExpression jjtn000 = new ASTStringExpression(this, JJTSTRINGEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = PrimaryExpression();
                                        sb.append(simpleNode.getImage());
      label_54:
      while (true) {
        switch (jj_nt.kind) {
        case 18:
          ;
          break;
        default:
          jj_la1[222] = jj_gen;
          break label_54;
        }
        jj_consume_token(18);
               sb.append(" || ");
        simpleNode = PrimaryExpression();
                                          sb.append(simpleNode.getImage());
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTMultiplicativeExpression MultiplicativeExpression() throws ParseException {
 /*@bgen(jjtree) MultiplicativeExpression */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(this, JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      simpleNode = UnaryExpression(true);
                                          sb.append(simpleNode.getImage());
      label_55:
      while (true) {
        switch (jj_nt.kind) {
        case 1:
        case 19:
        case 20:
        case MOD:
          ;
          break;
        default:
          jj_la1[223] = jj_gen;
          break label_55;
        }
        switch (jj_nt.kind) {
        case 19:
          jj_consume_token(19);
                 sb.append(" ** ");
          break;
        case 20:
          jj_consume_token(20);
                sb.append(" * ");
          break;
        case 1:
          jj_consume_token(1);
                sb.append(" / ");
          break;
        case MOD:
          jj_consume_token(MOD);
                  sb.append(" MOD ");
          break;
        default:
          jj_la1[224] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        simpleNode = UnaryExpression(true);
                                            sb.append(simpleNode.getImage());
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTUnaryExpression UnaryExpression(boolean isUnarySign) throws ParseException {
 /*@bgen(jjtree) UnaryExpression */
  ASTUnaryExpression jjtn000 = new ASTUnaryExpression(this, JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      switch (jj_nt.kind) {
      case 16:
      case 17:
        switch (jj_nt.kind) {
        case 16:
          jj_consume_token(16);
              sb.append(isUnarySign ? " +" : " + ");
          break;
        case 17:
          jj_consume_token(17);
              sb.append(isUnarySign ? " -" : " - ");
          break;
        default:
          jj_la1[225] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        simpleNode = UnaryExpression(false);
                                            sb.append(simpleNode.getImage());
        break;
      case 5:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NOT:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        simpleNode = UnaryExpressionNotPlusMinus();
                                                   sb.append(simpleNode.getImage());
        break;
      default:
        jj_la1[226] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTUnaryExpressionNotPlusMinus UnaryExpressionNotPlusMinus() throws ParseException {
 /*@bgen(jjtree) UnaryExpressionNotPlusMinus */
  ASTUnaryExpressionNotPlusMinus jjtn000 = new ASTUnaryExpressionNotPlusMinus(this, JJTUNARYEXPRESSIONNOTPLUSMINUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      switch (jj_nt.kind) {
      case NOT:
        jj_consume_token(NOT);
           sb.append(" NOT ");
        simpleNode = UnaryExpression(false);
                                           sb.append(simpleNode.getImage());
        break;
      case 5:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        simpleNode = PrimaryExpression();
                                         sb.append(simpleNode.getImage());
        break;
      default:
        jj_la1[227] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 2006-05-23 - Matthias Hendler - Added lookahead otherwise warning encountered.
 *                                 Warning arised while adding methode triggerUnit(). 
 * 2011-04-27 - SRT - Add optional NEW Keyword to cope with Object Type constructors
 */
  final public ASTPrimaryExpression PrimaryExpression() throws ParseException {
 /*@bgen(jjtree) PrimaryExpression */
  ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(this, JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token thisToken ; SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      switch (jj_nt.kind) {
      case NEW_DOT:
        jj_consume_token(NEW_DOT);
        simpleNode = QualifiedID();
                                                       sb.append(" NEW."); sb.append(simpleNode.getImage());
        break;
      case 5:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NO:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        if (jj_2_39(2147483647)) {
          jj_consume_token(NEW);
                sb.append(" NEW ");
          simpleNode = PrimaryPrefix();
                                                                       sb.append(simpleNode.getImage());
        } else {
          switch (jj_nt.kind) {
          case 5:
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ARRAY:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case BODY:
          case BULK:
          case BYTE:
          case CASCADE:
          case CASE:
          case CLOSE:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CURRENT:
          case CURSOR:
          case DATA:
          case DAY:
          case DISABLE:
          case ELEMENT:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTIONS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FINAL:
          case FORCE:
          case FUNCTION:
          case GLOBAL:
          case HASH:
          case HEAP:
          case HOUR:
          case IMMEDIATE:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSTANTIABLE:
          case INTERVAL:
          case INVALIDATE:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIMIT:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MONTH:
          case NATURAL:
          case NEW:
          case NO:
          case NULL:
          case OBJECT:
          case OID:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case ORGANIZATION:
          case OTHERS:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PRESERVE:
          case PRIVATE:
          case PROCEDURE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SET:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case STATIC:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TEMPORARY:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TRANSACTION:
          case TRUE:
          case TYPE:
          case UNDER:
          case USING:
          case YES:
          case SHOW:
          case A:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case UNSIGNED_NUMERIC_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case QUOTED_LITERAL:
            simpleNode = PrimaryPrefix();
                                               sb.append(simpleNode.getImage());
            break;
          default:
            jj_la1[228] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        label_56:
        while (true) {
          if (jj_2_40(2)) {
            ;
          } else {
            break label_56;
          }
          simpleNode = PrimarySuffix();
                                                           sb.append(simpleNode.getImage());
        }
        break;
      default:
        jj_la1[229] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTPrimaryPrefix PrimaryPrefix() throws ParseException {
 /*@bgen(jjtree) PrimaryPrefix */
  ASTPrimaryPrefix jjtn000 = new ASTPrimaryPrefix(this, JJTPRIMARYPREFIX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null; StringBuffer sb = new StringBuffer() ;
    try {
      switch (jj_nt.kind) {
      case FALSE:
      case INTERVAL:
      case NULL:
      case TIMESTAMP:
      case TRUE:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
        simpleNode = Literal();
                               sb.append(simpleNode.getImage()) ;
        break;
      default:
        jj_la1[231] = jj_gen;
        if (jj_2_41(2147483647)) {
          simpleNode = MultiSetCondition();
        } else if (jj_2_42(2147483647)) {
          simpleNode = TrimExpression();
        } else if (jj_2_43(2147483647)) {
          simpleNode = CaseExpression();
                                                                 sb.append(simpleNode.getImage()) ;
        } else if (jj_2_44(2147483647)) {
          simpleNode = ObjectExpression();
                                                                       sb.append(simpleNode.getImage()) ;
        } else {
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ARRAY:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case BODY:
          case BULK:
          case BYTE:
          case CASCADE:
          case CLOSE:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CURRENT:
          case CURSOR:
          case DATA:
          case DAY:
          case DISABLE:
          case ELEMENT:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTIONS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FINAL:
          case FORCE:
          case FUNCTION:
          case GLOBAL:
          case HASH:
          case HEAP:
          case HOUR:
          case IMMEDIATE:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSTANTIABLE:
          case INTERVAL:
          case INVALIDATE:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIMIT:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MONTH:
          case NATURAL:
          case NEW:
          case NO:
          case OBJECT:
          case OID:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case ORGANIZATION:
          case OTHERS:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PRESERVE:
          case PRIVATE:
          case PROCEDURE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELF:
          case SET:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case STATIC:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TEMPORARY:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TRANSACTION:
          case TRUE:
          case TYPE:
          case UNDER:
          case USING:
          case YES:
          case SHOW:
          case A:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
            simpleNode = Name();
                           sb.append(simpleNode.getImage()) ;
            break;
          default:
            jj_la1[232] = jj_gen;
            if (jj_2_45(2147483647)) {
              jj_consume_token(SELECT);
                                  sb.append("SELECT ...");
              Skip2NextTerminator(null,";");
            } else if (jj_2_46(2147483647)) {
              jj_consume_token(5);
                                    sb.append("(SELECT ...");
              Skip2NextTerminator("(",")");
              jj_consume_token(7);
            } else if (jj_2_47(2147483647)) {
              jj_consume_token(WITH);
                              sb.append("WITH ...");
              Skip2NextTerminator(null,";");
            } else if (jj_2_48(2147483647)) {
              jj_consume_token(5);
                                  sb.append("(WITH ...");
              Skip2NextTerminator("(",")");
              jj_consume_token(7);
            } else {
              switch (jj_nt.kind) {
              case 5:
                jj_consume_token(5);
          sb.append("(");
                simpleNode = Expression();
                                sb.append(simpleNode.getImage());
                label_57:
                while (true) {
                  switch (jj_nt.kind) {
                  case 6:
                    ;
                    break;
                  default:
                    jj_la1[230] = jj_gen;
                    break label_57;
                  }
                  jj_consume_token(6);
           sb.append(", ");
                  simpleNode = Expression();
                                  sb.append(simpleNode.getImage());
                }
                jj_consume_token(7);
         sb.append(")");
                break;
              default:
                jj_la1[233] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
        }
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTPrimarySuffix PrimarySuffix() throws ParseException {
 /*@bgen(jjtree) PrimarySuffix */
  ASTPrimarySuffix jjtn000 = new ASTPrimarySuffix(this, JJTPRIMARYSUFFIX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));SimpleNode suffixNode = null ; SimpleNode arguments = null; StringBuffer sb = new StringBuffer() ;
    try {
      switch (jj_nt.kind) {
      case 3:
        jj_consume_token(3);
         sb.append(".");
        suffixNode = QualifiedID();
                                                           sb.append(suffixNode.toString()) ;
        break;
      case 2:
        jj_consume_token(2);
         sb.append("@");
        suffixNode = QualifiedID();
                                                           sb.append(suffixNode.toString()) ;
        break;
      case AT:
        jj_consume_token(AT);
          sb.append(" "); sb.append(token.image.toUpperCase());
        switch (jj_nt.kind) {
        case LOCAL:
          jj_consume_token(LOCAL);
                      sb.append(" "); sb.append(token.image.toUpperCase());
          break;
        case TIME:
          jj_consume_token(TIME);
          jj_consume_token(ZONE);
                               sb.append(" TIME ZONE");
          switch (jj_nt.kind) {
          case DBTIMEZONE:
            jj_consume_token(DBTIMEZONE);
                                  sb.append(" "); sb.append(token.image.toUpperCase());
            break;
          case SESSIONTIMEZONE:
            jj_consume_token(SESSIONTIMEZONE);
                                       sb.append(" "); sb.append(token.image.toUpperCase());
            break;
          case STRING_LITERAL:
            suffixNode = StringLiteral();
                                                  sb.append(" "); sb.append(suffixNode.toString());
            break;
          case 5:
          case 16:
          case 17:
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ARRAY:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case BODY:
          case BULK:
          case BYTE:
          case CASCADE:
          case CASE:
          case CLOSE:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CURRENT:
          case CURSOR:
          case DATA:
          case DAY:
          case DISABLE:
          case ELEMENT:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTIONS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FINAL:
          case FORCE:
          case FUNCTION:
          case GLOBAL:
          case HASH:
          case HEAP:
          case HOUR:
          case IMMEDIATE:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSTANTIABLE:
          case INTERVAL:
          case INVALIDATE:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIMIT:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MONTH:
          case NATURAL:
          case NEW:
          case NEW_DOT:
          case NO:
          case NOT:
          case NULL:
          case OBJECT:
          case OID:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case ORGANIZATION:
          case OTHERS:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PRESERVE:
          case PRIVATE:
          case PROCEDURE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SET:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case STATIC:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TEMPORARY:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TRANSACTION:
          case TRUE:
          case TYPE:
          case UNDER:
          case USING:
          case YES:
          case SHOW:
          case A:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case CC_IF:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case IDENTIFIER:
          case UNSIGNED_NUMERIC_LITERAL:
          case CHARACTER_LITERAL:
          case QUOTED_LITERAL:
            suffixNode = Expression();
                                               sb.append(" "); sb.append(suffixNode.toString());
            break;
          default:
            jj_la1[234] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[235] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case 5:
        arguments = Arguments();
                               sb.append(arguments) ;
        break;
      default:
        jj_la1[236] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 jjtn000.setImage(sb.toString()); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTLiteral Literal() throws ParseException {
 /*@bgen(jjtree) Literal */
 ASTLiteral jjtn000 = new ASTLiteral(this, JJTLITERAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
 Token t = null ;
    try {
      switch (jj_nt.kind) {
      case UNSIGNED_NUMERIC_LITERAL:
        simpleNode = NumericLiteral();
        break;
      case CHARACTER_LITERAL:
        t = jj_consume_token(CHARACTER_LITERAL);
        break;
      case STRING_LITERAL:
        //<STRING_LITERAL> {literal = token.toString(); }
          simpleNode = StringLiteral();
        break;
      case FALSE:
      case TRUE:
        simpleNode = BooleanLiteral();
        break;
      case NULL:
        simpleNode = NullLiteral();
        break;
      case INTERVAL:
      case TIMESTAMP:
        simpleNode = DateTimeLiteral();
        break;
      default:
        jj_la1[237] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
   if (null != simpleNode)
   {
     jjtn000.setImage( simpleNode.getImage() ) ;
   }
   else if (null != t)
   {
     jjtn000.setImage( t.image ) ;
   }
   {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTStringLiteral StringLiteral() throws ParseException {
 /*@bgen(jjtree) StringLiteral */
        ASTStringLiteral jjtn000 = new ASTStringLiteral(this, JJTSTRINGLITERAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        jjtn000.jjtSetFirstToken(getToken(1));Token thisToken = null;
        StringBuffer literal = new StringBuffer() ;
        char startDelimiter ;
        char endDelimiter ;
        String terminator = null;
    try {
      thisToken = jj_consume_token(STRING_LITERAL);
   literal.append(thisToken.image);
   /*
   This might be Q-Quoted string and this might be only a partial string
   The token will only match up to the first single quote.
   The code below appends any remaining part, theh returns the complete string
   */
   if (thisToken.image.toUpperCase().startsWith("Q'")
       && thisToken.image.length() > 2
      )
   {
   // Get the first token of the string so that the delimiter can be identified

     startDelimiter= thisToken.image.charAt(2) ;
     /*
     if the start delimiter is one of [, {, <, or (, the end delimiter
     is the corresponding closing character
     */
     switch (startDelimiter)
     {
      case '<' : endDelimiter = '>' ; break ;
      case '{' : endDelimiter = '}' ;  break ;
      case '(' : endDelimiter = ')' ;  break ;
      case '[' : endDelimiter = ']' ;  break ;
      default: endDelimiter = startDelimiter ;
     }

     terminator = new String(endDelimiter + "'");
     if (!thisToken.image.endsWith(terminator))
     {
       //Loop until we find atoken that ends with a single-quote precede by the terminator
       literal.append(ReadPastNextOccurrence(terminator));
     }
   }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
   jjtn000.setImage(literal.toString()) ;  jjtn000.value = literal.toString() ; {if (true) return jjtn000 ;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTBooleanLiteral BooleanLiteral() throws ParseException {
 /*@bgen(jjtree) BooleanLiteral */
  ASTBooleanLiteral jjtn000 = new ASTBooleanLiteral(this, JJTBOOLEANLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case TRUE:
        jj_consume_token(TRUE);
        break;
      case FALSE:
        jj_consume_token(FALSE);
        break;
      default:
        jj_la1[238] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
   {if (true) return jjtn000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTNullLiteral NullLiteral() throws ParseException {
 /*@bgen(jjtree) NullLiteral */
  ASTNullLiteral jjtn000 = new ASTNullLiteral(this, JJTNULLLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(NULL);
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
  {if (true) return jjtn000 ;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTMultiSetCondition MultiSetCondition() throws ParseException {
 /*@bgen(jjtree) MultiSetCondition */
  ASTMultiSetCondition jjtn000 = new ASTMultiSetCondition(this, JJTMULTISETCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case A:
        jj_consume_token(A);
        jj_consume_token(SET);
        break;
      case EMPTY:
        jj_consume_token(EMPTY);
        break;
      default:
        jj_la1[239] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
  {if (true) return jjtn000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/** Recognizes a numeric literal.
* This may look like token, but it isn't. Not atomic enough.
* E.g. "+1" would be valid literal, which make parsing of "i+1" impossible
* (here, we have tokens "i", "+" and "1")
*/
  final public ASTNumericLiteral NumericLiteral() throws ParseException {
 /*@bgen(jjtree) NumericLiteral */
 ASTNumericLiteral jjtn000 = new ASTNumericLiteral(this, JJTNUMERICLITERAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t = null ;
    try {
      //Essentially unchanged, as it previouly returned a Token 
                      t = jj_consume_token(UNSIGNED_NUMERIC_LITERAL);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
         jjtn000.setImage(t.image) ;
         {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/** This cannot be a token because these are valid labels '<< next_msg >>", '<<"OUTER LOOP">>'  
*/
  final public ASTLabel Label() throws ParseException {
 /*@bgen(jjtree) Label */
 ASTLabel jjtn000 = new ASTLabel(this, JJTLABEL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
    try {
      jj_consume_token(21);
      simpleNode = UnqualifiedID();
      jj_consume_token(22);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage( simpleNode.getImage() ) ;
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTName Name() throws ParseException {
 /*@bgen(jjtree) Name */
 ASTName jjtn000 = new ASTName(this, JJTNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
 StringBuffer sb = new StringBuffer();
    try {
      simpleNode = UnqualifiedID();
                                   sb.append(simpleNode.getImage()) ;
      label_58:
      while (true) {
        if (jj_2_49(2)) {
          ;
        } else {
          break label_58;
        }
        switch (jj_nt.kind) {
        case 3:
          jj_consume_token(3);
            sb.append(".") ;
          break;
        case 11:
          jj_consume_token(11);
                                       sb.append("%") ;
          break;
        default:
          jj_la1[240] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        //QualifiedID() 
            simpleNode = QualifiedID();
                                  sb.append(simpleNode.getImage()) ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
  jjtn000.setImage(sb.toString()) ;
  {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTQualifiedName QualifiedName() throws ParseException {
 /*@bgen(jjtree) QualifiedName */
 ASTQualifiedName jjtn000 = new ASTQualifiedName(this, JJTQUALIFIEDNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
 StringBuffer sb = new StringBuffer();
    try {
      simpleNode = UnqualifiedID();
                                        sb.append(simpleNode.getImage()) ;
      label_59:
      while (true) {
        switch (jj_nt.kind) {
        case 3:
          ;
          break;
        default:
          jj_la1[241] = jj_gen;
          break label_59;
        }
        jj_consume_token(3);
        simpleNode = QualifiedID();
                                              sb.append(".") ; sb.append(simpleNode.getImage()) ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
         jjtn000.setImage(sb.toString()) ;
         {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTArguments Arguments() throws ParseException {
 /*@bgen(jjtree) Arguments */
  ASTArguments jjtn000 = new ASTArguments(this, JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(5);
      switch (jj_nt.kind) {
      case 5:
      case 16:
      case 17:
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CASE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NEW_DOT:
      case NO:
      case NOT:
      case NULL:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case CC_IF:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case UNSIGNED_NUMERIC_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case QUOTED_LITERAL:
        ArgumentList();
        break;
      default:
        jj_la1[242] = jj_gen;
        ;
      }
      jj_consume_token(7);
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTArgumentList ArgumentList() throws ParseException {
 /*@bgen(jjtree) ArgumentList */
  ASTArgumentList jjtn000 = new ASTArgumentList(this, JJTARGUMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      Argument();
      label_60:
      while (true) {
        switch (jj_nt.kind) {
        case 6:
          ;
          break;
        default:
          jj_la1[243] = jj_gen;
          break label_60;
        }
        jj_consume_token(6);
        Argument();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTArgument Argument() throws ParseException {
 /*@bgen(jjtree) Argument */
 ASTArgument jjtn000 = new ASTArgument(this, JJTARGUMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
    try {
      if (jj_2_50(2)) {
        simpleNode = UnqualifiedID();
        switch (jj_nt.kind) {
        case 23:
          jj_consume_token(23);
          break;
        case AS:
          jj_consume_token(AS);
          break;
        default:
          jj_la1[244] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
      Expression();
      switch (jj_nt.kind) {
      case USING:
        jj_consume_token(USING);
        switch (jj_nt.kind) {
        case CHAR_CS:
          jj_consume_token(CHAR_CS);
          break;
        case NCHAR_CS:
          jj_consume_token(NCHAR_CS);
          break;
        default:
          jj_la1[245] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[246] = jj_gen;
        ;
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
 if (null != simpleNode) { jjtn000.setImage(simpleNode.getImage()) ; }
 {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

// ============================================================================
// D E C L A R A T I O N S
// ============================================================================
  final public ASTVariableOrConstantDeclaration VariableOrConstantDeclaration() throws ParseException {
 /*@bgen(jjtree) VariableOrConstantDeclaration */
  ASTVariableOrConstantDeclaration jjtn000 = new ASTVariableOrConstantDeclaration(this, JJTVARIABLEORCONSTANTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      VariableOrConstantDeclarator();
      jj_consume_token(4);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTDatatypeDeclaration DatatypeDeclaration() throws ParseException {
 /*@bgen(jjtree) DatatypeDeclaration */
 ASTDatatypeDeclaration jjtn000 = new ASTDatatypeDeclaration(this, JJTDATATYPEDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t ;
    try {
      t = jj_consume_token(IDENTIFIER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.setImage(t.image) ;  {if (true) return jjtn000 ;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTPragma Pragma() throws ParseException {
 /*@bgen(jjtree) Pragma */
  ASTPragma jjtn000 = new ASTPragma(this, JJTPRAGMA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(PRAGMA);
      switch (jj_nt.kind) {
      case SERIALLY_REUSABLE:
        jj_consume_token(SERIALLY_REUSABLE);
        break;
      case AUTONOMOUS_TRANSACTION:
        jj_consume_token(AUTONOMOUS_TRANSACTION);
        break;
      case TIMESTAMP:
        jj_consume_token(TIMESTAMP);
        jj_consume_token(5);
        StringLiteral();
        jj_consume_token(7);
        break;
      case RESTRICT_REFERENCES:
        jj_consume_token(RESTRICT_REFERENCES);
        jj_consume_token(5);
        ID();
        label_61:
        while (true) {
          jj_consume_token(6);
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            ID();
            break;
          case STRING_LITERAL:
            StringLiteral();
            break;
          default:
            jj_la1[247] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[248] = jj_gen;
            break label_61;
          }
        }
        jj_consume_token(7);
        break;
      case EXCEPTION_INIT:
        jj_consume_token(EXCEPTION_INIT);
        jj_consume_token(5);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(6);
        switch (jj_nt.kind) {
        case 16:
        case 17:
          switch (jj_nt.kind) {
          case 16:
            jj_consume_token(16);
            break;
          case 17:
            jj_consume_token(17);
            break;
          default:
            jj_la1[249] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[250] = jj_gen;
          ;
        }
        NumericLiteral();
        jj_consume_token(7);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
        jj_consume_token(5);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(6);
        ID();
        switch (jj_nt.kind) {
        case 6:
          jj_consume_token(6);
          NumericLiteral();
          break;
        default:
          jj_la1[251] = jj_gen;
          ;
        }
        jj_consume_token(7);
        break;
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ARRAY:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BODY:
      case BULK:
      case BYTE:
      case CASCADE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MONTH:
      case NATURAL:
      case NEW:
      case NO:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PRIVATE:
      case PROCEDURE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELF:
      case SET:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case TYPE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case QUOTED_LITERAL:
        QualifiedName();
        jj_consume_token(5);
        ReadPastNextOccurrence(")");
        break;
      default:
        jj_la1[252] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(4);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTExceptionDeclaration ExceptionDeclaration() throws ParseException {
 /*@bgen(jjtree) ExceptionDeclaration */
 ASTExceptionDeclaration jjtn000 = new ASTExceptionDeclaration(this, JJTEXCEPTIONDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
    try {
      simpleNode = ID();
      jj_consume_token(EXCEPTION);
      jj_consume_token(4);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTParallelClause ParallelClause() throws ParseException {
 /*@bgen(jjtree) ParallelClause */
  ASTParallelClause jjtn000 = new ASTParallelClause(this, JJTPARALLELCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(5);
      jj_consume_token(PARTITION);
      ID();
      jj_consume_token(BY);
      switch (jj_nt.kind) {
      case ANY:
        jj_consume_token(ANY);
        break;
      case HASH:
      case RANGE:
        switch (jj_nt.kind) {
        case HASH:
          jj_consume_token(HASH);
          break;
        case RANGE:
          jj_consume_token(RANGE);
          break;
        default:
          jj_la1[253] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(5);
        ID();
        label_62:
        while (true) {
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[254] = jj_gen;
            break label_62;
          }
          jj_consume_token(6);
          ID();
        }
        jj_consume_token(7);
        break;
      default:
        jj_la1[255] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(7);
      switch (jj_nt.kind) {
      case CLUSTER:
      case ORDER:
        switch (jj_nt.kind) {
        case ORDER:
          jj_consume_token(ORDER);
          break;
        case CLUSTER:
          jj_consume_token(CLUSTER);
          break;
        default:
          jj_la1[256] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(BY);
        jj_consume_token(5);
        ID();
        label_63:
        while (true) {
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[257] = jj_gen;
            break label_63;
          }
          jj_consume_token(6);
          ID();
        }
        jj_consume_token(7);
        break;
      default:
        jj_la1[258] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new Error("Missing return statement in function");
  }

// Copyright (C) 2002 Albert Tumanov

/**
 * 2006-05-10 - Matthias Hendler - merged SIV and sourceforge sources
 */

// SRT *
  final public ASTTable Table() throws ParseException {
 /*@bgen(jjtree) Table */
  ASTTable jjtn000 = new ASTTable(this, JJTTABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(CREATE);
      switch (jj_nt.kind) {
      case GLOBAL:
        jj_consume_token(GLOBAL);
        jj_consume_token(TEMPORARY);
        break;
      default:
        jj_la1[259] = jj_gen;
        ;
      }
      jj_consume_token(TABLE);
      ObjectNameDeclaration();
      jj_consume_token(5);
      TableColumn();
      label_64:
      while (true) {
        switch (jj_nt.kind) {
        case 6:
          ;
          break;
        default:
          jj_la1[260] = jj_gen;
          break label_64;
        }
        jj_consume_token(6);
        TableColumn();
      }
      jj_consume_token(7);
      if (jj_2_51(2)) {
        jj_consume_token(ON);
        jj_consume_token(COMMIT);
        switch (jj_nt.kind) {
        case DELETE:
          jj_consume_token(DELETE);
          break;
        case PRESERVE:
          jj_consume_token(PRESERVE);
          break;
        default:
          jj_la1[261] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(ROWS);
      } else {
        ;
      }
      switch (jj_nt.kind) {
      case 4:
        jj_consume_token(4);
        break;
      default:
        jj_la1[262] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTTableColumn TableColumn() throws ParseException {
 /*@bgen(jjtree) TableColumn */
  ASTTableColumn jjtn000 = new ASTTableColumn(this, JJTTABLECOLUMN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      ID();
      Datatype();
      switch (jj_nt.kind) {
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
        Expression();
        break;
      default:
        jj_la1[263] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case NOT:
      case NULL:
        switch (jj_nt.kind) {
        case NOT:
          jj_consume_token(NOT);
          break;
        default:
          jj_la1[264] = jj_gen;
          ;
        }
        jj_consume_token(NULL);
        break;
      default:
        jj_la1[265] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTView View() throws ParseException {
 /*@bgen(jjtree) View */
  ASTView jjtn000 = new ASTView(this, JJTVIEW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(CREATE);
      switch (jj_nt.kind) {
      case OR:
        jj_consume_token(OR);
        jj_consume_token(REPLACE);
        break;
      default:
        jj_la1[266] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case FORCE:
      case NO:
        switch (jj_nt.kind) {
        case NO:
          jj_consume_token(NO);
          break;
        default:
          jj_la1[267] = jj_gen;
          ;
        }
        jj_consume_token(FORCE);
        break;
      default:
        jj_la1[268] = jj_gen;
        ;
      }
      jj_consume_token(VIEW);
      ObjectNameDeclaration();
      switch (jj_nt.kind) {
      case 5:
        jj_consume_token(5);
        ViewColumn();
        label_65:
        while (true) {
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[269] = jj_gen;
            break label_65;
          }
          jj_consume_token(6);
          ViewColumn();
        }
        jj_consume_token(7);
        break;
      default:
        jj_la1[270] = jj_gen;
        ;
      }
      jj_consume_token(AS);
      Statement();
      switch (jj_nt.kind) {
      case 4:
        jj_consume_token(4);
        break;
      case 1:
        jj_consume_token(1);
        break;
      default:
        jj_la1[271] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTViewColumn ViewColumn() throws ParseException {
 /*@bgen(jjtree) ViewColumn */
  ASTViewColumn jjtn000 = new ASTViewColumn(this, JJTVIEWCOLUMN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      ID();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTComment Comment() throws ParseException {
 /*@bgen(jjtree) Comment */
  ASTComment jjtn000 = new ASTComment(this, JJTCOMMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(COMMENT);
      jj_consume_token(ON);
      switch (jj_nt.kind) {
      case INDEXTYPE:
      case OPERATOR:
      case TABLE:
        switch (jj_nt.kind) {
        case TABLE:
          jj_consume_token(TABLE);
          break;
        case OPERATOR:
          jj_consume_token(OPERATOR);
          break;
        case INDEXTYPE:
          jj_consume_token(INDEXTYPE);
          break;
        default:
          jj_la1[272] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        if (jj_2_52(2)) {
          ID();
          jj_consume_token(3);
        } else {
          ;
        }
        ID();
        break;
      case COLUMN:
        jj_consume_token(COLUMN);
        if (jj_2_53(2147483647)) {
          ID();
          jj_consume_token(3);
        } else {
          ;
        }
        ID();
        jj_consume_token(3);
        ID();
        break;
      default:
        jj_la1[273] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(IS);
      jj_consume_token(STRING_LITERAL);
      switch (jj_nt.kind) {
      case 4:
        jj_consume_token(4);
        break;
      default:
        jj_la1[274] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

// SRT * /
  final public ASTTypeMethod TypeMethod() throws ParseException {
 /*@bgen(jjtree) TypeMethod */
  ASTTypeMethod jjtn000 = new ASTTypeMethod(this, JJTTYPEMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
        getToken(1);
        //System.err.println("typeMethod: Result of getToken(1) is \"" + startToken.toString() + "\"" );

      label_66:
      while (true) {
        switch (jj_nt.kind) {
        case FINAL:
        case INSTANTIABLE:
        case NOT:
        case OVERRIDING:
          ;
          break;
        default:
          jj_la1[275] = jj_gen;
          break label_66;
        }
        switch (jj_nt.kind) {
        case NOT:
          jj_consume_token(NOT);
          break;
        default:
          jj_la1[276] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case OVERRIDING:
          jj_consume_token(OVERRIDING);
          break;
        case INSTANTIABLE:
          jj_consume_token(INSTANTIABLE);
          break;
        case FINAL:
          jj_consume_token(FINAL);
          break;
        default:
          jj_la1[277] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch (jj_nt.kind) {
      case MAP:
      case ORDER:
        switch (jj_nt.kind) {
        case MAP:
          jj_consume_token(MAP);
          break;
        case ORDER:
          jj_consume_token(ORDER);
          break;
        default:
          jj_la1[278] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[279] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case CONSTRUCTOR:
        jj_consume_token(CONSTRUCTOR);
        break;
      case MEMBER:
        jj_consume_token(MEMBER);
        break;
      case STATIC:
        jj_consume_token(STATIC);
        break;
      default:
        jj_la1[280] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      MethodDeclarator();
      switch (jj_nt.kind) {
      case DETERMINISTIC:
        jj_consume_token(DETERMINISTIC);
        break;
      default:
        jj_la1[281] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case PARALLEL_ENABLE:
        jj_consume_token(PARALLEL_ENABLE);
        break;
      default:
        jj_la1[282] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case PIPELINED:
        jj_consume_token(PIPELINED);
        break;
      default:
        jj_la1[283] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case RESULT_CACHE:
        jj_consume_token(RESULT_CACHE);
        break;
      default:
        jj_la1[284] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case AS:
      case IS:
        switch (jj_nt.kind) {
        case IS:
          jj_consume_token(IS);
          break;
        case AS:
          jj_consume_token(AS);
          break;
        default:
          jj_la1[285] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch (jj_nt.kind) {
        case LANGUAGE:
        case EXTERNAL:
          CallSpecTail();
          switch (jj_nt.kind) {
          case 4:
            jj_consume_token(4);
            break;
          default:
            jj_la1[286] = jj_gen;
            ;
          }
          break;
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case SERIALLY_REUSABLE:
        case RESTRICT_REFERENCES:
        case EXCEPTION_INIT:
        case AUTONOMOUS_TRANSACTION:
        case ADD:
        case AGGREGATE:
        case ALL:
        case ALTER:
        case AND:
        case ANY:
        case ARRAY:
        case AS:
        case ASC:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case AVG:
        case BEGIN:
        case BETWEEN:
        case BINARY_INTEGER:
        case BODY:
        case BOOLEAN:
        case BULK:
        case BY:
        case BYTE:
        case CASCADE:
        case CASE:
        case CHAR:
        case CHAR_BASE:
        case CHECK:
        case CLOSE:
        case CLUSTER:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case COMPRESS:
        case CONNECT:
        case CONSTANT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CREATE:
        case CURRENT:
        case CURRVAL:
        case CURSOR:
        case DATA:
        case DATE:
        case DAY:
        case DECLARE:
        case DECIMAL:
        case _DEFAULT:
        case DELETE:
        case DESC:
        case DISABLE:
        case DISTINCT:
        case DO:
        case DROP:
        case ELEMENT:
        case ELSE:
        case ELSIF:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTION:
        case EXCEPTIONS:
        case EXCLUSIVE:
        case EXECUTE:
        case EXISTS:
        case EXIT:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FLOAT:
        case FOR:
        case FORALL:
        case FORCE:
        case FROM:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case GROUP:
        case HASH:
        case HAVING:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case IN:
        case INDEX:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTEGER:
        case INTERFACE:
        case INTERSECT:
        case INTERVAL:
        case INTO:
        case INVALIDATE:
        case IS:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIKE:
        case LIMIT:
        case LIMITED:
        case LOCK:
        case LONG:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUS:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MODE:
        case MONTH:
        case NATURAL:
        case NATURALN:
        case NEW:
        case NEXTVAL:
        case NO:
        case NOCOPY:
        case NOT:
        case NOWAIT:
        case NULL:
        case NULLIF:
        case NUMBER:
        case BFILE_BASE:
        case BLOB_BASE:
        case CLOB_BASE:
        case DATE_BASE:
        case NUMBER_BASE:
        case OBJECT:
        case OCIROWID:
        case OF:
        case OID:
        case ON:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case OPTION:
        case OR:
        case ORDER:
        case ORGANIZATION:
        case OTHERS:
        case OUT:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PCTFREE:
        case PLS_INTEGER:
        case POSITIVE:
        case POSITIVEN:
        case PRAGMA:
        case PRESERVE:
        case PRIOR:
        case PROMPT:
        case PRIVATE:
        case PROCEDURE:
        case PUBLIC:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELEASE:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case ROWTYPE:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SEPARATE:
        case SET:
        case SHARE:
        case SMALLINT:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case START:
        case STATIC:
        case STDDEV:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SUM:
        case SYNONYM:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TABLE:
        case TEMPORARY:
        case THEN:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TO:
        case TRANSACTION:
        case TRIGGER:
        case TRUE:
        case TYPE:
        case UI:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case VARCHAR:
        case VARCHAR2:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case SIGNTYPE:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case QUOTED_LITERAL:
        case SQLDATA_CLASS:
        case CUSTOMDATUM_CLASS:
        case ORADATA_CLASS:
        case JAVA_INTERFACE_CLASS:
          DeclarativeSection();
          jj_consume_token(BEGIN);
          label_67:
          while (true) {
            switch (jj_nt.kind) {
            case 5:
            case 16:
            case 17:
            case 21:
            case REPLACE:
            case DEFINER:
            case CURRENT_USER:
            case LANGUAGE:
            case ADD:
            case AGGREGATE:
            case ARRAY:
            case AT:
            case ATTRIBUTE:
            case AUTHID:
            case BEGIN:
            case BODY:
            case BULK:
            case BYTE:
            case CASCADE:
            case CASE:
            case CLOSE:
            case COALESCE:
            case COLLECT:
            case COLUMN:
            case COMMENT:
            case COMMIT:
            case CONSTRUCTOR:
            case CONTINUE:
            case CONVERT:
            case CURRENT:
            case CURSOR:
            case DATA:
            case DAY:
            case DECLARE:
            case DELETE:
            case DISABLE:
            case ELEMENT:
            case ENABLE:
            case ESCAPE:
            case EXCEPT:
            case EXCEPTIONS:
            case EXECUTE:
            case EXIT:
            case EXTERNAL:
            case EXTENDS:
            case EXTRACT:
            case FALSE:
            case FETCH:
            case FINAL:
            case FOR:
            case FORALL:
            case FORCE:
            case FUNCTION:
            case GLOBAL:
            case GOTO:
            case HASH:
            case HEAP:
            case HOUR:
            case IF:
            case IMMEDIATE:
            case INDICES:
            case INDEXTYPE:
            case INDICATOR:
            case INSERT:
            case INSTANTIABLE:
            case INTERVAL:
            case INVALIDATE:
            case ISOLATION:
            case JAVA:
            case LEVEL:
            case LIMIT:
            case LOCK:
            case LOOP:
            case MAP:
            case MAX:
            case MEMBER:
            case MERGE:
            case MIN:
            case MINUTE:
            case MLSLABEL:
            case MODIFY:
            case MOD:
            case MONTH:
            case NATURAL:
            case NEW:
            case NEW_DOT:
            case NO:
            case NOT:
            case NULL:
            case OBJECT:
            case OID:
            case OPAQUE:
            case OPEN:
            case OPERATOR:
            case ORGANIZATION:
            case OTHERS:
            case OVERRIDING:
            case PACKAGE:
            case PARTITION:
            case PIPE:
            case PRESERVE:
            case PRIVATE:
            case PROCEDURE:
            case RAISE:
            case RANGE:
            case RAW:
            case REAL:
            case RECORD:
            case REF:
            case RELIES_ON:
            case RESULT:
            case RETURN:
            case REVERSE:
            case ROLLBACK:
            case ROW:
            case ROWS:
            case ROWID:
            case ROWNUM:
            case SAVE:
            case SAVEPOINT:
            case SECOND:
            case SELECT:
            case SELF:
            case SET:
            case SPACE:
            case SQL:
            case SQLCODE:
            case SQLERRM:
            case STATIC:
            case SUBTYPE:
            case SUBSTITUTABLE:
            case SUCCESSFUL:
            case SYSDATE:
            case SYS_REFCURSOR:
            case TEMPORARY:
            case TIME:
            case TIMESTAMP:
            case TIMEZONE_REGION:
            case TIMEZONE_ABBR:
            case TIMEZONE_MINUTE:
            case TIMEZONE_HOUR:
            case TRANSACTION:
            case TRUE:
            case TYPE:
            case UNDER:
            case USING:
            case WHILE:
            case YES:
            case SHOW:
            case A:
            case UPDATE:
            case DOUBLE:
            case DEC:
            case PRECISION:
            case INT:
            case NUMERIC:
            case NCHAR:
            case NVARCHAR2:
            case STRING:
            case UROWID:
            case VARRAY:
            case VARYING:
            case BFILE:
            case BLOB:
            case CLOB:
            case NCLOB:
            case YEAR:
            case LOCAL:
            case WITH:
            case ZONE:
            case CHARACTER:
            case AFTER:
            case BEFORE:
            case OLD:
            case PARENT:
            case CC_IF:
            case CC_ERROR:
            case ANALYZE:
            case ASSOCIATE:
            case AUDIT:
            case COMPOUND:
            case DATABASE:
            case CALL:
            case DDL:
            case DISASSOCIATE:
            case EACH:
            case FOLLOWS:
            case LOGOFF:
            case LOGON:
            case NESTED:
            case NOAUDIT:
            case SCHEMA:
            case SERVERERROR:
            case SHUTDOWN:
            case STARTUP:
            case STATEMENT:
            case STATISTICS:
            case SUSPEND:
            case TRUNCATE:
            case WRAPPED:
            case LIBRARY:
            case NAME:
            case STRUCT:
            case CONTEXT:
            case PARAMETERS:
            case LENGTH:
            case TDO:
            case MAXLEN:
            case CHARSETID:
            case CHARSETFORM:
            case ACCEPT:
            case COPY:
            case DISCONNECT:
            case HOST:
            case PRINT:
            case QUIT:
            case REMARK:
            case UNDEFINE:
            case VARIABLE:
            case WHENEVER:
            case ATTACH:
            case CAST:
            case TREAT:
            case TRIM:
            case LEFT:
            case RIGHT:
            case BOTH:
            case EMPTY:
            case MULTISET:
            case SUBMULTISET:
            case LEADING:
            case TRAILING:
            case CHAR_CS:
            case NCHAR_CS:
            case DBTIMEZONE:
            case SESSIONTIMEZONE:
            case IDENTIFIER:
            case UNSIGNED_NUMERIC_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case QUOTED_LITERAL:
              ;
              break;
            default:
              jj_la1[287] = jj_gen;
              break label_67;
            }
            Statement();
          }
          switch (jj_nt.kind) {
          case EXCEPTION:
            ExceptionHandler();
            break;
          default:
            jj_la1[288] = jj_gen;
            ;
          }
          jj_consume_token(END);
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            ID();
            break;
          default:
            jj_la1[289] = jj_gen;
            ;
          }
          jj_consume_token(4);
          break;
        default:
          jj_la1[290] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[291] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTTypeSpecification TypeSpecification() throws ParseException {
 /*@bgen(jjtree) TypeSpecification */
 ASTTypeSpecification jjtn000 = new ASTTypeSpecification(this, JJTTYPESPECIFICATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
    try {
      switch (jj_nt.kind) {
      case CREATE:
        jj_consume_token(CREATE);
        switch (jj_nt.kind) {
        case OR:
          jj_consume_token(OR);
          jj_consume_token(REPLACE);
          break;
        default:
          jj_la1[292] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[293] = jj_gen;
        ;
      }
      jj_consume_token(TYPE);
      simpleNode = ObjectNameDeclaration();
      if (jj_2_54(2)) {
        jj_consume_token(OID);
        jj_consume_token(STRING_LITERAL);
      } else {
        ;
      }
      if (jj_2_55(2)) {
        jj_consume_token(AUTHID);
        switch (jj_nt.kind) {
        case CURRENT_USER:
          jj_consume_token(CURRENT_USER);
          break;
        case DEFINER:
          jj_consume_token(DEFINER);
          break;
        default:
          jj_la1[294] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
      switch (jj_nt.kind) {
      case AS:
      case IS:
      case UNDER:
        switch (jj_nt.kind) {
        case UNDER:
          jj_consume_token(UNDER);
          ObjectNameDeclaration();
          break;
        default:
          jj_la1[301] = jj_gen;
          if (jj_2_56(2)) {
            switch (jj_nt.kind) {
            case IS:
              jj_consume_token(IS);
              break;
            case AS:
              jj_consume_token(AS);
              break;
            default:
              jj_la1[295] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(OBJECT);
          } else if (jj_2_57(2)) {
            switch (jj_nt.kind) {
            case IS:
              jj_consume_token(IS);
              break;
            case AS:
              jj_consume_token(AS);
              break;
            default:
              jj_la1[296] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(OPAQUE);
            jj_consume_token(VARYING);
            jj_consume_token(24);
            jj_consume_token(USING);
            jj_consume_token(LIBRARY);
            switch (jj_nt.kind) {
            case IDENTIFIER:
              jj_consume_token(IDENTIFIER);
              break;
            case QUOTED_LITERAL:
              jj_consume_token(QUOTED_LITERAL);
              break;
            case STRING_LITERAL:
              StringLiteral();
              break;
            default:
              jj_la1[297] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch (jj_nt.kind) {
            case 3:
              jj_consume_token(3);
              switch (jj_nt.kind) {
              case IDENTIFIER:
                jj_consume_token(IDENTIFIER);
                break;
              case QUOTED_LITERAL:
                jj_consume_token(QUOTED_LITERAL);
                break;
              case STRING_LITERAL:
                StringLiteral();
                break;
              default:
                jj_la1[298] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
            default:
              jj_la1[299] = jj_gen;
              ;
            }
          } else if (jj_2_58(2)) {
            switch (jj_nt.kind) {
            case IS:
              jj_consume_token(IS);
              break;
            case AS:
              jj_consume_token(AS);
              break;
            default:
              jj_la1[300] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            CollectionTypeName();
            jj_consume_token(OF);
            Datatype();
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[302] = jj_gen;
        ;
      }
      if (jj_2_59(8)) {
        jj_consume_token(EXTERNAL);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(LANGUAGE);
        jj_consume_token(JAVA);
        jj_consume_token(USING);
        jj_consume_token(IDENTIFIER);
      } else {
        ;
      }
      switch (jj_nt.kind) {
      case WRAPPED:
        WrappedObject();
        break;
      default:
        jj_la1[303] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case 5:
        jj_consume_token(5);
        label_68:
        while (true) {
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRAGMA:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            ;
            break;
          default:
            jj_la1[304] = jj_gen;
            break label_68;
          }
          if (jj_2_60(2)) {
            TypeMethod();
          } else {
            switch (jj_nt.kind) {
            case REPLACE:
            case DEFINER:
            case CURRENT_USER:
            case SERIALLY_REUSABLE:
            case RESTRICT_REFERENCES:
            case EXCEPTION_INIT:
            case AUTONOMOUS_TRANSACTION:
            case LANGUAGE:
            case ADD:
            case AGGREGATE:
            case ALL:
            case ALTER:
            case AND:
            case ANY:
            case ARRAY:
            case AS:
            case ASC:
            case AT:
            case ATTRIBUTE:
            case AUTHID:
            case AVG:
            case BETWEEN:
            case BINARY_INTEGER:
            case BODY:
            case BOOLEAN:
            case BULK:
            case BY:
            case BYTE:
            case CASCADE:
            case CASE:
            case CHAR:
            case CHAR_BASE:
            case CHECK:
            case CLOSE:
            case CLUSTER:
            case COALESCE:
            case COLLECT:
            case COLUMN:
            case COMMENT:
            case COMMIT:
            case COMPRESS:
            case CONNECT:
            case CONSTANT:
            case CONSTRUCTOR:
            case CONTINUE:
            case CONVERT:
            case CREATE:
            case CURRENT:
            case CURRVAL:
            case CURSOR:
            case DATA:
            case DATE:
            case DAY:
            case DECLARE:
            case DECIMAL:
            case _DEFAULT:
            case DELETE:
            case DESC:
            case DISABLE:
            case DISTINCT:
            case DO:
            case DROP:
            case ELEMENT:
            case ELSE:
            case ELSIF:
            case ENABLE:
            case ESCAPE:
            case EXCEPT:
            case EXCEPTION:
            case EXCEPTIONS:
            case EXCLUSIVE:
            case EXECUTE:
            case EXISTS:
            case EXIT:
            case EXTERNAL:
            case EXTENDS:
            case EXTRACT:
            case FALSE:
            case FETCH:
            case FINAL:
            case FLOAT:
            case FOR:
            case FORALL:
            case FORCE:
            case FROM:
            case FUNCTION:
            case GLOBAL:
            case GOTO:
            case GROUP:
            case HASH:
            case HAVING:
            case HEAP:
            case HOUR:
            case IF:
            case IMMEDIATE:
            case IN:
            case INDEX:
            case INDICES:
            case INDEXTYPE:
            case INDICATOR:
            case INSERT:
            case INSTANTIABLE:
            case INTEGER:
            case INTERFACE:
            case INTERSECT:
            case INTERVAL:
            case INTO:
            case INVALIDATE:
            case IS:
            case ISOLATION:
            case JAVA:
            case LEVEL:
            case LIKE:
            case LIMIT:
            case LIMITED:
            case LOCK:
            case LONG:
            case LOOP:
            case MAP:
            case MAX:
            case MEMBER:
            case MERGE:
            case MIN:
            case MINUS:
            case MINUTE:
            case MLSLABEL:
            case MODIFY:
            case MOD:
            case MODE:
            case MONTH:
            case NATURAL:
            case NATURALN:
            case NEW:
            case NEXTVAL:
            case NO:
            case NOCOPY:
            case NOT:
            case NOWAIT:
            case NULL:
            case NULLIF:
            case NUMBER:
            case BFILE_BASE:
            case BLOB_BASE:
            case CLOB_BASE:
            case DATE_BASE:
            case NUMBER_BASE:
            case OBJECT:
            case OCIROWID:
            case OF:
            case OID:
            case ON:
            case OPAQUE:
            case OPEN:
            case OPERATOR:
            case OPTION:
            case OR:
            case ORDER:
            case ORGANIZATION:
            case OTHERS:
            case OUT:
            case OVERRIDING:
            case PACKAGE:
            case PARTITION:
            case PCTFREE:
            case PLS_INTEGER:
            case POSITIVE:
            case POSITIVEN:
            case PRESERVE:
            case PRIOR:
            case PROMPT:
            case PRIVATE:
            case PROCEDURE:
            case PUBLIC:
            case RAISE:
            case RANGE:
            case RAW:
            case REAL:
            case RECORD:
            case REF:
            case RELEASE:
            case RELIES_ON:
            case RESULT:
            case RETURN:
            case REVERSE:
            case ROLLBACK:
            case ROW:
            case ROWS:
            case ROWID:
            case ROWNUM:
            case ROWTYPE:
            case SAVE:
            case SAVEPOINT:
            case SECOND:
            case SELECT:
            case SELF:
            case SEPARATE:
            case SET:
            case SHARE:
            case SMALLINT:
            case SPACE:
            case SQL:
            case SQLCODE:
            case SQLERRM:
            case START:
            case STATIC:
            case STDDEV:
            case SUBTYPE:
            case SUBSTITUTABLE:
            case SUCCESSFUL:
            case SUM:
            case SYNONYM:
            case SYSDATE:
            case SYS_REFCURSOR:
            case TABLE:
            case TEMPORARY:
            case THEN:
            case TIME:
            case TIMESTAMP:
            case TIMEZONE_REGION:
            case TIMEZONE_ABBR:
            case TIMEZONE_MINUTE:
            case TIMEZONE_HOUR:
            case TO:
            case TRANSACTION:
            case TRIGGER:
            case TRUE:
            case TYPE:
            case UI:
            case UNDER:
            case USING:
            case WHILE:
            case YES:
            case SHOW:
            case A:
            case UPDATE:
            case VARCHAR:
            case VARCHAR2:
            case DOUBLE:
            case DEC:
            case PRECISION:
            case INT:
            case NUMERIC:
            case SIGNTYPE:
            case NCHAR:
            case NVARCHAR2:
            case STRING:
            case UROWID:
            case VARRAY:
            case VARYING:
            case BFILE:
            case BLOB:
            case CLOB:
            case NCLOB:
            case YEAR:
            case LOCAL:
            case WITH:
            case ZONE:
            case CHARACTER:
            case AFTER:
            case BEFORE:
            case OLD:
            case PARENT:
            case ANALYZE:
            case ASSOCIATE:
            case AUDIT:
            case COMPOUND:
            case DATABASE:
            case CALL:
            case DDL:
            case DISASSOCIATE:
            case EACH:
            case FOLLOWS:
            case LOGOFF:
            case LOGON:
            case NESTED:
            case NOAUDIT:
            case SCHEMA:
            case SERVERERROR:
            case SHUTDOWN:
            case STARTUP:
            case STATEMENT:
            case STATISTICS:
            case SUSPEND:
            case TRUNCATE:
            case WRAPPED:
            case LIBRARY:
            case NAME:
            case STRUCT:
            case CONTEXT:
            case PARAMETERS:
            case LENGTH:
            case TDO:
            case MAXLEN:
            case CHARSETID:
            case CHARSETFORM:
            case ACCEPT:
            case COPY:
            case DISCONNECT:
            case HOST:
            case PRINT:
            case QUIT:
            case REMARK:
            case UNDEFINE:
            case VARIABLE:
            case WHENEVER:
            case ATTACH:
            case CAST:
            case TREAT:
            case TRIM:
            case LEFT:
            case RIGHT:
            case BOTH:
            case EMPTY:
            case MULTISET:
            case SUBMULTISET:
            case LEADING:
            case TRAILING:
            case CHAR_CS:
            case NCHAR_CS:
            case DBTIMEZONE:
            case SESSIONTIMEZONE:
            case IDENTIFIER:
            case QUOTED_LITERAL:
            case SQLDATA_CLASS:
            case CUSTOMDATUM_CLASS:
            case ORADATA_CLASS:
            case JAVA_INTERFACE_CLASS:
              AttributeDeclaration();
              break;
            case PRAGMA:
              PragmaClause();
              break;
            default:
              jj_la1[305] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        label_69:
        while (true) {
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[306] = jj_gen;
            break label_69;
          }
          jj_consume_token(6);
          switch (jj_nt.kind) {
          case CONSTRUCTOR:
          case FINAL:
          case INSTANTIABLE:
          case MAP:
          case MEMBER:
          case NOT:
          case ORDER:
          case OVERRIDING:
          case STATIC:
            TypeMethod();
            break;
          default:
            jj_la1[307] = jj_gen;
            if (jj_2_61(2)) {
              AttributeDeclaration();
            } else {
              switch (jj_nt.kind) {
              case PRAGMA:
                PragmaClause();
                break;
              default:
                jj_la1[308] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
        }
        jj_consume_token(7);
        break;
      default:
        jj_la1[309] = jj_gen;
        ;
      }
      label_70:
      while (true) {
        switch (jj_nt.kind) {
        case FINAL:
        case INSTANTIABLE:
        case NOT:
        case NULL:
          ;
          break;
        default:
          jj_la1[310] = jj_gen;
          break label_70;
        }
        switch (jj_nt.kind) {
        case NOT:
          jj_consume_token(NOT);
          break;
        default:
          jj_la1[311] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case FINAL:
          jj_consume_token(FINAL);
          break;
        case INSTANTIABLE:
          jj_consume_token(INSTANTIABLE);
          break;
        case NULL:
          jj_consume_token(NULL);
          break;
        default:
          jj_la1[312] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_71:
      while (true) {
        switch (jj_nt.kind) {
        case ALTER:
          ;
          break;
        default:
          jj_la1[313] = jj_gen;
          break label_71;
        }
        AlterTypeSpec();
      }
      switch (jj_nt.kind) {
      case 1:
      case 4:
        switch (jj_nt.kind) {
        case 4:
          jj_consume_token(4);
          break;
        case 1:
          jj_consume_token(1);
          break;
        default:
          jj_la1[314] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_72:
        while (true) {
          switch (jj_nt.kind) {
          case ALTER:
            ;
            break;
          default:
            jj_la1[315] = jj_gen;
            break label_72;
          }
          AlterTypeSpec();
          switch (jj_nt.kind) {
          case 1:
            jj_consume_token(1);
            break;
          case 4:
            jj_consume_token(4);
            break;
          default:
            jj_la1[316] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[317] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTAlterTypeSpec AlterTypeSpec() throws ParseException {
 /*@bgen(jjtree) AlterTypeSpec */
 ASTAlterTypeSpec jjtn000 = new ASTAlterTypeSpec(this, JJTALTERTYPESPEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
    try {
      jj_consume_token(ALTER);
      jj_consume_token(TYPE);
      simpleNode = QualifiedName();
      label_73:
      while (true) {
        switch (jj_nt.kind) {
        case 6:
        case ADD:
        case DROP:
        case MODIFY:
          ;
          break;
        default:
          jj_la1[318] = jj_gen;
          break label_73;
        }
        switch (jj_nt.kind) {
        case 6:
        case ADD:
        case MODIFY:
          switch (jj_nt.kind) {
          case 6:
            jj_consume_token(6);
            break;
          default:
            jj_la1[319] = jj_gen;
            ;
          }
          switch (jj_nt.kind) {
          case ADD:
            jj_consume_token(ADD);
            break;
          case MODIFY:
            jj_consume_token(MODIFY);
            break;
          default:
            jj_la1[320] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          label_74:
          while (true) {
            switch (jj_nt.kind) {
            case CONSTRUCTOR:
            case FINAL:
            case INSTANTIABLE:
            case MAP:
            case MEMBER:
            case NOT:
            case ORDER:
            case OVERRIDING:
            case STATIC:
              TypeMethod();
              break;
            case ATTRIBUTE:
              jj_consume_token(ATTRIBUTE);
              label_75:
              while (true) {
                switch (jj_nt.kind) {
                case 5:
                  ;
                  break;
                default:
                  jj_la1[321] = jj_gen;
                  break label_75;
                }
                jj_consume_token(5);
              }
              AttributeDeclaration();
              label_76:
              while (true) {
                switch (jj_nt.kind) {
                case 6:
                  ;
                  break;
                default:
                  jj_la1[322] = jj_gen;
                  break label_76;
                }
                jj_consume_token(6);
                AttributeDeclaration();
              }
              label_77:
              while (true) {
                switch (jj_nt.kind) {
                case 7:
                  ;
                  break;
                default:
                  jj_la1[323] = jj_gen;
                  break label_77;
                }
                jj_consume_token(7);
              }
              break;
            case LIMIT:
              jj_consume_token(LIMIT);
              NumericLiteral();
              break;
            case ELEMENT:
              jj_consume_token(ELEMENT);
              jj_consume_token(TYPE);
              Datatype();
              break;
            default:
              jj_la1[324] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch (jj_nt.kind) {
            case ATTRIBUTE:
            case CONSTRUCTOR:
            case ELEMENT:
            case FINAL:
            case INSTANTIABLE:
            case LIMIT:
            case MAP:
            case MEMBER:
            case NOT:
            case ORDER:
            case OVERRIDING:
            case STATIC:
              ;
              break;
            default:
              jj_la1[325] = jj_gen;
              break label_74;
            }
          }
          break;
        case DROP:
          jj_consume_token(DROP);
          label_78:
          while (true) {
            switch (jj_nt.kind) {
            case ATTRIBUTE:
              jj_consume_token(ATTRIBUTE);
              label_79:
              while (true) {
                switch (jj_nt.kind) {
                case 5:
                  ;
                  break;
                default:
                  jj_la1[326] = jj_gen;
                  break label_79;
                }
                jj_consume_token(5);
              }
              Attribute();
              label_80:
              while (true) {
                switch (jj_nt.kind) {
                case 6:
                  ;
                  break;
                default:
                  jj_la1[327] = jj_gen;
                  break label_80;
                }
                jj_consume_token(6);
                Attribute();
              }
              label_81:
              while (true) {
                switch (jj_nt.kind) {
                case 7:
                  ;
                  break;
                default:
                  jj_la1[328] = jj_gen;
                  break label_81;
                }
                jj_consume_token(7);
              }
              break;
            case CONSTRUCTOR:
            case FINAL:
            case INSTANTIABLE:
            case MAP:
            case MEMBER:
            case NOT:
            case ORDER:
            case OVERRIDING:
            case STATIC:
              TypeMethod();
              break;
            default:
              jj_la1[329] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch (jj_nt.kind) {
            case ATTRIBUTE:
            case CONSTRUCTOR:
            case FINAL:
            case INSTANTIABLE:
            case MAP:
            case MEMBER:
            case NOT:
            case ORDER:
            case OVERRIDING:
            case STATIC:
              ;
              break;
            default:
              jj_la1[330] = jj_gen;
              break label_78;
            }
          }
          break;
        default:
          jj_la1[331] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch (jj_nt.kind) {
      case REPLACE:
        jj_consume_token(REPLACE);
        if (jj_2_62(2)) {
          jj_consume_token(AUTHID);
          switch (jj_nt.kind) {
          case CURRENT_USER:
            jj_consume_token(CURRENT_USER);
            break;
          case DEFINER:
            jj_consume_token(DEFINER);
            break;
          default:
            jj_la1[332] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          ;
        }
        switch (jj_nt.kind) {
        case IS:
          jj_consume_token(IS);
          break;
        case AS:
          jj_consume_token(AS);
          break;
        default:
          jj_la1[333] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(OBJECT);
        jj_consume_token(5);
        if (jj_2_63(2)) {
          TypeMethod();
        } else {
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            AttributeDeclaration();
            break;
          default:
            jj_la1[334] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        label_82:
        while (true) {
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[335] = jj_gen;
            break label_82;
          }
          jj_consume_token(6);
          if (jj_2_64(2)) {
            TypeMethod();
          } else {
            switch (jj_nt.kind) {
            case REPLACE:
            case DEFINER:
            case CURRENT_USER:
            case SERIALLY_REUSABLE:
            case RESTRICT_REFERENCES:
            case EXCEPTION_INIT:
            case AUTONOMOUS_TRANSACTION:
            case LANGUAGE:
            case ADD:
            case AGGREGATE:
            case ALL:
            case ALTER:
            case AND:
            case ANY:
            case ARRAY:
            case AS:
            case ASC:
            case AT:
            case ATTRIBUTE:
            case AUTHID:
            case AVG:
            case BETWEEN:
            case BINARY_INTEGER:
            case BODY:
            case BOOLEAN:
            case BULK:
            case BY:
            case BYTE:
            case CASCADE:
            case CASE:
            case CHAR:
            case CHAR_BASE:
            case CHECK:
            case CLOSE:
            case CLUSTER:
            case COALESCE:
            case COLLECT:
            case COLUMN:
            case COMMENT:
            case COMMIT:
            case COMPRESS:
            case CONNECT:
            case CONSTANT:
            case CONSTRUCTOR:
            case CONTINUE:
            case CONVERT:
            case CREATE:
            case CURRENT:
            case CURRVAL:
            case CURSOR:
            case DATA:
            case DATE:
            case DAY:
            case DECLARE:
            case DECIMAL:
            case _DEFAULT:
            case DELETE:
            case DESC:
            case DISABLE:
            case DISTINCT:
            case DO:
            case DROP:
            case ELEMENT:
            case ELSE:
            case ELSIF:
            case ENABLE:
            case ESCAPE:
            case EXCEPT:
            case EXCEPTION:
            case EXCEPTIONS:
            case EXCLUSIVE:
            case EXECUTE:
            case EXISTS:
            case EXIT:
            case EXTERNAL:
            case EXTENDS:
            case EXTRACT:
            case FALSE:
            case FETCH:
            case FINAL:
            case FLOAT:
            case FOR:
            case FORALL:
            case FORCE:
            case FROM:
            case FUNCTION:
            case GLOBAL:
            case GOTO:
            case GROUP:
            case HASH:
            case HAVING:
            case HEAP:
            case HOUR:
            case IF:
            case IMMEDIATE:
            case IN:
            case INDEX:
            case INDICES:
            case INDEXTYPE:
            case INDICATOR:
            case INSERT:
            case INSTANTIABLE:
            case INTEGER:
            case INTERFACE:
            case INTERSECT:
            case INTERVAL:
            case INTO:
            case INVALIDATE:
            case IS:
            case ISOLATION:
            case JAVA:
            case LEVEL:
            case LIKE:
            case LIMIT:
            case LIMITED:
            case LOCK:
            case LONG:
            case LOOP:
            case MAP:
            case MAX:
            case MEMBER:
            case MERGE:
            case MIN:
            case MINUS:
            case MINUTE:
            case MLSLABEL:
            case MODIFY:
            case MOD:
            case MODE:
            case MONTH:
            case NATURAL:
            case NATURALN:
            case NEW:
            case NEXTVAL:
            case NO:
            case NOCOPY:
            case NOT:
            case NOWAIT:
            case NULL:
            case NULLIF:
            case NUMBER:
            case BFILE_BASE:
            case BLOB_BASE:
            case CLOB_BASE:
            case DATE_BASE:
            case NUMBER_BASE:
            case OBJECT:
            case OCIROWID:
            case OF:
            case OID:
            case ON:
            case OPAQUE:
            case OPEN:
            case OPERATOR:
            case OPTION:
            case OR:
            case ORDER:
            case ORGANIZATION:
            case OTHERS:
            case OUT:
            case OVERRIDING:
            case PACKAGE:
            case PARTITION:
            case PCTFREE:
            case PLS_INTEGER:
            case POSITIVE:
            case POSITIVEN:
            case PRESERVE:
            case PRIOR:
            case PROMPT:
            case PRIVATE:
            case PROCEDURE:
            case PUBLIC:
            case RAISE:
            case RANGE:
            case RAW:
            case REAL:
            case RECORD:
            case REF:
            case RELEASE:
            case RELIES_ON:
            case RESULT:
            case RETURN:
            case REVERSE:
            case ROLLBACK:
            case ROW:
            case ROWS:
            case ROWID:
            case ROWNUM:
            case ROWTYPE:
            case SAVE:
            case SAVEPOINT:
            case SECOND:
            case SELECT:
            case SELF:
            case SEPARATE:
            case SET:
            case SHARE:
            case SMALLINT:
            case SPACE:
            case SQL:
            case SQLCODE:
            case SQLERRM:
            case START:
            case STATIC:
            case STDDEV:
            case SUBTYPE:
            case SUBSTITUTABLE:
            case SUCCESSFUL:
            case SUM:
            case SYNONYM:
            case SYSDATE:
            case SYS_REFCURSOR:
            case TABLE:
            case TEMPORARY:
            case THEN:
            case TIME:
            case TIMESTAMP:
            case TIMEZONE_REGION:
            case TIMEZONE_ABBR:
            case TIMEZONE_MINUTE:
            case TIMEZONE_HOUR:
            case TO:
            case TRANSACTION:
            case TRIGGER:
            case TRUE:
            case TYPE:
            case UI:
            case UNDER:
            case USING:
            case WHILE:
            case YES:
            case SHOW:
            case A:
            case UPDATE:
            case VARCHAR:
            case VARCHAR2:
            case DOUBLE:
            case DEC:
            case PRECISION:
            case INT:
            case NUMERIC:
            case SIGNTYPE:
            case NCHAR:
            case NVARCHAR2:
            case STRING:
            case UROWID:
            case VARRAY:
            case VARYING:
            case BFILE:
            case BLOB:
            case CLOB:
            case NCLOB:
            case YEAR:
            case LOCAL:
            case WITH:
            case ZONE:
            case CHARACTER:
            case AFTER:
            case BEFORE:
            case OLD:
            case PARENT:
            case ANALYZE:
            case ASSOCIATE:
            case AUDIT:
            case COMPOUND:
            case DATABASE:
            case CALL:
            case DDL:
            case DISASSOCIATE:
            case EACH:
            case FOLLOWS:
            case LOGOFF:
            case LOGON:
            case NESTED:
            case NOAUDIT:
            case SCHEMA:
            case SERVERERROR:
            case SHUTDOWN:
            case STARTUP:
            case STATEMENT:
            case STATISTICS:
            case SUSPEND:
            case TRUNCATE:
            case WRAPPED:
            case LIBRARY:
            case NAME:
            case STRUCT:
            case CONTEXT:
            case PARAMETERS:
            case LENGTH:
            case TDO:
            case MAXLEN:
            case CHARSETID:
            case CHARSETFORM:
            case ACCEPT:
            case COPY:
            case DISCONNECT:
            case HOST:
            case PRINT:
            case QUIT:
            case REMARK:
            case UNDEFINE:
            case VARIABLE:
            case WHENEVER:
            case ATTACH:
            case CAST:
            case TREAT:
            case TRIM:
            case LEFT:
            case RIGHT:
            case BOTH:
            case EMPTY:
            case MULTISET:
            case SUBMULTISET:
            case LEADING:
            case TRAILING:
            case CHAR_CS:
            case NCHAR_CS:
            case DBTIMEZONE:
            case SESSIONTIMEZONE:
            case IDENTIFIER:
            case QUOTED_LITERAL:
            case SQLDATA_CLASS:
            case CUSTOMDATUM_CLASS:
            case ORADATA_CLASS:
            case JAVA_INTERFACE_CLASS:
              AttributeDeclaration();
              break;
            default:
              jj_la1[336] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        jj_consume_token(7);
        break;
      default:
        jj_la1[337] = jj_gen;
        ;
      }
      label_83:
      while (true) {
        switch (jj_nt.kind) {
        case FINAL:
        case INSTANTIABLE:
        case NOT:
        case NULL:
          ;
          break;
        default:
          jj_la1[338] = jj_gen;
          break label_83;
        }
        switch (jj_nt.kind) {
        case NOT:
          jj_consume_token(NOT);
          break;
        default:
          jj_la1[339] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case FINAL:
          jj_consume_token(FINAL);
          break;
        case INSTANTIABLE:
          jj_consume_token(INSTANTIABLE);
          break;
        case NULL:
          jj_consume_token(NULL);
          break;
        default:
          jj_la1[340] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch (jj_nt.kind) {
      case CASCADE:
      case INVALIDATE:
        switch (jj_nt.kind) {
        case INVALIDATE:
          jj_consume_token(INVALIDATE);
          break;
        case CASCADE:
          jj_consume_token(CASCADE);
          label_84:
          while (true) {
            switch (jj_nt.kind) {
            case CONVERT:
            case INCLUDING:
            case NOT:
              ;
              break;
            default:
              jj_la1[341] = jj_gen;
              break label_84;
            }
            switch (jj_nt.kind) {
            case INCLUDING:
            case NOT:
              switch (jj_nt.kind) {
              case NOT:
                jj_consume_token(NOT);
                break;
              default:
                jj_la1[342] = jj_gen;
                ;
              }
              jj_consume_token(INCLUDING);
              jj_consume_token(TABLE);
              jj_consume_token(DATA);
              break;
            case CONVERT:
              jj_consume_token(CONVERT);
              jj_consume_token(TO);
              jj_consume_token(SUBSTITUTABLE);
              break;
            default:
              jj_la1[343] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          switch (jj_nt.kind) {
          case EXCEPTIONS:
          case FORCE:
            switch (jj_nt.kind) {
            case FORCE:
              jj_consume_token(FORCE);
              break;
            default:
              jj_la1[344] = jj_gen;
              ;
            }
            jj_consume_token(EXCEPTIONS);
            jj_consume_token(INTO);
            QualifiedName();
            break;
          default:
            jj_la1[345] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[346] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[347] = jj_gen;
        ;
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/*
ASTTypeBody TypeBody()  :
{ Token name=null; }
{
	[<CREATE> [<OR> <REPLACE>]]

	<TYPE> <BODY> (LOOKAHEAD(2) ID()".")? name=ID()

	(
	  (
	    WrappedObject() 
	  )
	  |
	  (
	    (<IS> | <AS>)

		    DeclarativeSection() //SRT 20110524 Allow PLDOc in Type Bodies 

	    [ <BEGIN> (Statement())* (ExceptionHandler())? ] <END> [ID()] ";" 
	  )
	)
}
*/


/**
  * Method 
**/
  final public ASTAttributeDeclaration AttributeDeclaration() throws ParseException {
 /*@bgen(jjtree) AttributeDeclaration */
 ASTAttributeDeclaration jjtn000 = new ASTAttributeDeclaration(this, JJTATTRIBUTEDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
    try {
      simpleNode = ID();
      Datatype();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(simpleNode.getImage()) ;   {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTAttribute Attribute() throws ParseException {
 /*@bgen(jjtree) Attribute */
 ASTAttribute jjtn000 = new ASTAttribute(this, JJTATTRIBUTE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null;
    try {
      simpleNode = ID();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
        }
    }
    throw new Error("Missing return statement in function");
  }

/*
 This was quick cut from PRAGMA
*/
  final public ASTPragmaClause PragmaClause() throws ParseException {
 /*@bgen(jjtree) PragmaClause */
  ASTPragmaClause jjtn000 = new ASTPragmaClause(this, JJTPRAGMACLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(PRAGMA);
      switch (jj_nt.kind) {
      case SERIALLY_REUSABLE:
        jj_consume_token(SERIALLY_REUSABLE);
        break;
      case AUTONOMOUS_TRANSACTION:
        jj_consume_token(AUTONOMOUS_TRANSACTION);
        break;
      case RESTRICT_REFERENCES:
        jj_consume_token(RESTRICT_REFERENCES);
        jj_consume_token(5);
        ID();
        label_85:
        while (true) {
          jj_consume_token(6);
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            ID();
            break;
          case STRING_LITERAL:
            StringLiteral();
            break;
          default:
            jj_la1[348] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[349] = jj_gen;
            break label_85;
          }
        }
        jj_consume_token(7);
        break;
      case EXCEPTION_INIT:
        jj_consume_token(EXCEPTION_INIT);
        jj_consume_token(5);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(6);
        switch (jj_nt.kind) {
        case 16:
        case 17:
          switch (jj_nt.kind) {
          case 16:
            jj_consume_token(16);
            break;
          case 17:
            jj_consume_token(17);
            break;
          default:
            jj_la1[350] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[351] = jj_gen;
          ;
        }
        NumericLiteral();
        jj_consume_token(7);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
        jj_consume_token(5);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(6);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(6);
        NumericLiteral();
        jj_consume_token(7);
        break;
      default:
        jj_la1[352] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/** 
 * Trigger
 * Triggers are always outside of a package.
 *
 *  2006-05-17 - Matthias Hendler - added 
 */

/*
  11g Trigger Syntax 

 create_trigger : 
 CREATE [OR REPLACE] TRIGGER [schema.]trigger 
( simple_dml_trigger | compound_dml_trigger | non_dml_trigger )
[ FOLLOWS ( [schema.]trigger) ( , [schema.]trigger)*  ]
[ ENABLE  | DISABLE ]
( WHEN ( trigger_condition ) 
trigger_body


simple_dml_trigger :
(BEFORE |AFTER | INSTEAD OF)
dml_event_clause 
[ referencing_clause ]
[ FOR EACH ROW ]



compound_dml_trigger :
FOR dml_event_clause 
[ referencing_clause ]


non_dml_trigger :
(BEFORE> |<AFTER> ) 
(DDLEvent | database_event) ( OR (DDLEvent | database_event))*
ON
(DATABASE | [schema.]SCHEMA



trigger_body :
(plsql_block | compound_trigger_block | CALL routine_clause)



dml_event_clause:
( DELETE | INSERT | UPDATE [ OF column (, column ) ] )
ON ( (schema.table | NESTED TABLE nested_table_column OF [schema.]view )

referencing_clause:
REFERENCING 
(OLD AS old_alias | NEW AS new_alias | PARENT AS parent_alias )+ 


compound_trigger_block :
COMPOUND TRIGGER 
declare_section 
(timing_point_section)+  
END [trigger_name] ;

timing_point_section:
(
BEFORE STATEMENT IS tps_body END BEFORE STATEMENT 
|BEFORE EACH ROW IS tps_body END BEFORE EACH ROW 
|AFTER STATEMENT IS tps_body END AFTER STATEMENT 
|AFTER EACH ROW IS tps_body END AFTER EACH ROW 
)


tps_body:
(statement)+
(EXCEPTION exception_handler )*

*/
  final public ASTTriggerUnit TriggerUnit() throws ParseException {
 /*@bgen(jjtree) TriggerUnit */
 ASTTriggerUnit jjtn000 = new ASTTriggerUnit(this, JJTTRIGGERUNIT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));SimpleNode simpleNode = null ;
    try {
      switch (jj_nt.kind) {
      case CREATE:
        jj_consume_token(CREATE);
        switch (jj_nt.kind) {
        case OR:
          jj_consume_token(OR);
          jj_consume_token(REPLACE);
          break;
        default:
          jj_la1[353] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[354] = jj_gen;
        ;
      }
      jj_consume_token(TRIGGER);
      simpleNode = ObjectNameDeclaration();
      switch (jj_nt.kind) {
      case BEFORE:
        jj_consume_token(BEFORE);
        break;
      case AFTER:
        jj_consume_token(AFTER);
        break;
      case INSTEADOF:
        jj_consume_token(INSTEADOF);
        break;
      case FOR:
        jj_consume_token(FOR);
        break;
      default:
        jj_la1[355] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case DELETE:
      case INSERT:
      case UPDATE:
        switch (jj_nt.kind) {
        case DELETE:
          jj_consume_token(DELETE);
          break;
        case INSERT:
          jj_consume_token(INSERT);
          break;
        case UPDATE:
          jj_consume_token(UPDATE);
          break;
        default:
          jj_la1[356] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        if (jj_2_65(6)) {
          jj_consume_token(OF);
          ID();
          label_86:
          while (true) {
            switch (jj_nt.kind) {
            case 6:
              ;
              break;
            default:
              jj_la1[357] = jj_gen;
              break label_86;
            }
            jj_consume_token(6);
            ID();
          }
        } else {
          ;
        }
        break;
      case ALTER:
      case COMMENT:
      case CREATE:
      case DROP:
      case GRANT:
      case RENAME:
      case REVOKE:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case DDL:
      case DISASSOCIATE:
      case LOGOFF:
      case LOGON:
      case NOAUDIT:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case SUSPEND:
      case TRUNCATE:
        NonDMLEvent();
        break;
      default:
        jj_la1[358] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_87:
      while (true) {
        switch (jj_nt.kind) {
        case OR:
          ;
          break;
        default:
          jj_la1[359] = jj_gen;
          break label_87;
        }
        jj_consume_token(OR);
        switch (jj_nt.kind) {
        case DELETE:
        case INSERT:
        case UPDATE:
          switch (jj_nt.kind) {
          case DELETE:
            jj_consume_token(DELETE);
            break;
          case INSERT:
            jj_consume_token(INSERT);
            break;
          case UPDATE:
            jj_consume_token(UPDATE);
            break;
          default:
            jj_la1[360] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          if (jj_2_66(6)) {
            jj_consume_token(OF);
            ID();
            label_88:
            while (true) {
              switch (jj_nt.kind) {
              case 6:
                ;
                break;
              default:
                jj_la1[361] = jj_gen;
                break label_88;
              }
              jj_consume_token(6);
              ID();
            }
          } else {
            ;
          }
          break;
        case ALTER:
        case COMMENT:
        case CREATE:
        case DROP:
        case GRANT:
        case RENAME:
        case REVOKE:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case DDL:
        case DISASSOCIATE:
        case LOGOFF:
        case LOGON:
        case NOAUDIT:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case SUSPEND:
        case TRUNCATE:
          NonDMLEvent();
          break;
        default:
          jj_la1[362] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(ON);
      switch (jj_nt.kind) {
      case DATABASE:
        jj_consume_token(DATABASE);
        break;
      default:
        jj_la1[363] = jj_gen;
        if (jj_2_69(2)) {
          jj_consume_token(NESTED);
          jj_consume_token(TABLE);
          ID();
          jj_consume_token(OF);
          if (jj_2_67(2)) {
            ID();
            jj_consume_token(3);
          } else {
            ;
          }
          ID();
        } else {
          switch (jj_nt.kind) {
          case REPLACE:
          case DEFINER:
          case CURRENT_USER:
          case SERIALLY_REUSABLE:
          case RESTRICT_REFERENCES:
          case EXCEPTION_INIT:
          case AUTONOMOUS_TRANSACTION:
          case LANGUAGE:
          case ADD:
          case AGGREGATE:
          case ALL:
          case ALTER:
          case AND:
          case ANY:
          case ARRAY:
          case AS:
          case ASC:
          case AT:
          case ATTRIBUTE:
          case AUTHID:
          case AVG:
          case BETWEEN:
          case BINARY_INTEGER:
          case BODY:
          case BOOLEAN:
          case BULK:
          case BY:
          case BYTE:
          case CASCADE:
          case CASE:
          case CHAR:
          case CHAR_BASE:
          case CHECK:
          case CLOSE:
          case CLUSTER:
          case COALESCE:
          case COLLECT:
          case COLUMN:
          case COMMENT:
          case COMMIT:
          case COMPRESS:
          case CONNECT:
          case CONSTANT:
          case CONSTRUCTOR:
          case CONTINUE:
          case CONVERT:
          case CREATE:
          case CURRENT:
          case CURRVAL:
          case CURSOR:
          case DATA:
          case DATE:
          case DAY:
          case DECLARE:
          case DECIMAL:
          case _DEFAULT:
          case DELETE:
          case DESC:
          case DISABLE:
          case DISTINCT:
          case DO:
          case DROP:
          case ELEMENT:
          case ELSE:
          case ELSIF:
          case ENABLE:
          case ESCAPE:
          case EXCEPT:
          case EXCEPTION:
          case EXCEPTIONS:
          case EXCLUSIVE:
          case EXECUTE:
          case EXISTS:
          case EXIT:
          case EXTERNAL:
          case EXTENDS:
          case EXTRACT:
          case FALSE:
          case FETCH:
          case FINAL:
          case FLOAT:
          case FOR:
          case FORALL:
          case FORCE:
          case FROM:
          case FUNCTION:
          case GLOBAL:
          case GOTO:
          case GROUP:
          case HASH:
          case HAVING:
          case HEAP:
          case HOUR:
          case IF:
          case IMMEDIATE:
          case IN:
          case INDEX:
          case INDICES:
          case INDEXTYPE:
          case INDICATOR:
          case INSERT:
          case INSTANTIABLE:
          case INTEGER:
          case INTERFACE:
          case INTERSECT:
          case INTERVAL:
          case INTO:
          case INVALIDATE:
          case IS:
          case ISOLATION:
          case JAVA:
          case LEVEL:
          case LIKE:
          case LIMIT:
          case LIMITED:
          case LOCK:
          case LONG:
          case LOOP:
          case MAP:
          case MAX:
          case MEMBER:
          case MERGE:
          case MIN:
          case MINUS:
          case MINUTE:
          case MLSLABEL:
          case MODIFY:
          case MOD:
          case MODE:
          case MONTH:
          case NATURAL:
          case NATURALN:
          case NEW:
          case NEXTVAL:
          case NO:
          case NOCOPY:
          case NOT:
          case NOWAIT:
          case NULL:
          case NULLIF:
          case NUMBER:
          case BFILE_BASE:
          case BLOB_BASE:
          case CLOB_BASE:
          case DATE_BASE:
          case NUMBER_BASE:
          case OBJECT:
          case OCIROWID:
          case OF:
          case OID:
          case ON:
          case OPAQUE:
          case OPEN:
          case OPERATOR:
          case OPTION:
          case OR:
          case ORDER:
          case ORGANIZATION:
          case OTHERS:
          case OUT:
          case OVERRIDING:
          case PACKAGE:
          case PARTITION:
          case PCTFREE:
          case PLS_INTEGER:
          case POSITIVE:
          case POSITIVEN:
          case PRESERVE:
          case PRIOR:
          case PROMPT:
          case PRIVATE:
          case PROCEDURE:
          case PUBLIC:
          case RAISE:
          case RANGE:
          case RAW:
          case REAL:
          case RECORD:
          case REF:
          case RELEASE:
          case RELIES_ON:
          case RESULT:
          case RETURN:
          case REVERSE:
          case ROLLBACK:
          case ROW:
          case ROWS:
          case ROWID:
          case ROWNUM:
          case ROWTYPE:
          case SAVE:
          case SAVEPOINT:
          case SECOND:
          case SELECT:
          case SELF:
          case SEPARATE:
          case SET:
          case SHARE:
          case SMALLINT:
          case SPACE:
          case SQL:
          case SQLCODE:
          case SQLERRM:
          case START:
          case STATIC:
          case STDDEV:
          case SUBTYPE:
          case SUBSTITUTABLE:
          case SUCCESSFUL:
          case SUM:
          case SYNONYM:
          case SYSDATE:
          case SYS_REFCURSOR:
          case TABLE:
          case TEMPORARY:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMEZONE_REGION:
          case TIMEZONE_ABBR:
          case TIMEZONE_MINUTE:
          case TIMEZONE_HOUR:
          case TO:
          case TRANSACTION:
          case TRIGGER:
          case TRUE:
          case TYPE:
          case UI:
          case UNDER:
          case USING:
          case WHILE:
          case YES:
          case SHOW:
          case A:
          case UPDATE:
          case VARCHAR:
          case VARCHAR2:
          case DOUBLE:
          case DEC:
          case PRECISION:
          case INT:
          case NUMERIC:
          case SIGNTYPE:
          case NCHAR:
          case NVARCHAR2:
          case STRING:
          case UROWID:
          case VARRAY:
          case VARYING:
          case BFILE:
          case BLOB:
          case CLOB:
          case NCLOB:
          case YEAR:
          case LOCAL:
          case WITH:
          case ZONE:
          case CHARACTER:
          case AFTER:
          case BEFORE:
          case OLD:
          case PARENT:
          case ANALYZE:
          case ASSOCIATE:
          case AUDIT:
          case COMPOUND:
          case DATABASE:
          case CALL:
          case DDL:
          case DISASSOCIATE:
          case EACH:
          case FOLLOWS:
          case LOGOFF:
          case LOGON:
          case NESTED:
          case NOAUDIT:
          case SCHEMA:
          case SERVERERROR:
          case SHUTDOWN:
          case STARTUP:
          case STATEMENT:
          case STATISTICS:
          case SUSPEND:
          case TRUNCATE:
          case WRAPPED:
          case LIBRARY:
          case NAME:
          case STRUCT:
          case CONTEXT:
          case PARAMETERS:
          case LENGTH:
          case TDO:
          case MAXLEN:
          case CHARSETID:
          case CHARSETFORM:
          case ACCEPT:
          case COPY:
          case DISCONNECT:
          case HOST:
          case PRINT:
          case QUIT:
          case REMARK:
          case UNDEFINE:
          case VARIABLE:
          case WHENEVER:
          case ATTACH:
          case CAST:
          case TREAT:
          case TRIM:
          case LEFT:
          case RIGHT:
          case BOTH:
          case EMPTY:
          case MULTISET:
          case SUBMULTISET:
          case LEADING:
          case TRAILING:
          case CHAR_CS:
          case NCHAR_CS:
          case DBTIMEZONE:
          case SESSIONTIMEZONE:
          case IDENTIFIER:
          case QUOTED_LITERAL:
          case SQLDATA_CLASS:
          case CUSTOMDATUM_CLASS:
          case ORADATA_CLASS:
          case JAVA_INTERFACE_CLASS:
            if (jj_2_68(2)) {
              ID();
              jj_consume_token(3);
            } else {
              ;
            }
            ID();
            break;
          default:
            jj_la1[364] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      switch (jj_nt.kind) {
      case REFERENCING:
        jj_consume_token(REFERENCING);
        label_89:
        while (true) {
          switch (jj_nt.kind) {
          case OLD:
            jj_consume_token(OLD);
            break;
          case NEW:
            jj_consume_token(NEW);
            break;
          case PARENT:
            jj_consume_token(PARENT);
            break;
          default:
            jj_la1[365] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(AS);
          ID();
          switch (jj_nt.kind) {
          case NEW:
          case OLD:
          case PARENT:
            ;
            break;
          default:
            jj_la1[366] = jj_gen;
            break label_89;
          }
        }
        break;
      default:
        jj_la1[367] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case FOREACHROW:
        jj_consume_token(FOREACHROW);
        break;
      default:
        jj_la1[368] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case REVERSE:
      case FORWARD:
      case CROSSEDITION:
        switch (jj_nt.kind) {
        case REVERSE:
        case FORWARD:
          switch (jj_nt.kind) {
          case FORWARD:
            jj_consume_token(FORWARD);
            break;
          case REVERSE:
            jj_consume_token(REVERSE);
            break;
          default:
            jj_la1[369] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[370] = jj_gen;
          ;
        }
        jj_consume_token(CROSSEDITION);
        break;
      default:
        jj_la1[371] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case FOLLOWS:
      case PRECEDES:
        switch (jj_nt.kind) {
        case FOLLOWS:
          jj_consume_token(FOLLOWS);
          break;
        case PRECEDES:
          jj_consume_token(PRECEDES);
          break;
        default:
          jj_la1[372] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        if (jj_2_70(2)) {
          ID();
          jj_consume_token(3);
        } else {
          ;
        }
        ID();
        label_90:
        while (true) {
          switch (jj_nt.kind) {
          case 6:
            ;
            break;
          default:
            jj_la1[373] = jj_gen;
            break label_90;
          }
          jj_consume_token(6);
          if (jj_2_71(2)) {
            ID();
            jj_consume_token(3);
          } else {
            ;
          }
          ID();
        }
        break;
      default:
        jj_la1[374] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case DISABLE:
      case ENABLE:
        switch (jj_nt.kind) {
        case ENABLE:
          jj_consume_token(ENABLE);
          break;
        case DISABLE:
          jj_consume_token(DISABLE);
          break;
        default:
          jj_la1[375] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[376] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case WHEN:
        jj_consume_token(WHEN);
        jj_consume_token(5);
        ConditionalOrExpression();
        jj_consume_token(7);
        break;
      default:
        jj_la1[377] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case CALL:
        jj_consume_token(CALL);
        PrimaryExpression();
        jj_consume_token(4);
        break;
      case COMPOUND:
        CompoundTriggerBlock();
        break;
      case BEGIN:
      case DECLARE:
        Block();
        jj_consume_token(4);
        break;
      default:
        jj_la1[378] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.setImage(simpleNode.getImage()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTTriggerTimingPointSection TriggerTimingPointSection() throws ParseException {
 /*@bgen(jjtree) TriggerTimingPointSection */
 ASTTriggerTimingPointSection jjtn000 = new ASTTriggerTimingPointSection(this, JJTTRIGGERTIMINGPOINTSECTION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));StringBuffer sb = new StringBuffer();
    try {
      switch (jj_nt.kind) {
      case BEFORE:
        jj_consume_token(BEFORE);
        break;
      case AFTER:
        jj_consume_token(AFTER);
        break;
      case INSTEADOF:
        jj_consume_token(INSTEADOF);
        break;
      default:
        jj_la1[379] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                        sb.append(token.image) ;
      switch (jj_nt.kind) {
      case STATEMENT:
        jj_consume_token(STATEMENT);
        break;
      case EACH:
        jj_consume_token(EACH);
        jj_consume_token(ROW);
        break;
      default:
        jj_la1[380] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                     sb.append(" "); sb.append(token.image) ;
      jj_consume_token(IS);
      jj_consume_token(BEGIN);
      label_91:
      while (true) {
        Statement();
        switch (jj_nt.kind) {
        case 5:
        case 16:
        case 17:
        case 21:
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ARRAY:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case BEGIN:
        case BODY:
        case BULK:
        case BYTE:
        case CASCADE:
        case CASE:
        case CLOSE:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CURRENT:
        case CURSOR:
        case DATA:
        case DAY:
        case DECLARE:
        case DELETE:
        case DISABLE:
        case ELEMENT:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTIONS:
        case EXECUTE:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FOR:
        case FORALL:
        case FORCE:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case HASH:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTERVAL:
        case INVALIDATE:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIMIT:
        case LOCK:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MONTH:
        case NATURAL:
        case NEW:
        case NEW_DOT:
        case NO:
        case NOT:
        case NULL:
        case OBJECT:
        case OID:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case ORGANIZATION:
        case OTHERS:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PIPE:
        case PRESERVE:
        case PRIVATE:
        case PROCEDURE:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SET:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case STATIC:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TEMPORARY:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TRANSACTION:
        case TRUE:
        case TYPE:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case OLD:
        case PARENT:
        case CC_IF:
        case CC_ERROR:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case UNSIGNED_NUMERIC_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_LITERAL:
          ;
          break;
        default:
          jj_la1[381] = jj_gen;
          break label_91;
        }
      }
      jj_consume_token(END);
      switch (jj_nt.kind) {
      case BEFORE:
        jj_consume_token(BEFORE);
        break;
      case AFTER:
        jj_consume_token(AFTER);
        break;
      case INSTEADOF:
        jj_consume_token(INSTEADOF);
        break;
      default:
        jj_la1[382] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case STATEMENT:
        jj_consume_token(STATEMENT);
        break;
      case EACH:
        jj_consume_token(EACH);
        jj_consume_token(ROW);
        break;
      default:
        jj_la1[383] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(4);

   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
   jjtn000.setImage(sb.toString()) ;  {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTCompoundTriggerBlock CompoundTriggerBlock() throws ParseException {
 /*@bgen(jjtree) CompoundTriggerBlock */
  ASTCompoundTriggerBlock jjtn000 = new ASTCompoundTriggerBlock(this, JJTCOMPOUNDTRIGGERBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(COMPOUND);
      jj_consume_token(TRIGGER);
      label_92:
      while (true) {
        switch (jj_nt.kind) {
        case REPLACE:
        case DEFINER:
        case CURRENT_USER:
        case SERIALLY_REUSABLE:
        case RESTRICT_REFERENCES:
        case EXCEPTION_INIT:
        case AUTONOMOUS_TRANSACTION:
        case LANGUAGE:
        case ADD:
        case AGGREGATE:
        case ALL:
        case ALTER:
        case AND:
        case ANY:
        case ARRAY:
        case AS:
        case ASC:
        case AT:
        case ATTRIBUTE:
        case AUTHID:
        case AVG:
        case BETWEEN:
        case BINARY_INTEGER:
        case BODY:
        case BOOLEAN:
        case BULK:
        case BY:
        case BYTE:
        case CASCADE:
        case CASE:
        case CHAR:
        case CHAR_BASE:
        case CHECK:
        case CLOSE:
        case CLUSTER:
        case COALESCE:
        case COLLECT:
        case COLUMN:
        case COMMENT:
        case COMMIT:
        case COMPRESS:
        case CONNECT:
        case CONSTANT:
        case CONSTRUCTOR:
        case CONTINUE:
        case CONVERT:
        case CREATE:
        case CURRENT:
        case CURRVAL:
        case CURSOR:
        case DATA:
        case DATE:
        case DAY:
        case DECLARE:
        case DECIMAL:
        case _DEFAULT:
        case DELETE:
        case DESC:
        case DISABLE:
        case DISTINCT:
        case DO:
        case DROP:
        case ELEMENT:
        case ELSE:
        case ELSIF:
        case ENABLE:
        case ESCAPE:
        case EXCEPT:
        case EXCEPTION:
        case EXCEPTIONS:
        case EXCLUSIVE:
        case EXECUTE:
        case EXISTS:
        case EXIT:
        case EXTERNAL:
        case EXTENDS:
        case EXTRACT:
        case FALSE:
        case FETCH:
        case FINAL:
        case FLOAT:
        case FOR:
        case FORALL:
        case FORCE:
        case FROM:
        case FUNCTION:
        case GLOBAL:
        case GOTO:
        case GROUP:
        case HASH:
        case HAVING:
        case HEAP:
        case HOUR:
        case IF:
        case IMMEDIATE:
        case IN:
        case INDEX:
        case INDICES:
        case INDEXTYPE:
        case INDICATOR:
        case INSERT:
        case INSTANTIABLE:
        case INTEGER:
        case INTERFACE:
        case INTERSECT:
        case INTERVAL:
        case INTO:
        case INVALIDATE:
        case IS:
        case ISOLATION:
        case JAVA:
        case LEVEL:
        case LIKE:
        case LIMIT:
        case LIMITED:
        case LOCK:
        case LONG:
        case LOOP:
        case MAP:
        case MAX:
        case MEMBER:
        case MERGE:
        case MIN:
        case MINUS:
        case MINUTE:
        case MLSLABEL:
        case MODIFY:
        case MOD:
        case MODE:
        case MONTH:
        case NATURAL:
        case NATURALN:
        case NEW:
        case NEXTVAL:
        case NO:
        case NOCOPY:
        case NOT:
        case NOWAIT:
        case NULL:
        case NULLIF:
        case NUMBER:
        case BFILE_BASE:
        case BLOB_BASE:
        case CLOB_BASE:
        case DATE_BASE:
        case NUMBER_BASE:
        case OBJECT:
        case OCIROWID:
        case OF:
        case OID:
        case ON:
        case OPAQUE:
        case OPEN:
        case OPERATOR:
        case OPTION:
        case OR:
        case ORDER:
        case ORGANIZATION:
        case OTHERS:
        case OUT:
        case OVERRIDING:
        case PACKAGE:
        case PARTITION:
        case PCTFREE:
        case PLS_INTEGER:
        case POSITIVE:
        case POSITIVEN:
        case PRAGMA:
        case PRESERVE:
        case PRIOR:
        case PROMPT:
        case PRIVATE:
        case PROCEDURE:
        case PUBLIC:
        case RAISE:
        case RANGE:
        case RAW:
        case REAL:
        case RECORD:
        case REF:
        case RELEASE:
        case RELIES_ON:
        case RESULT:
        case RETURN:
        case REVERSE:
        case ROLLBACK:
        case ROW:
        case ROWS:
        case ROWID:
        case ROWNUM:
        case ROWTYPE:
        case SAVE:
        case SAVEPOINT:
        case SECOND:
        case SELECT:
        case SELF:
        case SEPARATE:
        case SET:
        case SHARE:
        case SMALLINT:
        case SPACE:
        case SQL:
        case SQLCODE:
        case SQLERRM:
        case START:
        case STATIC:
        case STDDEV:
        case SUBTYPE:
        case SUBSTITUTABLE:
        case SUCCESSFUL:
        case SUM:
        case SYNONYM:
        case SYSDATE:
        case SYS_REFCURSOR:
        case TABLE:
        case TEMPORARY:
        case THEN:
        case TIME:
        case TIMESTAMP:
        case TIMEZONE_REGION:
        case TIMEZONE_ABBR:
        case TIMEZONE_MINUTE:
        case TIMEZONE_HOUR:
        case TO:
        case TRANSACTION:
        case TRIGGER:
        case TRUE:
        case TYPE:
        case UI:
        case UNDER:
        case USING:
        case WHILE:
        case YES:
        case SHOW:
        case A:
        case UPDATE:
        case VARCHAR:
        case VARCHAR2:
        case DOUBLE:
        case DEC:
        case PRECISION:
        case INT:
        case NUMERIC:
        case SIGNTYPE:
        case NCHAR:
        case NVARCHAR2:
        case STRING:
        case UROWID:
        case VARRAY:
        case VARYING:
        case BFILE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case YEAR:
        case LOCAL:
        case WITH:
        case ZONE:
        case CHARACTER:
        case AFTER:
        case BEFORE:
        case INSTEADOF:
        case OLD:
        case PARENT:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case COMPOUND:
        case DATABASE:
        case CALL:
        case DDL:
        case DISASSOCIATE:
        case EACH:
        case FOLLOWS:
        case LOGOFF:
        case LOGON:
        case NESTED:
        case NOAUDIT:
        case SCHEMA:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case STATEMENT:
        case STATISTICS:
        case SUSPEND:
        case TRUNCATE:
        case WRAPPED:
        case LIBRARY:
        case NAME:
        case STRUCT:
        case CONTEXT:
        case PARAMETERS:
        case LENGTH:
        case TDO:
        case MAXLEN:
        case CHARSETID:
        case CHARSETFORM:
        case ACCEPT:
        case COPY:
        case DISCONNECT:
        case HOST:
        case PRINT:
        case QUIT:
        case REMARK:
        case UNDEFINE:
        case VARIABLE:
        case WHENEVER:
        case ATTACH:
        case CAST:
        case TREAT:
        case TRIM:
        case LEFT:
        case RIGHT:
        case BOTH:
        case EMPTY:
        case MULTISET:
        case SUBMULTISET:
        case LEADING:
        case TRAILING:
        case CHAR_CS:
        case NCHAR_CS:
        case DBTIMEZONE:
        case SESSIONTIMEZONE:
        case IDENTIFIER:
        case QUOTED_LITERAL:
        case SQLDATA_CLASS:
        case CUSTOMDATUM_CLASS:
        case ORADATA_CLASS:
        case JAVA_INTERFACE_CLASS:
          ;
          break;
        default:
          jj_la1[384] = jj_gen;
          break label_92;
        }
        switch (jj_nt.kind) {
        case AFTER:
        case BEFORE:
        case INSTEADOF:
          TriggerTimingPointSection();
          break;
        case PRAGMA:
          Pragma();
          break;
        default:
          jj_la1[385] = jj_gen;
          if (jj_2_72(2)) {
            ExceptionDeclaration();
          } else if (jj_2_73(2)) {
            SubTypeDefinition();
          } else if (jj_2_74(4)) {
            VariableOrConstantDeclaration();
          } else if (jj_2_75(2)) {
            CursorSpecification();
          } else {
            switch (jj_nt.kind) {
            case CURSOR:
              CursorBody();
              break;
            case IDENTIFIER:
              CollectionDeclaration();
              break;
            case CREATE:
            case FUNCTION:
            case PROCEDURE:
              ProgramUnit();
              break;
            default:
              jj_la1[386] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
      jj_consume_token(END);
      switch (jj_nt.kind) {
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case SERIALLY_REUSABLE:
      case RESTRICT_REFERENCES:
      case EXCEPTION_INIT:
      case AUTONOMOUS_TRANSACTION:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ALL:
      case ALTER:
      case AND:
      case ANY:
      case ARRAY:
      case AS:
      case ASC:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case AVG:
      case BETWEEN:
      case BINARY_INTEGER:
      case BODY:
      case BOOLEAN:
      case BULK:
      case BY:
      case BYTE:
      case CASCADE:
      case CASE:
      case CHAR:
      case CHAR_BASE:
      case CHECK:
      case CLOSE:
      case CLUSTER:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case COMPRESS:
      case CONNECT:
      case CONSTANT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CREATE:
      case CURRENT:
      case CURRVAL:
      case CURSOR:
      case DATA:
      case DATE:
      case DAY:
      case DECLARE:
      case DECIMAL:
      case _DEFAULT:
      case DELETE:
      case DESC:
      case DISABLE:
      case DISTINCT:
      case DO:
      case DROP:
      case ELEMENT:
      case ELSE:
      case ELSIF:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTION:
      case EXCEPTIONS:
      case EXCLUSIVE:
      case EXECUTE:
      case EXISTS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FETCH:
      case FINAL:
      case FLOAT:
      case FOR:
      case FORALL:
      case FORCE:
      case FROM:
      case FUNCTION:
      case GLOBAL:
      case GOTO:
      case GROUP:
      case HASH:
      case HAVING:
      case HEAP:
      case HOUR:
      case IF:
      case IMMEDIATE:
      case IN:
      case INDEX:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSERT:
      case INSTANTIABLE:
      case INTEGER:
      case INTERFACE:
      case INTERSECT:
      case INTERVAL:
      case INTO:
      case INVALIDATE:
      case IS:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIKE:
      case LIMIT:
      case LIMITED:
      case LOCK:
      case LONG:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUS:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MODE:
      case MONTH:
      case NATURAL:
      case NATURALN:
      case NEW:
      case NEXTVAL:
      case NO:
      case NOCOPY:
      case NOT:
      case NOWAIT:
      case NULL:
      case NULLIF:
      case NUMBER:
      case BFILE_BASE:
      case BLOB_BASE:
      case CLOB_BASE:
      case DATE_BASE:
      case NUMBER_BASE:
      case OBJECT:
      case OCIROWID:
      case OF:
      case OID:
      case ON:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case OPTION:
      case OR:
      case ORDER:
      case ORGANIZATION:
      case OTHERS:
      case OUT:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PCTFREE:
      case PLS_INTEGER:
      case POSITIVE:
      case POSITIVEN:
      case PRESERVE:
      case PRIOR:
      case PROMPT:
      case PRIVATE:
      case PROCEDURE:
      case PUBLIC:
      case RAISE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELEASE:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case ROWTYPE:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SEPARATE:
      case SET:
      case SHARE:
      case SMALLINT:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case START:
      case STATIC:
      case STDDEV:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SUM:
      case SYNONYM:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TABLE:
      case TEMPORARY:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TO:
      case TRANSACTION:
      case TRIGGER:
      case TRUE:
      case TYPE:
      case UI:
      case UNDER:
      case USING:
      case WHILE:
      case YES:
      case SHOW:
      case A:
      case UPDATE:
      case VARCHAR:
      case VARCHAR2:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case SIGNTYPE:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case QUOTED_LITERAL:
      case SQLDATA_CLASS:
      case CUSTOMDATUM_CLASS:
      case ORADATA_CLASS:
      case JAVA_INTERFACE_CLASS:
        ID();
        break;
      default:
        jj_la1[387] = jj_gen;
        ;
      }
      jj_consume_token(4);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/*
non_dml_trigger :
(BEFORE> |<AFTER> ) 
(DDLEvent | database_event) ( OR (DDLEvent | database_event))*
ON
(DATABASE | [schema.]SCHEMA
*/
  final public ASTNonDMLTrigger NonDMLTrigger() throws ParseException {
 /*@bgen(jjtree) NonDMLTrigger */
  ASTNonDMLTrigger jjtn000 = new ASTNonDMLTrigger(this, JJTNONDMLTRIGGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case BEFORE:
        jj_consume_token(BEFORE);
        break;
      case AFTER:
        jj_consume_token(AFTER);
        break;
      default:
        jj_la1[388] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case ALTER:
      case COMMENT:
      case CREATE:
      case DROP:
      case GRANT:
      case RENAME:
      case REVOKE:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case DDL:
      case DISASSOCIATE:
      case NOAUDIT:
      case TRUNCATE:
        DDLEvent();
        break;
      case LOGOFF:
      case LOGON:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case SUSPEND:
        DatabaseEvent();
        break;
      default:
        jj_la1[389] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_93:
      while (true) {
        switch (jj_nt.kind) {
        case OR:
          ;
          break;
        default:
          jj_la1[390] = jj_gen;
          break label_93;
        }
        jj_consume_token(OR);
        switch (jj_nt.kind) {
        case ALTER:
        case COMMENT:
        case CREATE:
        case DROP:
        case GRANT:
        case RENAME:
        case REVOKE:
        case ANALYZE:
        case ASSOCIATE:
        case AUDIT:
        case DDL:
        case DISASSOCIATE:
        case NOAUDIT:
        case TRUNCATE:
          DDLEvent();
          break;
        case LOGOFF:
        case LOGON:
        case SERVERERROR:
        case SHUTDOWN:
        case STARTUP:
        case SUSPEND:
          DatabaseEvent();
          break;
        default:
          jj_la1[391] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(ON);
      switch (jj_nt.kind) {
      case DATABASE:
        jj_consume_token(DATABASE);
        break;
      case REPLACE:
      case DEFINER:
      case CURRENT_USER:
      case SERIALLY_REUSABLE:
      case RESTRICT_REFERENCES:
      case EXCEPTION_INIT:
      case AUTONOMOUS_TRANSACTION:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case ALL:
      case ALTER:
      case AND:
      case ANY:
      case ARRAY:
      case AS:
      case ASC:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case AVG:
      case BETWEEN:
      case BINARY_INTEGER:
      case BODY:
      case BOOLEAN:
      case BULK:
      case BY:
      case BYTE:
      case CASCADE:
      case CASE:
      case CHAR:
      case CHAR_BASE:
      case CHECK:
      case CLOSE:
      case CLUSTER:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case COMPRESS:
      case CONNECT:
      case CONSTANT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CREATE:
      case CURRENT:
      case CURRVAL:
      case CURSOR:
      case DATA:
      case DATE:
      case DAY:
      case DECLARE:
      case DECIMAL:
      case _DEFAULT:
      case DELETE:
      case DESC:
      case DISABLE:
      case DISTINCT:
      case DO:
      case DROP:
      case ELEMENT:
      case ELSE:
      case ELSIF:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTION:
      case EXCEPTIONS:
      case EXCLUSIVE:
      case EXECUTE:
      case EXISTS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FETCH:
      case FINAL:
      case FLOAT:
      case FOR:
      case FORALL:
      case FORCE:
      case FROM:
      case FUNCTION:
      case GLOBAL:
      case GOTO:
      case GROUP:
      case HASH:
      case HAVING:
      case HEAP:
      case HOUR:
      case IF:
      case IMMEDIATE:
      case IN:
      case INDEX:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSERT:
      case INSTANTIABLE:
      case INTEGER:
      case INTERFACE:
      case INTERSECT:
      case INTERVAL:
      case INTO:
      case INVALIDATE:
      case IS:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIKE:
      case LIMIT:
      case LIMITED:
      case LOCK:
      case LONG:
      case LOOP:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUS:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MOD:
      case MODE:
      case MONTH:
      case NATURAL:
      case NATURALN:
      case NEW:
      case NEXTVAL:
      case NO:
      case NOCOPY:
      case NOT:
      case NOWAIT:
      case NULL:
      case NULLIF:
      case NUMBER:
      case BFILE_BASE:
      case BLOB_BASE:
      case CLOB_BASE:
      case DATE_BASE:
      case NUMBER_BASE:
      case OBJECT:
      case OCIROWID:
      case OF:
      case OID:
      case ON:
      case OPAQUE:
      case OPEN:
      case OPERATOR:
      case OPTION:
      case OR:
      case ORDER:
      case ORGANIZATION:
      case OTHERS:
      case OUT:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PCTFREE:
      case PLS_INTEGER:
      case POSITIVE:
      case POSITIVEN:
      case PRESERVE:
      case PRIOR:
      case PROMPT:
      case PRIVATE:
      case PROCEDURE:
      case PUBLIC:
      case RAISE:
      case RANGE:
      case RAW:
      case REAL:
      case RECORD:
      case REF:
      case RELEASE:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case ROWTYPE:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELECT:
      case SELF:
      case SEPARATE:
      case SET:
      case SHARE:
      case SMALLINT:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERRM:
      case START:
      case STATIC:
      case STDDEV:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SUM:
      case SYNONYM:
      case SYSDATE:
      case SYS_REFCURSOR:
      case TABLE:
      case TEMPORARY:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TO:
      case TRANSACTION:
      case TRIGGER:
      case TRUE:
      case TYPE:
      case UI:
      case UNDER:
      case USING:
      case WHILE:
      case YES:
      case SHOW:
      case A:
      case UPDATE:
      case VARCHAR:
      case VARCHAR2:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case INT:
      case NUMERIC:
      case SIGNTYPE:
      case NCHAR:
      case NVARCHAR2:
      case STRING:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case WITH:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
      case IDENTIFIER:
      case QUOTED_LITERAL:
      case SQLDATA_CLASS:
      case CUSTOMDATUM_CLASS:
      case ORADATA_CLASS:
      case JAVA_INTERFACE_CLASS:
        if (jj_2_76(2)) {
          ID();
          jj_consume_token(3);
        } else {
          ;
        }
        jj_consume_token(SCHEMA);
        break;
      default:
        jj_la1[392] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
        {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
     jjtn000.jjtSetLastToken(getToken(0));
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTDDLEvent DDLEvent() throws ParseException {
                         /*@bgen(jjtree) DDLEvent */
  ASTDDLEvent jjtn000 = new ASTDDLEvent(this, JJTDDLEVENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case ALTER:
        jj_consume_token(ALTER);
        break;
      case ANALYZE:
        jj_consume_token(ANALYZE);
        break;
      case ASSOCIATE:
        jj_consume_token(ASSOCIATE);
        jj_consume_token(STATISTICS);
        break;
      case AUDIT:
        jj_consume_token(AUDIT);
        break;
      case COMMENT:
        jj_consume_token(COMMENT);
        break;
      case CREATE:
        jj_consume_token(CREATE);
        break;
      case DISASSOCIATE:
        jj_consume_token(DISASSOCIATE);
        jj_consume_token(STATISTICS);
        break;
      case DROP:
        jj_consume_token(DROP);
        break;
      case GRANT:
        jj_consume_token(GRANT);
        break;
      case NOAUDIT:
        jj_consume_token(NOAUDIT);
        break;
      case RENAME:
        jj_consume_token(RENAME);
        break;
      case REVOKE:
        jj_consume_token(REVOKE);
        break;
      case TRUNCATE:
        jj_consume_token(TRUNCATE);
        break;
      case DDL:
        jj_consume_token(DDL);
        break;
      default:
        jj_la1[393] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTDatabaseEvent DatabaseEvent() throws ParseException {
                                   /*@bgen(jjtree) DatabaseEvent */
  ASTDatabaseEvent jjtn000 = new ASTDatabaseEvent(this, JJTDATABASEEVENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case STARTUP:
        jj_consume_token(STARTUP);
        break;
      case SHUTDOWN:
        jj_consume_token(SHUTDOWN);
        break;
      case LOGON:
        jj_consume_token(LOGON);
        break;
      case LOGOFF:
        jj_consume_token(LOGOFF);
        break;
      case SERVERERROR:
        jj_consume_token(SERVERERROR);
        break;
      case SUSPEND:
        jj_consume_token(SUSPEND);
        break;
      default:
        jj_la1[394] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTNonDMLEvent NonDMLEvent() throws ParseException {
                               /*@bgen(jjtree) NonDMLEvent */
  ASTNonDMLEvent jjtn000 = new ASTNonDMLEvent(this, JJTNONDMLEVENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case ALTER:
      case COMMENT:
      case CREATE:
      case DROP:
      case GRANT:
      case RENAME:
      case REVOKE:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case DDL:
      case DISASSOCIATE:
      case NOAUDIT:
      case TRUNCATE:
        DDLEvent();
        break;
      case LOGOFF:
      case LOGON:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case SUSPEND:
        DatabaseEvent();
        break;
      default:
        jj_la1[395] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/*
When DBMS_METADATA.GET_DDL returns a trigger, it can come in 2 DDL statements.
The first is the CREATE OR REPLACE TRIGER statement; the second is an ALTER TRIGGER statement,
enabling or disabling the trigger.

Unlike the ALTER TYPE, it does not seem to alter the structure of the object.
*/
  final public void AlterTrigger() throws ParseException {
 /*@bgen(jjtree) AlterTrigger */
  ASTAlterTrigger jjtn000 = new ASTAlterTrigger(this, JJTALTERTRIGGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(ALTER);
      jj_consume_token(TRIGGER);
      Skip2NextTerminator(null,";");
      jj_consume_token(4);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
                {if (true) return;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
  }

//SRT 2011-04-17 - START 
  final public ASTKEYWORD_RESERVED KEYWORD_RESERVED() throws ParseException {
                                          /*@bgen(jjtree) KEYWORD_RESERVED */
  ASTKEYWORD_RESERVED jjtn000 = new ASTKEYWORD_RESERVED(this, JJTKEYWORD_RESERVED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case ALL:
        jj_consume_token(ALL);
        break;
      case ALTER:
        jj_consume_token(ALTER);
        break;
      case AND:
        jj_consume_token(AND);
        break;
      case ANY:
        jj_consume_token(ANY);
        break;
      case AS:
        jj_consume_token(AS);
        break;
      case ASC:
        jj_consume_token(ASC);
        break;
      case BETWEEN:
        jj_consume_token(BETWEEN);
        break;
      case BY:
        jj_consume_token(BY);
        break;
      case CHAR:
        jj_consume_token(CHAR);
        break;
      case CHECK:
        jj_consume_token(CHECK);
        break;
      case CLUSTER:
        jj_consume_token(CLUSTER);
        break;
      case COMPRESS:
        jj_consume_token(COMPRESS);
        break;
      case CONNECT:
        jj_consume_token(CONNECT);
        break;
      case CREATE:
        jj_consume_token(CREATE);
        break;
      case DATE:
        jj_consume_token(DATE);
        break;
      case DECIMAL:
        jj_consume_token(DECIMAL);
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
        break;
      case DELETE:
        jj_consume_token(DELETE);
        break;
      case DESC:
        jj_consume_token(DESC);
        break;
      case DISTINCT:
        jj_consume_token(DISTINCT);
        break;
      case DROP:
        jj_consume_token(DROP);
        break;
      case ELSE:
        jj_consume_token(ELSE);
        break;
      case EXCLUSIVE:
        jj_consume_token(EXCLUSIVE);
        break;
      case EXISTS:
        jj_consume_token(EXISTS);
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
        break;
      case FOR:
        jj_consume_token(FOR);
        break;
      case FROM:
        jj_consume_token(FROM);
        break;
      case GRANT:
        jj_consume_token(GRANT);
        break;
      case GROUP:
        jj_consume_token(GROUP);
        break;
      case HAVING:
        jj_consume_token(HAVING);
        break;
      case IDENTIFIED:
        jj_consume_token(IDENTIFIED);
        break;
      case IN:
        jj_consume_token(IN);
        break;
      case INDEX:
        jj_consume_token(INDEX);
        break;
      case INSERT:
        jj_consume_token(INSERT);
        break;
      case INTEGER:
        jj_consume_token(INTEGER);
        break;
      case INTERSECT:
        jj_consume_token(INTERSECT);
        break;
      case INTO:
        jj_consume_token(INTO);
        break;
      case IS:
        jj_consume_token(IS);
        break;
      case LIKE:
        jj_consume_token(LIKE);
        break;
      case LOCK:
        jj_consume_token(LOCK);
        break;
      case LONG:
        jj_consume_token(LONG);
        break;
      case MINUS:
        jj_consume_token(MINUS);
        break;
      case MODE:
        jj_consume_token(MODE);
        break;
      case NOCOMPRESS:
        jj_consume_token(NOCOMPRESS);
        break;
      case NOT:
        jj_consume_token(NOT);
        break;
      case NOWAIT:
        jj_consume_token(NOWAIT);
        break;
      case NULL:
        jj_consume_token(NULL);
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      case OF:
        jj_consume_token(OF);
        break;
      case ON:
        jj_consume_token(ON);
        break;
      case OPTION:
        jj_consume_token(OPTION);
        break;
      case OR:
        jj_consume_token(OR);
        break;
      case ORDER:
        jj_consume_token(ORDER);
        break;
      case PCTFREE:
        jj_consume_token(PCTFREE);
        break;
      case PRIOR:
        jj_consume_token(PRIOR);
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        break;
      case RAW:
        jj_consume_token(RAW);
        break;
      case RENAME:
        jj_consume_token(RENAME);
        break;
      case RESOURCE:
        jj_consume_token(RESOURCE);
        break;
      case REVOKE:
        jj_consume_token(REVOKE);
        break;
      case SELECT:
        jj_consume_token(SELECT);
        break;
      case SET:
        jj_consume_token(SET);
        break;
      case SHARE:
        jj_consume_token(SHARE);
        break;
      case SIZE:
        jj_consume_token(SIZE);
        break;
      case SMALLINT:
        jj_consume_token(SMALLINT);
        break;
      case START:
        jj_consume_token(START);
        break;
      case SYNONYM:
        jj_consume_token(SYNONYM);
        break;
      case TABLE:
        jj_consume_token(TABLE);
        break;
      case THEN:
        jj_consume_token(THEN);
        break;
      case TO:
        jj_consume_token(TO);
        break;
      case TRIGGER:
        jj_consume_token(TRIGGER);
        break;
      case UNION:
        jj_consume_token(UNION);
        break;
      case UNIQUE:
        jj_consume_token(UNIQUE);
        break;
      case UPDATE:
        jj_consume_token(UPDATE);
        break;
      case VALUES:
        jj_consume_token(VALUES);
        break;
      case VARCHAR:
        jj_consume_token(VARCHAR);
        break;
      case VARCHAR2:
        jj_consume_token(VARCHAR2);
        break;
      case VIEW:
        jj_consume_token(VIEW);
        break;
      case WHERE:
        jj_consume_token(WHERE);
        break;
      case WITH:
        jj_consume_token(WITH);
        break;
      default:
        jj_la1[396] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtreeCloseNodeScope(jjtn000);
   jjtn000.jjtSetLastToken(getToken(0));
   jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTKEYWORD_UNRESERVED KEYWORD_UNRESERVED() throws ParseException {
                                              /*@bgen(jjtree) KEYWORD_UNRESERVED */
  ASTKEYWORD_UNRESERVED jjtn000 = new ASTKEYWORD_UNRESERVED(this, JJTKEYWORD_UNRESERVED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case FALSE:
        jj_consume_token(FALSE);
        break;
      case TRUE:
        jj_consume_token(TRUE);
        break;
      case A:
        jj_consume_token(A);
        break;
      case ACCEPT:
        jj_consume_token(ACCEPT);
        break;
      case ADD:
        jj_consume_token(ADD);
        break;
      case AFTER:
        jj_consume_token(AFTER);
        break;
      case AGGREGATE:
        jj_consume_token(AGGREGATE);
        break;
      case ANALYZE:
        jj_consume_token(ANALYZE);
        break;
      case ASSOCIATE:
        jj_consume_token(ASSOCIATE);
        break;
      case AT:
        jj_consume_token(AT);
        break;
      case ATTACH:
        jj_consume_token(ATTACH);
        break;
      case ATTRIBUTE:
        jj_consume_token(ATTRIBUTE);
        break;
      case AUDIT:
        jj_consume_token(AUDIT);
        break;
      case AUTHID:
        jj_consume_token(AUTHID);
        break;
      case BEFORE:
        jj_consume_token(BEFORE);
        break;
      case BFILE:
        jj_consume_token(BFILE);
        break;
      case BLOB:
        jj_consume_token(BLOB);
        break;
      case BOTH:
        jj_consume_token(BOTH);
        break;
      case BULK:
        jj_consume_token(BULK);
        break;
      case BYTE:
        jj_consume_token(BYTE);
        break;
      case CALL:
        jj_consume_token(CALL);
        break;
      case CASCADE:
        jj_consume_token(CASCADE);
        break;
      case CAST:
        jj_consume_token(CAST);
        break;
      case CHAR_CS:
        jj_consume_token(CHAR_CS);
        break;
      case CHARACTER:
        jj_consume_token(CHARACTER);
        break;
      case CHARSETFORM:
        jj_consume_token(CHARSETFORM);
        break;
      case CHARSETID:
        jj_consume_token(CHARSETID);
        break;
      case CLOB:
        jj_consume_token(CLOB);
        break;
      case CLOSE:
        jj_consume_token(CLOSE);
        break;
      case COALESCE:
        jj_consume_token(COALESCE);
        break;
      case COLLECT:
        jj_consume_token(COLLECT);
        break;
      case COLUMN:
        jj_consume_token(COLUMN);
        break;
      case COMMENT:
        jj_consume_token(COMMENT);
        break;
      case COMMIT:
        jj_consume_token(COMMIT);
        break;
      case COMPOUND:
        jj_consume_token(COMPOUND);
        break;
      case CONSTRUCTOR:
        jj_consume_token(CONSTRUCTOR);
        break;
      case CONTEXT:
        jj_consume_token(CONTEXT);
        break;
      case CONTINUE:
        jj_consume_token(CONTINUE);
        break;
      case CONVERT:
        jj_consume_token(CONVERT);
        break;
      case COPY:
        jj_consume_token(COPY);
        break;
      case CURRENT:
        jj_consume_token(CURRENT);
        break;
      case CURRENT_USER:
        jj_consume_token(CURRENT_USER);
        break;
      case CURSOR:
        jj_consume_token(CURSOR);
        break;
      case DATA:
        jj_consume_token(DATA);
        break;
      case DATABASE:
        jj_consume_token(DATABASE);
        break;
      case DAY:
        jj_consume_token(DAY);
        break;
      case DBTIMEZONE:
        jj_consume_token(DBTIMEZONE);
        break;
      case DDL:
        jj_consume_token(DDL);
        break;
      case DEC:
        jj_consume_token(DEC);
        break;
      case DEFINER:
        jj_consume_token(DEFINER);
        break;
      case DISABLE:
        jj_consume_token(DISABLE);
        break;
      case DISASSOCIATE:
        jj_consume_token(DISASSOCIATE);
        break;
      case DISCONNECT:
        jj_consume_token(DISCONNECT);
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
        break;
      case EACH:
        jj_consume_token(EACH);
        break;
      case ELEMENT:
        jj_consume_token(ELEMENT);
        break;
      case EMPTY:
        jj_consume_token(EMPTY);
        break;
      case ENABLE:
        jj_consume_token(ENABLE);
        break;
      case ESCAPE:
        jj_consume_token(ESCAPE);
        break;
      case EXCEPT:
        jj_consume_token(EXCEPT);
        break;
      case EXCEPTIONS:
        jj_consume_token(EXCEPTIONS);
        break;
      case EXIT:
        jj_consume_token(EXIT);
        break;
      case EXTENDS:
        jj_consume_token(EXTENDS);
        break;
      case EXTERNAL:
        jj_consume_token(EXTERNAL);
        break;
      case EXTRACT:
        jj_consume_token(EXTRACT);
        break;
      case FINAL:
        jj_consume_token(FINAL);
        break;
      case FOLLOWS:
        jj_consume_token(FOLLOWS);
        break;
      case FORCE:
        jj_consume_token(FORCE);
        break;
      case FUNCTION:
        jj_consume_token(FUNCTION);
        break;
      case GLOBAL:
        jj_consume_token(GLOBAL);
        break;
      case HASH:
        jj_consume_token(HASH);
        break;
      case HEAP:
        jj_consume_token(HEAP);
        break;
      case HOST:
        jj_consume_token(HOST);
        break;
      case HOUR:
        jj_consume_token(HOUR);
        break;
      case IMMEDIATE:
        jj_consume_token(IMMEDIATE);
        break;
      case INDEXTYPE:
        jj_consume_token(INDEXTYPE);
        break;
      case INDICATOR:
        jj_consume_token(INDICATOR);
        break;
      case INDICES:
        jj_consume_token(INDICES);
        break;
      case INSTANTIABLE:
        jj_consume_token(INSTANTIABLE);
        break;
      case INTERVAL:
        jj_consume_token(INTERVAL);
        break;
      case INVALIDATE:
        jj_consume_token(INVALIDATE);
        break;
      case ISOLATION:
        jj_consume_token(ISOLATION);
        break;
      case JAVA:
        jj_consume_token(JAVA);
        break;
      case LANGUAGE:
        jj_consume_token(LANGUAGE);
        break;
      case LEADING:
        jj_consume_token(LEADING);
        break;
      case LEFT:
        jj_consume_token(LEFT);
        break;
      case LENGTH:
        jj_consume_token(LENGTH);
        break;
      case LEVEL:
        jj_consume_token(LEVEL);
        break;
      case LIBRARY:
        jj_consume_token(LIBRARY);
        break;
      case LIMIT:
        jj_consume_token(LIMIT);
        break;
      case LOCAL:
        jj_consume_token(LOCAL);
        break;
      case LOGOFF:
        jj_consume_token(LOGOFF);
        break;
      case LOGON:
        jj_consume_token(LOGON);
        break;
      case MAP:
        jj_consume_token(MAP);
        break;
      case MAX:
        jj_consume_token(MAX);
        break;
      case MAXLEN:
        jj_consume_token(MAXLEN);
        break;
      case MEMBER:
        jj_consume_token(MEMBER);
        break;
      case MERGE:
        jj_consume_token(MERGE);
        break;
      case MIN:
        jj_consume_token(MIN);
        break;
      case MINUTE:
        jj_consume_token(MINUTE);
        break;
      case MLSLABEL:
        jj_consume_token(MLSLABEL);
        break;
      case MODIFY:
        jj_consume_token(MODIFY);
        break;
      case MONTH:
        jj_consume_token(MONTH);
        break;
      case MULTISET:
        jj_consume_token(MULTISET);
        break;
      case NAME:
        jj_consume_token(NAME);
        break;
      case NATURAL:
        jj_consume_token(NATURAL);
        break;
      case NCHAR:
        jj_consume_token(NCHAR);
        break;
      case NCHAR_CS:
        jj_consume_token(NCHAR_CS);
        break;
      case NCLOB:
        jj_consume_token(NCLOB);
        break;
      case NESTED:
        jj_consume_token(NESTED);
        break;
      case NEW:
        jj_consume_token(NEW);
        break;
      case NO:
        jj_consume_token(NO);
        break;
      case NOAUDIT:
        jj_consume_token(NOAUDIT);
        break;
      case NUMERIC:
        jj_consume_token(NUMERIC);
        break;
      case NVARCHAR2:
        jj_consume_token(NVARCHAR2);
        break;
      case OBJECT:
        jj_consume_token(OBJECT);
        break;
      case OID:
        jj_consume_token(OID);
        break;
      case OLD:
        jj_consume_token(OLD);
        break;
      case OPAQUE:
        jj_consume_token(OPAQUE);
        break;
      case OPEN:
        jj_consume_token(OPEN);
        break;
      case ORGANIZATION:
        jj_consume_token(ORGANIZATION);
        break;
      case OTHERS:
        jj_consume_token(OTHERS);
        break;
      case OVERRIDING:
        jj_consume_token(OVERRIDING);
        break;
      case PACKAGE:
        jj_consume_token(PACKAGE);
        break;
      case PARAMETERS:
        jj_consume_token(PARAMETERS);
        break;
      case PARENT:
        jj_consume_token(PARENT);
        break;
      case PARTITION:
        jj_consume_token(PARTITION);
        break;
      case PRECISION:
        jj_consume_token(PRECISION);
        break;
      case PRESERVE:
        jj_consume_token(PRESERVE);
        break;
      case PRINT:
        jj_consume_token(PRINT);
        break;
      case PROCEDURE:
        jj_consume_token(PROCEDURE);
        break;
      case QUIT:
        jj_consume_token(QUIT);
        break;
      case RANGE:
        jj_consume_token(RANGE);
        break;
      case REAL:
        jj_consume_token(REAL);
        break;
      case RECORD:
        jj_consume_token(RECORD);
        break;
      case REF:
        jj_consume_token(REF);
        break;
      case RELIES_ON:
        jj_consume_token(RELIES_ON);
        break;
      case REMARK:
        jj_consume_token(REMARK);
        break;
      case RESULT:
        jj_consume_token(RESULT);
        break;
      case RETURN:
        jj_consume_token(RETURN);
        break;
      case REVERSE:
        jj_consume_token(REVERSE);
        break;
      case RIGHT:
        jj_consume_token(RIGHT);
        break;
      case ROLLBACK:
        jj_consume_token(ROLLBACK);
        break;
      case ROW:
        jj_consume_token(ROW);
        break;
      case ROWID:
        jj_consume_token(ROWID);
        break;
      case ROWNUM:
        jj_consume_token(ROWNUM);
        break;
      case ROWS:
        jj_consume_token(ROWS);
        break;
      case SAVE:
        jj_consume_token(SAVE);
        break;
      case SAVEPOINT:
        jj_consume_token(SAVEPOINT);
        break;
      case SCHEMA:
        jj_consume_token(SCHEMA);
        break;
      case SECOND:
        jj_consume_token(SECOND);
        break;
      case SELF:
        jj_consume_token(SELF);
        break;
      case SERVERERROR:
        jj_consume_token(SERVERERROR);
        break;
      case SESSIONTIMEZONE:
        jj_consume_token(SESSIONTIMEZONE);
        break;
      case SET:
        jj_consume_token(SET);
        break;
      case SHUTDOWN:
        jj_consume_token(SHUTDOWN);
        break;
      case SPACE:
        jj_consume_token(SPACE);
        break;
      case STARTUP:
        jj_consume_token(STARTUP);
        break;
      case STATEMENT:
        jj_consume_token(STATEMENT);
        break;
      case STATIC:
        jj_consume_token(STATIC);
        break;
      case STATISTICS:
        jj_consume_token(STATISTICS);
        break;
      case STRUCT:
        jj_consume_token(STRUCT);
        break;
      case SUBMULTISET:
        jj_consume_token(SUBMULTISET);
        break;
      case SUBSTITUTABLE:
        jj_consume_token(SUBSTITUTABLE);
        break;
      case SUBTYPE:
        jj_consume_token(SUBTYPE);
        break;
      case SUCCESSFUL:
        jj_consume_token(SUCCESSFUL);
        break;
      case SUSPEND:
        jj_consume_token(SUSPEND);
        break;
      case TDO:
        jj_consume_token(TDO);
        break;
      case TEMPORARY:
        jj_consume_token(TEMPORARY);
        break;
      case TIME:
        jj_consume_token(TIME);
        break;
      case TIMESTAMP:
        jj_consume_token(TIMESTAMP);
        break;
      case TIMEZONE_ABBR:
        jj_consume_token(TIMEZONE_ABBR);
        break;
      case TIMEZONE_HOUR:
        jj_consume_token(TIMEZONE_HOUR);
        break;
      case TIMEZONE_MINUTE:
        jj_consume_token(TIMEZONE_MINUTE);
        break;
      case TIMEZONE_REGION:
        jj_consume_token(TIMEZONE_REGION);
        break;
      case TRAILING:
        jj_consume_token(TRAILING);
        break;
      case TRANSACTION:
        jj_consume_token(TRANSACTION);
        break;
      case TREAT:
        jj_consume_token(TREAT);
        break;
      case TRIM:
        jj_consume_token(TRIM);
        break;
      case TRUNCATE:
        jj_consume_token(TRUNCATE);
        break;
      case UNDEFINE:
        jj_consume_token(UNDEFINE);
        break;
      case UNDER:
        jj_consume_token(UNDER);
        break;
      case UROWID:
        jj_consume_token(UROWID);
        break;
      case USING:
        jj_consume_token(USING);
        break;
      case VARRAY:
        jj_consume_token(VARRAY);
        break;
      case VARIABLE:
        jj_consume_token(VARIABLE);
        break;
      case VARYING:
        jj_consume_token(VARYING);
        break;
      case WHENEVER:
        jj_consume_token(WHENEVER);
        break;
      case YEAR:
        jj_consume_token(YEAR);
        break;
      case YES:
        jj_consume_token(YES);
        break;
      case ZONE:
        jj_consume_token(ZONE);
        break;
      case SHOW:
        jj_consume_token(SHOW);
        break;
      case WRAPPED:
        jj_consume_token(WRAPPED);
        break;
      case SYS_REFCURSOR:
        jj_consume_token(SYS_REFCURSOR);
        break;
      default:
        jj_la1[397] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
  jjtreeCloseNodeScope(jjtn000);
  jjtn000.jjtSetLastToken(getToken(0));
  jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
  }
    }
    throw new Error("Missing return statement in function");
  }

//SRT 2011-04-17 - END  */
/**
 * 2006-05-20 - Matthias Hendler - added <OLD> and <PARENT>  
 */
  final public ASTID ID() throws ParseException {
             /*@bgen(jjtree) ID */
  ASTID jjtn000 = new ASTID(this, JJTID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case QUOTED_LITERAL:
        jj_consume_token(QUOTED_LITERAL);
        break;
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BULK:
      case BYTE:
      case CASCADE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MONTH:
      case NATURAL:
      case NEW:
      case NO:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PROCEDURE:
      case RANGE:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELF:
      case SET:
      case SPACE:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
        KEYWORD_UNRESERVED();
        break;
      case REPLACE:
        jj_consume_token(REPLACE);
        break;
      case SERIALLY_REUSABLE:
        jj_consume_token(SERIALLY_REUSABLE);
        break;
      case RESTRICT_REFERENCES:
        jj_consume_token(RESTRICT_REFERENCES);
        break;
      case EXCEPTION_INIT:
        jj_consume_token(EXCEPTION_INIT);
        break;
      case AUTONOMOUS_TRANSACTION:
        jj_consume_token(AUTONOMOUS_TRANSACTION);
        break;
      case ALL:
        jj_consume_token(ALL);
        break;
      case ALTER:
        jj_consume_token(ALTER);
        break;
      case AND:
        jj_consume_token(AND);
        break;
      case ANY:
        jj_consume_token(ANY);
        break;
      case ARRAY:
        jj_consume_token(ARRAY);
        break;
      case AS:
        jj_consume_token(AS);
        break;
      case ASC:
        jj_consume_token(ASC);
        break;
      case AVG:
        jj_consume_token(AVG);
        break;
      case BETWEEN:
        jj_consume_token(BETWEEN);
        break;
      case BINARY_INTEGER:
        jj_consume_token(BINARY_INTEGER);
        break;
      case BODY:
        jj_consume_token(BODY);
        break;
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
        break;
      case BY:
        jj_consume_token(BY);
        break;
      case CASE:
        jj_consume_token(CASE);
        break;
      case CHAR:
        jj_consume_token(CHAR);
        break;
      case CHAR_BASE:
        jj_consume_token(CHAR_BASE);
        break;
      case CHECK:
        jj_consume_token(CHECK);
        break;
      case CLUSTER:
        jj_consume_token(CLUSTER);
        break;
      case COMPRESS:
        jj_consume_token(COMPRESS);
        break;
      case CONNECT:
        jj_consume_token(CONNECT);
        break;
      case CONSTANT:
        jj_consume_token(CONSTANT);
        break;
      case CREATE:
        jj_consume_token(CREATE);
        break;
      case CURRVAL:
        jj_consume_token(CURRVAL);
        break;
      case DATE:
        jj_consume_token(DATE);
        break;
      case DECLARE:
        jj_consume_token(DECLARE);
        break;
      case DECIMAL:
        jj_consume_token(DECIMAL);
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
        break;
      case DELETE:
        jj_consume_token(DELETE);
        break;
      case DESC:
        jj_consume_token(DESC);
        break;
      case DISTINCT:
        jj_consume_token(DISTINCT);
        break;
      case DO:
        jj_consume_token(DO);
        break;
      case DROP:
        jj_consume_token(DROP);
        break;
      case ELSE:
        jj_consume_token(ELSE);
        break;
      case ELSIF:
        jj_consume_token(ELSIF);
        break;
      case EXCEPTION:
        jj_consume_token(EXCEPTION);
        break;
      case EXCLUSIVE:
        jj_consume_token(EXCLUSIVE);
        break;
      case EXECUTE:
        jj_consume_token(EXECUTE);
        break;
      case EXISTS:
        jj_consume_token(EXISTS);
        break;
      case FETCH:
        jj_consume_token(FETCH);
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
        break;
      case FOR:
        jj_consume_token(FOR);
        break;
      case FORALL:
        jj_consume_token(FORALL);
        break;
      case FROM:
        jj_consume_token(FROM);
        break;
      case GOTO:
        jj_consume_token(GOTO);
        break;
      case GROUP:
        jj_consume_token(GROUP);
        break;
      case HAVING:
        jj_consume_token(HAVING);
        break;
      case IF:
        jj_consume_token(IF);
        break;
      case IN:
        jj_consume_token(IN);
        break;
      case INDEX:
        jj_consume_token(INDEX);
        break;
      case INSERT:
        jj_consume_token(INSERT);
        break;
      case INTEGER:
        jj_consume_token(INTEGER);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
        break;
      case INTERSECT:
        jj_consume_token(INTERSECT);
        break;
      case INTO:
        jj_consume_token(INTO);
        break;
      case IS:
        jj_consume_token(IS);
        break;
      case LIKE:
        jj_consume_token(LIKE);
        break;
      case LIMITED:
        jj_consume_token(LIMITED);
        break;
      case LOCK:
        jj_consume_token(LOCK);
        break;
      case LONG:
        jj_consume_token(LONG);
        break;
      case LOOP:
        jj_consume_token(LOOP);
        break;
      case MINUS:
        jj_consume_token(MINUS);
        break;
      case MOD:
        jj_consume_token(MOD);
        break;
      case MODE:
        jj_consume_token(MODE);
        break;
      case NATURALN:
        jj_consume_token(NATURALN);
        break;
      case NEXTVAL:
        jj_consume_token(NEXTVAL);
        break;
      case NOCOPY:
        jj_consume_token(NOCOPY);
        break;
      case NOT:
        jj_consume_token(NOT);
        break;
      case NOWAIT:
        jj_consume_token(NOWAIT);
        break;
      case NULL:
        jj_consume_token(NULL);
        break;
      case NULLIF:
        jj_consume_token(NULLIF);
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      case NUMBER_BASE:
        jj_consume_token(NUMBER_BASE);
        break;
      case OCIROWID:
        jj_consume_token(OCIROWID);
        break;
      case OF:
        jj_consume_token(OF);
        break;
      case ON:
        jj_consume_token(ON);
        break;
      case BFILE_BASE:
        jj_consume_token(BFILE_BASE);
        break;
      case BLOB_BASE:
        jj_consume_token(BLOB_BASE);
        break;
      case CLOB_BASE:
        jj_consume_token(CLOB_BASE);
        break;
      case DATE_BASE:
        jj_consume_token(DATE_BASE);
        break;
      case OPERATOR:
        jj_consume_token(OPERATOR);
        break;
      case OPTION:
        jj_consume_token(OPTION);
        break;
      case OR:
        jj_consume_token(OR);
        break;
      case ORDER:
        jj_consume_token(ORDER);
        break;
      case OUT:
        jj_consume_token(OUT);
        break;
      case PCTFREE:
        jj_consume_token(PCTFREE);
        break;
      case PLS_INTEGER:
        jj_consume_token(PLS_INTEGER);
        break;
      case POSITIVE:
        jj_consume_token(POSITIVE);
        break;
      case POSITIVEN:
        jj_consume_token(POSITIVEN);
        break;
      case PRIOR:
        jj_consume_token(PRIOR);
        break;
      case PRIVATE:
        jj_consume_token(PRIVATE);
        break;
      case PROMPT:
        jj_consume_token(PROMPT);
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        break;
      case RAISE:
        jj_consume_token(RAISE);
        break;
      case RAW:
        jj_consume_token(RAW);
        break;
      case RELEASE:
        jj_consume_token(RELEASE);
        break;
      case ROWTYPE:
        jj_consume_token(ROWTYPE);
        break;
      case SELECT:
        jj_consume_token(SELECT);
        break;
      case SEPARATE:
        jj_consume_token(SEPARATE);
        break;
      case SHARE:
        jj_consume_token(SHARE);
        break;
      case SMALLINT:
        jj_consume_token(SMALLINT);
        break;
      case SQL:
        jj_consume_token(SQL);
        break;
      case SQLCODE:
        jj_consume_token(SQLCODE);
        break;
      case SQLERRM:
        jj_consume_token(SQLERRM);
        break;
      case START:
        jj_consume_token(START);
        break;
      case STDDEV:
        jj_consume_token(STDDEV);
        break;
      case SUM:
        jj_consume_token(SUM);
        break;
      case SYNONYM:
        jj_consume_token(SYNONYM);
        break;
      case SYSDATE:
        jj_consume_token(SYSDATE);
        break;
      case TABLE:
        jj_consume_token(TABLE);
        break;
      case THEN:
        jj_consume_token(THEN);
        break;
      case TO:
        jj_consume_token(TO);
        break;
      case TRIGGER:
        jj_consume_token(TRIGGER);
        break;
      case TYPE:
        jj_consume_token(TYPE);
        break;
      case UI:
        jj_consume_token(UI);
        break;
      case UPDATE:
        jj_consume_token(UPDATE);
        break;
      case VARCHAR:
        jj_consume_token(VARCHAR);
        break;
      case VARCHAR2:
        jj_consume_token(VARCHAR2);
        break;
      case INT:
        jj_consume_token(INT);
        break;
      case SIGNTYPE:
        jj_consume_token(SIGNTYPE);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      case WITH:
        jj_consume_token(WITH);
        break;
      case WHILE:
        jj_consume_token(WHILE);
        break;
      case JAVA_INTERFACE_CLASS:
        jj_consume_token(JAVA_INTERFACE_CLASS);
        break;
      case SQLDATA_CLASS:
        jj_consume_token(SQLDATA_CLASS);
        break;
      case CUSTOMDATUM_CLASS:
        jj_consume_token(CUSTOMDATUM_CLASS);
        break;
      case ORADATA_CLASS:
        jj_consume_token(ORADATA_CLASS);
        break;
      default:
        jj_la1[398] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 2006-05-20 - Matthias Hendler - added <OLD>, <NEW>, <LOOP>, <INT>
 */
  final public ASTUnqualifiedID UnqualifiedID() throws ParseException {
                                   /*@bgen(jjtree) UnqualifiedID */
  ASTUnqualifiedID jjtn000 = new ASTUnqualifiedID(this, JJTUNQUALIFIEDID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case QUOTED_LITERAL:
        jj_consume_token(QUOTED_LITERAL);
        break;
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BULK:
      case BYTE:
      case CASCADE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MONTH:
      case NATURAL:
      case NEW:
      case NO:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PROCEDURE:
      case RANGE:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELF:
      case SET:
      case SPACE:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
        KEYWORD_UNRESERVED();
        break;
      case BODY:
        jj_consume_token(BODY);
        break;
      case MOD:
        jj_consume_token(MOD);
        break;
      case OPERATOR:
        jj_consume_token(OPERATOR);
        break;
      case PRIVATE:
        jj_consume_token(PRIVATE);
        break;
      case RAW:
        jj_consume_token(RAW);
        break;
      case REPLACE:
        jj_consume_token(REPLACE);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      case SQL:
        jj_consume_token(SQL);
        break;
      case SQLCODE:
        jj_consume_token(SQLCODE);
        break;
      case SQLERRM:
        jj_consume_token(SQLERRM);
        break;
      case SYSDATE:
        jj_consume_token(SYSDATE);
        break;
      case TYPE:
        jj_consume_token(TYPE);
        break;
      case LOOP:
        jj_consume_token(LOOP);
        break;
      case INT:
        jj_consume_token(INT);
        break;
      case ARRAY:
        jj_consume_token(ARRAY);
        break;
      default:
        jj_la1[399] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * 2006-05-20 - Matthias Hendler - added <LIMIT>
 */
  final public ASTQualifiedID QualifiedID() throws ParseException {
                               /*@bgen(jjtree) QualifiedID */
  ASTQualifiedID jjtn000 = new ASTQualifiedID(this, JJTQUALIFIEDID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case QUOTED_LITERAL:
        jj_consume_token(QUOTED_LITERAL);
        break;
      case DEFINER:
      case CURRENT_USER:
      case LANGUAGE:
      case ADD:
      case AGGREGATE:
      case AT:
      case ATTRIBUTE:
      case AUTHID:
      case BULK:
      case BYTE:
      case CASCADE:
      case CLOSE:
      case COALESCE:
      case COLLECT:
      case COLUMN:
      case COMMENT:
      case COMMIT:
      case CONSTRUCTOR:
      case CONTINUE:
      case CONVERT:
      case CURRENT:
      case CURSOR:
      case DATA:
      case DAY:
      case DISABLE:
      case ELEMENT:
      case ENABLE:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTIONS:
      case EXIT:
      case EXTERNAL:
      case EXTENDS:
      case EXTRACT:
      case FALSE:
      case FINAL:
      case FORCE:
      case FUNCTION:
      case GLOBAL:
      case HASH:
      case HEAP:
      case HOUR:
      case IMMEDIATE:
      case INDICES:
      case INDEXTYPE:
      case INDICATOR:
      case INSTANTIABLE:
      case INTERVAL:
      case INVALIDATE:
      case ISOLATION:
      case JAVA:
      case LEVEL:
      case LIMIT:
      case MAP:
      case MAX:
      case MEMBER:
      case MERGE:
      case MIN:
      case MINUTE:
      case MLSLABEL:
      case MODIFY:
      case MONTH:
      case NATURAL:
      case NEW:
      case NO:
      case OBJECT:
      case OID:
      case OPAQUE:
      case OPEN:
      case ORGANIZATION:
      case OTHERS:
      case OVERRIDING:
      case PACKAGE:
      case PARTITION:
      case PRESERVE:
      case PROCEDURE:
      case RANGE:
      case REAL:
      case RECORD:
      case REF:
      case RELIES_ON:
      case RESULT:
      case RETURN:
      case REVERSE:
      case ROLLBACK:
      case ROW:
      case ROWS:
      case ROWID:
      case ROWNUM:
      case SAVE:
      case SAVEPOINT:
      case SECOND:
      case SELF:
      case SET:
      case SPACE:
      case STATIC:
      case SUBTYPE:
      case SUBSTITUTABLE:
      case SUCCESSFUL:
      case SYS_REFCURSOR:
      case TEMPORARY:
      case TIME:
      case TIMESTAMP:
      case TIMEZONE_REGION:
      case TIMEZONE_ABBR:
      case TIMEZONE_MINUTE:
      case TIMEZONE_HOUR:
      case TRANSACTION:
      case TRUE:
      case UNDER:
      case USING:
      case YES:
      case SHOW:
      case A:
      case DOUBLE:
      case DEC:
      case PRECISION:
      case NUMERIC:
      case NCHAR:
      case NVARCHAR2:
      case UROWID:
      case VARRAY:
      case VARYING:
      case BFILE:
      case BLOB:
      case CLOB:
      case NCLOB:
      case YEAR:
      case LOCAL:
      case ZONE:
      case CHARACTER:
      case AFTER:
      case BEFORE:
      case OLD:
      case PARENT:
      case ANALYZE:
      case ASSOCIATE:
      case AUDIT:
      case COMPOUND:
      case DATABASE:
      case CALL:
      case DDL:
      case DISASSOCIATE:
      case EACH:
      case FOLLOWS:
      case LOGOFF:
      case LOGON:
      case NESTED:
      case NOAUDIT:
      case SCHEMA:
      case SERVERERROR:
      case SHUTDOWN:
      case STARTUP:
      case STATEMENT:
      case STATISTICS:
      case SUSPEND:
      case TRUNCATE:
      case WRAPPED:
      case LIBRARY:
      case NAME:
      case STRUCT:
      case CONTEXT:
      case PARAMETERS:
      case LENGTH:
      case TDO:
      case MAXLEN:
      case CHARSETID:
      case CHARSETFORM:
      case ACCEPT:
      case COPY:
      case DISCONNECT:
      case HOST:
      case PRINT:
      case QUIT:
      case REMARK:
      case UNDEFINE:
      case VARIABLE:
      case WHENEVER:
      case ATTACH:
      case CAST:
      case TREAT:
      case TRIM:
      case LEFT:
      case RIGHT:
      case BOTH:
      case EMPTY:
      case MULTISET:
      case SUBMULTISET:
      case LEADING:
      case TRAILING:
      case CHAR_CS:
      case NCHAR_CS:
      case DBTIMEZONE:
      case SESSIONTIMEZONE:
        KEYWORD_UNRESERVED();
        break;
      case REPLACE:
        jj_consume_token(REPLACE);
        break;
      case SERIALLY_REUSABLE:
        jj_consume_token(SERIALLY_REUSABLE);
        break;
      case RESTRICT_REFERENCES:
        jj_consume_token(RESTRICT_REFERENCES);
        break;
      case EXCEPTION_INIT:
        jj_consume_token(EXCEPTION_INIT);
        break;
      case AUTONOMOUS_TRANSACTION:
        jj_consume_token(AUTONOMOUS_TRANSACTION);
        break;
      case ARRAY:
        jj_consume_token(ARRAY);
        break;
      case AVG:
        jj_consume_token(AVG);
        break;
      case BINARY_INTEGER:
        jj_consume_token(BINARY_INTEGER);
        break;
      case BODY:
        jj_consume_token(BODY);
        break;
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
        break;
      case CHAR:
        jj_consume_token(CHAR);
        break;
      case CHAR_BASE:
        jj_consume_token(CHAR_BASE);
        break;
      case CONSTANT:
        jj_consume_token(CONSTANT);
        break;
      case CURRVAL:
        jj_consume_token(CURRVAL);
        break;
      case DATE:
        jj_consume_token(DATE);
        break;
      case DECIMAL:
        jj_consume_token(DECIMAL);
        break;
      case DELETE:
        jj_consume_token(DELETE);
        break;
      case DO:
        jj_consume_token(DO);
        break;
      case ELSIF:
        jj_consume_token(ELSIF);
        break;
      case EXECUTE:
        jj_consume_token(EXECUTE);
        break;
      case EXISTS:
        jj_consume_token(EXISTS);
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
        break;
      case FORALL:
        jj_consume_token(FORALL);
        break;
      case INTEGER:
        jj_consume_token(INTEGER);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
        break;
      case LONG:
        jj_consume_token(LONG);
        break;
      case LOOP:
        jj_consume_token(LOOP);
        break;
      case MOD:
        jj_consume_token(MOD);
        break;
      case NATURALN:
        jj_consume_token(NATURALN);
        break;
      case NEXTVAL:
        jj_consume_token(NEXTVAL);
        break;
      case NOCOPY:
        jj_consume_token(NOCOPY);
        break;
      case NULLIF:
        jj_consume_token(NULLIF);
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      case BFILE_BASE:
        jj_consume_token(BFILE_BASE);
        break;
      case BLOB_BASE:
        jj_consume_token(BLOB_BASE);
        break;
      case CLOB_BASE:
        jj_consume_token(CLOB_BASE);
        break;
      case DATE_BASE:
        jj_consume_token(DATE_BASE);
        break;
      case NUMBER_BASE:
        jj_consume_token(NUMBER_BASE);
        break;
      case OCIROWID:
        jj_consume_token(OCIROWID);
        break;
      case OPERATOR:
        jj_consume_token(OPERATOR);
        break;
      case OUT:
        jj_consume_token(OUT);
        break;
      case PLS_INTEGER:
        jj_consume_token(PLS_INTEGER);
        break;
      case POSITIVE:
        jj_consume_token(POSITIVE);
        break;
      case POSITIVEN:
        jj_consume_token(POSITIVEN);
        break;
      case PRAGMA:
        jj_consume_token(PRAGMA);
        break;
      case PRIOR:
        jj_consume_token(PRIOR);
        break;
      case PRIVATE:
        jj_consume_token(PRIVATE);
        break;
      case PROMPT:
        jj_consume_token(PROMPT);
        break;
      case RAISE:
        jj_consume_token(RAISE);
        break;
      case RAW:
        jj_consume_token(RAW);
        break;
      case RELEASE:
        jj_consume_token(RELEASE);
        break;
      case ROWTYPE:
        jj_consume_token(ROWTYPE);
        break;
      case SEPARATE:
        jj_consume_token(SEPARATE);
        break;
      case SMALLINT:
        jj_consume_token(SMALLINT);
        break;
      case SQLCODE:
        jj_consume_token(SQLCODE);
        break;
      case SQLERRM:
        jj_consume_token(SQLERRM);
        break;
      case STDDEV:
        jj_consume_token(STDDEV);
        break;
      case SUM:
        jj_consume_token(SUM);
        break;
      case SYNONYM:
        jj_consume_token(SYNONYM);
        break;
      case SYSDATE:
        jj_consume_token(SYSDATE);
        break;
      case TRIGGER:
        jj_consume_token(TRIGGER);
        break;
      case TYPE:
        jj_consume_token(TYPE);
        break;
      case UI:
        jj_consume_token(UI);
        break;
      case VARCHAR:
        jj_consume_token(VARCHAR);
        break;
      case VARCHAR2:
        jj_consume_token(VARCHAR2);
        break;
      case INT:
        jj_consume_token(INT);
        break;
      case SIGNTYPE:
        jj_consume_token(SIGNTYPE);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      case WHILE:
        jj_consume_token(WHILE);
        break;
      default:
        jj_la1[400] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTTypeKeyword TypeKeyword() throws ParseException {
                               /*@bgen(jjtree) TypeKeyword */
  ASTTypeKeyword jjtn000 = new ASTTypeKeyword(this, JJTTYPEKEYWORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case BFILE_BASE:
        jj_consume_token(BFILE_BASE);
        break;
      case BLOB_BASE:
        jj_consume_token(BLOB_BASE);
        break;
      case CLOB_BASE:
        jj_consume_token(CLOB_BASE);
        break;
      case DATE_BASE:
        jj_consume_token(DATE_BASE);
        break;
      case NUMBER_BASE:
        jj_consume_token(NUMBER_BASE);
        break;
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
        break;
      case DATE:
        jj_consume_token(DATE);
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
        break;
      case REAL:
        jj_consume_token(REAL);
        break;
      case INTEGER:
        jj_consume_token(INTEGER);
        break;
      case INT:
        jj_consume_token(INT);
        break;
      case SMALLINT:
        jj_consume_token(SMALLINT);
        break;
      case DECIMAL:
        jj_consume_token(DECIMAL);
        break;
      case NUMERIC:
        jj_consume_token(NUMERIC);
        break;
      case DEC:
        jj_consume_token(DEC);
        break;
      case BINARY_INTEGER:
        jj_consume_token(BINARY_INTEGER);
        break;
      case NATURAL:
        jj_consume_token(NATURAL);
        break;
      case NATURALN:
        jj_consume_token(NATURALN);
        break;
      case POSITIVE:
        jj_consume_token(POSITIVE);
        break;
      case POSITIVEN:
        jj_consume_token(POSITIVEN);
        break;
      case SIGNTYPE:
        jj_consume_token(SIGNTYPE);
        break;
      case VARCHAR2:
        jj_consume_token(VARCHAR2);
        break;
      case VARCHAR:
        jj_consume_token(VARCHAR);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      case LONG:
        jj_consume_token(LONG);
        break;
      case RAW:
        jj_consume_token(RAW);
        break;
      case ROWID:
        jj_consume_token(ROWID);
        break;
      case CHAR:
        jj_consume_token(CHAR);
        break;
      case CHARACTER:
        jj_consume_token(CHARACTER);
        break;
      case MLSLABEL:
        jj_consume_token(MLSLABEL);
        break;
      case BLOB:
        jj_consume_token(BLOB);
        break;
      case CLOB:
        jj_consume_token(CLOB);
        break;
      case BFILE:
        jj_consume_token(BFILE);
        break;
      case NCHAR:
        jj_consume_token(NCHAR);
        break;
      case NVARCHAR2:
        jj_consume_token(NVARCHAR2);
        break;
      case NCLOB:
        jj_consume_token(NCLOB);
        break;
      case PLS_INTEGER:
        jj_consume_token(PLS_INTEGER);
        break;
      case TIME:
        jj_consume_token(TIME);
        break;
      case TIMESTAMP:
        jj_consume_token(TIMESTAMP);
        break;
      case UROWID:
        jj_consume_token(UROWID);
        break;
      case ARRAY:
        jj_consume_token(ARRAY);
        break;
      case AUTHID:
        jj_consume_token(AUTHID);
        break;
      case CHAR_BASE:
        jj_consume_token(CHAR_BASE);
        break;
      case CURRVAL:
        jj_consume_token(CURRVAL);
        break;
      case HOUR:
        jj_consume_token(HOUR);
        break;
      case INTERVAL:
        jj_consume_token(INTERVAL);
        break;
      case MONTH:
        jj_consume_token(MONTH);
        break;
      case OCIROWID:
        jj_consume_token(OCIROWID);
        break;
      case RECORD:
        jj_consume_token(RECORD);
        break;
      case REF:
        jj_consume_token(REF);
        break;
      case ROW:
        jj_consume_token(ROW);
        break;
      case ROWNUM:
        jj_consume_token(ROWNUM);
        break;
      case ROWTYPE:
        jj_consume_token(ROWTYPE);
        break;
      case SECOND:
        jj_consume_token(SECOND);
        break;
      case SET:
        jj_consume_token(SET);
        break;
      case TABLE:
        jj_consume_token(TABLE);
        break;
      case TIMEZONE_REGION:
        jj_consume_token(TIMEZONE_REGION);
        break;
      case TIMEZONE_ABBR:
        jj_consume_token(TIMEZONE_ABBR);
        break;
      case TIMEZONE_MINUTE:
        jj_consume_token(TIMEZONE_MINUTE);
        break;
      case TIMEZONE_HOUR:
        jj_consume_token(TIMEZONE_HOUR);
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
        break;
      case PRECISION:
        jj_consume_token(PRECISION);
        break;
      case VARRAY:
        jj_consume_token(VARRAY);
        break;
      case YEAR:
        jj_consume_token(YEAR);
        break;
      case LOCAL:
        jj_consume_token(LOCAL);
        break;
      case WITH:
        jj_consume_token(WITH);
        break;
      case ZONE:
        jj_consume_token(ZONE);
        break;
      case JAVA_INTERFACE_CLASS:
        jj_consume_token(JAVA_INTERFACE_CLASS);
        break;
      case SQLDATA_CLASS:
        jj_consume_token(SQLDATA_CLASS);
        break;
      case CUSTOMDATUM_CLASS:
        jj_consume_token(CUSTOMDATUM_CLASS);
        break;
      case ORADATA_CLASS:
        jj_consume_token(ORADATA_CLASS);
        break;
      default:
        jj_la1[401] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTJavaInterfaceClass JavaInterfaceClass() throws ParseException {
                                             /*@bgen(jjtree) JavaInterfaceClass */
  ASTJavaInterfaceClass jjtn000 = new ASTJavaInterfaceClass(this, JJTJAVAINTERFACECLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_nt.kind) {
      case SQLDATA_CLASS:
        jj_consume_token(SQLDATA_CLASS);
        break;
      case CUSTOMDATUM_CLASS:
        jj_consume_token(CUSTOMDATUM_CLASS);
        break;
      case ORADATA_CLASS:
        jj_consume_token(ORADATA_CLASS);
        break;
      default:
        jj_la1[402] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
          jjtn000.setImage(token.toString()) ; jjtn000.value = token ; {if (true) return jjtn000 ;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Tests, if the new Token if type ID is identical to the old Token of type ID.
 * 
 * 2006-05-18 - Matthias Hendler - added: Just for understanding javacc and not used,
 *                                        cause to many closing ENDs (IDENTIFIER) were mistyped.
 */
  final public SimpleNode EqualsOldIDNewID(SimpleNode pOldID) throws ParseException {
 /*@bgen(jjtree) EqualsOldIDNewID */
        ASTEqualsOldIDNewID jjtn000 = new ASTEqualsOldIDNewID(this, JJTEQUALSOLDIDNEWID);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        jjtn000.jjtSetFirstToken(getToken(1));SimpleNode newID;
        Token oldIDToken;
        Token newIDToken;
    try {
      newID = ID();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.jjtSetLastToken(getToken(0));
                oldIDToken = (Token) pOldID.value ;
                newIDToken = (Token) newID.value ;
                if (oldIDToken.image.equals(newIDToken.image)) {
                        {if (true) return newID;}
                } else {
                        {if (true) throw new ParseException("PLSQL syntax error on line "+newIDToken.beginLine+" at column "+newIDToken.beginColumn+"!\u005cn"
                                + "Found \u005c""+newIDToken.image+"\u005c" but expected \u005c""+oldIDToken.image+"\u005c".");}
                }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.jjtSetLastToken(getToken(0));
          }
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  private boolean jj_2_58(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  private boolean jj_2_59(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  private boolean jj_2_60(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_60(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  private boolean jj_2_61(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_61(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  private boolean jj_2_62(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_62(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  private boolean jj_2_63(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_63(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  private boolean jj_2_64(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_64(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  private boolean jj_2_65(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_65(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  private boolean jj_2_66(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_66(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  private boolean jj_2_67(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_67(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  private boolean jj_2_68(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_68(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  private boolean jj_2_69(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_69(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  private boolean jj_2_70(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_70(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  private boolean jj_2_71(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_71(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  private boolean jj_2_72(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_72(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  private boolean jj_2_73(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_73(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  private boolean jj_2_74(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_74(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  private boolean jj_2_75(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_75(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  private boolean jj_2_76(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_76(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  private boolean jj_3R_377() {
    if (jj_3R_167()) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_3R_167()) return true;
    return false;
  }

  private boolean jj_3R_450() {
    if (jj_scan_token(IS)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(5)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3R_449() {
    if (jj_scan_token(RETURN)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_448() {
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_scan_token(CURSOR)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_448()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_449()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_450()) jj_scanpos = xsp;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_551() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_557() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_549() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_378() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_550() {
    if (jj_scan_token(3)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) {
    jj_scanpos = xsp;
    if (jj_scan_token(416)) {
    jj_scanpos = xsp;
    if (jj_3R_557()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_520() {
    if (jj_scan_token(9)) return true;
    if (jj_scan_token(10)) return true;
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_scan_token(PARAMETERS)) return true;
    if (jj_3R_552()) return true;
    return false;
  }

  private boolean jj_3R_492() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_520()) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) return true;
    }
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_471() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_111()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_scan_token(WITH)) return true;
    if (jj_scan_token(CONTEXT)) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_3R_329()) return true;
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_scan_token(NAME)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) {
    jj_scanpos = xsp;
    if (jj_scan_token(416)) {
    jj_scanpos = xsp;
    if (jj_3R_551()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_473() {
    if (jj_scan_token(INDEX)) return true;
    if (jj_scan_token(BY)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_469() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_467()) return true;
    return false;
  }

  private boolean jj_3R_169() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_243()) {
    jj_scanpos = xsp;
    if (jj_3R_244()) {
    jj_scanpos = xsp;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_scan_token(LIBRARY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) {
    jj_scanpos = xsp;
    if (jj_scan_token(416)) {
    jj_scanpos = xsp;
    if (jj_3R_549()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_550()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_468() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_467()) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_scan_token(LANGUAGE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) {
    jj_scanpos = xsp;
    if (jj_scan_token(151)) return true;
    }
    return false;
  }

  private boolean jj_3R_491() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(179)) jj_scanpos = xsp;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_3R_328()) return true;
    return false;
  }

  private boolean jj_3R_229() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_275()) {
    jj_scanpos = xsp;
    if (jj_3R_276()) return true;
    }
    return false;
  }

  private boolean jj_3R_475() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_470() {
    if (jj_scan_token(VARYING)) return true;
    if (jj_scan_token(ARRAY)) return true;
    return false;
  }

  private boolean jj_3R_474() {
    if (jj_scan_token(RETURN)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_472() {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_107() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_3R_168()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_169()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_447() {
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_329() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(355)) {
    jj_scanpos = xsp;
    if (jj_scan_token(354)) {
    jj_scanpos = xsp;
    if (jj_scan_token(349)) {
    jj_scanpos = xsp;
    if (jj_scan_token(348)) {
    jj_scanpos = xsp;
    if (jj_scan_token(353)) {
    jj_scanpos = xsp;
    if (jj_scan_token(358)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_446() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_202()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_475()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_445() {
    if (jj_scan_token(REF)) return true;
    if (jj_scan_token(CURSOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_474()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_467() {
    if (jj_3R_108()) return true;
    if (jj_3R_204()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_491()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_492()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_444() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(265)) {
    jj_scanpos = xsp;
    if (jj_scan_token(304)) {
    jj_scanpos = xsp;
    if (jj_3R_470()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_471()) jj_scanpos = xsp;
    if (jj_scan_token(OF)) return true;
    if (jj_3R_204()) return true;
    xsp = jj_scanpos;
    if (jj_3R_472()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_473()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_375() {
    if (jj_scan_token(DISASSOCIATE)) return true;
    if (jj_scan_token(STATISTICS)) return true;
    return false;
  }

  private boolean jj_3R_443() {
    if (jj_scan_token(RECORD)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_467()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_469()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3_76() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    return false;
  }

  private boolean jj_3R_442() {
    if (jj_scan_token(OBJECT)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_467()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_468()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_374() {
    if (jj_scan_token(ASSOCIATE)) return true;
    if (jj_scan_token(STATISTICS)) return true;
    return false;
  }

  private boolean jj_3R_328() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(338)) {
    jj_scanpos = xsp;
    if (jj_3R_374()) {
    jj_scanpos = xsp;
    if (jj_scan_token(340)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_3R_375()) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(351)) {
    jj_scanpos = xsp;
    if (jj_scan_token(228)) {
    jj_scanpos = xsp;
    if (jj_scan_token(234)) {
    jj_scanpos = xsp;
    if (jj_scan_token(359)) {
    jj_scanpos = xsp;
    if (jj_scan_token(344)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_580() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_scan_token(NEW)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) {
    jj_scanpos = xsp;
    if (jj_scan_token(186)) {
    jj_scanpos = xsp;
    if (jj_scan_token(185)) {
    jj_scanpos = xsp;
    if (jj_scan_token(184)) {
    jj_scanpos = xsp;
    if (jj_scan_token(188)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_573() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_441() {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_466() {
    if (jj_scan_token(RANGE)) return true;
    if (jj_3R_433()) return true;
    if (jj_scan_token(12)) return true;
    if (jj_3R_433()) return true;
    return false;
  }

  private boolean jj_3_71() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    return false;
  }

  private boolean jj_3R_465() {
    if (jj_scan_token(5)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_440() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_465()) {
    jj_scanpos = xsp;
    if (jj_3R_466()) return true;
    }
    return false;
  }

  private boolean jj_3_75() {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_3R_229()) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_scan_token(TYPE)) return true;
    if (jj_3R_104()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_37()) {
    jj_scanpos = xsp;
    if (jj_3R_442()) {
    jj_scanpos = xsp;
    if (jj_3R_443()) {
    jj_scanpos = xsp;
    if (jj_3R_444()) {
    jj_scanpos = xsp;
    if (jj_3R_445()) {
    jj_scanpos = xsp;
    if (jj_3R_446()) {
    jj_scanpos = xsp;
    if (jj_3R_447()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_74() {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3_73() {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3_72() {
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_3R_229()) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_scan_token(SUBTYPE)) return true;
    if (jj_3R_104()) return true;
    if (jj_scan_token(IS)) return true;
    if (jj_3R_204()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_440()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_441()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_581() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_569() {
    if (jj_scan_token(LIMIT)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_132() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) return true;
    }
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_579() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_575() {
    if (jj_scan_token(CC_ELSE)) return true;
    Token xsp;
    if (jj_3R_581()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_581()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_574() {
    if (jj_scan_token(CC_ELSIF)) return true;
    if (jj_3R_297()) return true;
    if (jj_scan_token(CC_THEN)) return true;
    Token xsp;
    if (jj_3R_580()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_580()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_413() {
    if (jj_scan_token(CC_ERROR)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(CC_END)) return true;
    return false;
  }

  private boolean jj_3_67() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    return false;
  }

  private boolean jj_3_70() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    return false;
  }

  private boolean jj_3R_412() {
    if (jj_scan_token(CC_IF)) return true;
    if (jj_3R_297()) return true;
    if (jj_scan_token(CC_THEN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_573()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_574()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_575()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CC_END)) return true;
    return false;
  }

  private boolean jj_3R_567() {
    if (jj_scan_token(BULK)) return true;
    if (jj_scan_token(COLLECT)) return true;
    return false;
  }

  private boolean jj_3R_373() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_412()) {
    jj_scanpos = xsp;
    if (jj_3R_413()) return true;
    }
    return false;
  }

  private boolean jj_3_66() {
    if (jj_scan_token(OF)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_131()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_568() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_572() {
    if (jj_scan_token(USING)) return true;
    if (jj_3R_202()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_579()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_372() {
    if (jj_scan_token(PIPE)) return true;
    if (jj_scan_token(ROW)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3_65() {
    if (jj_scan_token(OF)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_130()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_405() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_371() {
    if (jj_scan_token(EXECUTE)) return true;
    if (jj_scan_token(IMMEDIATE)) return true;
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_408() {
    if (jj_scan_token(FOR)) return true;
    if (jj_3R_202()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_572()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_369() {
    if (jj_scan_token(FETCH)) return true;
    if (jj_3R_112()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_567()) jj_scanpos = xsp;
    if (jj_scan_token(INTO)) return true;
    if (jj_3R_202()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_568()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_569()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_407() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_368() {
    if (jj_scan_token(OPEN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_407()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_408()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_230() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(291)) return true;
    }
    }
    return false;
  }

  private boolean jj_3_68() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    return false;
  }

  private boolean jj_3R_158() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_68()) jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3_69() {
    if (jj_scan_token(NESTED)) return true;
    if (jj_scan_token(TABLE)) return true;
    return false;
  }

  private boolean jj_3R_406() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_scan_token(OR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) return true;
    }
    return false;
  }

  private boolean jj_3R_367() {
    if (jj_scan_token(CLOSE)) return true;
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_155() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(291)) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3_65()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_scan_token(OR)) return true;
    if (jj_scan_token(REPLACE)) return true;
    return false;
  }

  private boolean jj_3R_404() {
    if (jj_3R_126()) return true;
    return false;
  }

  private boolean jj_3R_366() {
    if (jj_scan_token(RAISE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_406()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_3R_126()) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(CREATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_571() {
    if (jj_scan_token(12)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_154()) jj_scanpos = xsp;
    if (jj_scan_token(TRIGGER)) return true;
    if (jj_3R_134()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(316)) {
    jj_scanpos = xsp;
    if (jj_scan_token(315)) {
    jj_scanpos = xsp;
    if (jj_scan_token(317)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) return true;
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_157()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(ON)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(342)) {
    jj_scanpos = xsp;
    if (jj_3_69()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_365() {
    if (jj_scan_token(EXIT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_404()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_405()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_403() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_176()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_565() {
    if (jj_scan_token(SAVE)) return true;
    if (jj_scan_token(EXCEPTIONS)) return true;
    return false;
  }

  private boolean jj_3R_564() {
    if (jj_3R_202()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_571()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_562() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_563() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(137)) {
    jj_scanpos = xsp;
    if (jj_scan_token(283)) return true;
    }
    if (jj_scan_token(OF)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_364() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_403()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_363() {
    if (jj_scan_token(GOTO)) return true;
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_360() {
    if (jj_scan_token(FORALL)) return true;
    if (jj_3R_401()) return true;
    if (jj_scan_token(IN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_563()) {
    jj_scanpos = xsp;
    if (jj_3R_564()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_565()) jj_scanpos = xsp;
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3R_561() {
    if (jj_scan_token(12)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_558() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_566() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_401() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_400() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_560() {
    if (jj_3R_435()) return true;
    return false;
  }

  private boolean jj_3R_559() {
    if (jj_3R_570()) return true;
    return false;
  }

  private boolean jj_3R_358() {
    if (jj_scan_token(IF)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(THEN)) return true;
    Token xsp;
    if (jj_3R_558()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_558()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_559()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_560()) jj_scanpos = xsp;
    if (jj_scan_token(END)) return true;
    if (jj_scan_token(IF)) return true;
    return false;
  }

  private boolean jj_3R_578() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_355() {
    if (jj_scan_token(INTERFACE)) return true;
    if (jj_scan_token(5)) return true;
    return false;
  }

  private boolean jj_3R_354() {
    if (jj_scan_token(EXCEPTION_INIT)) return true;
    if (jj_scan_token(5)) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_scan_token(LOCK)) return true;
    if (jj_scan_token(TABLE)) return true;
    return false;
  }

  private boolean jj_3R_362() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(LOOP)) return true;
    Token xsp;
    if (jj_3R_566()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_566()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(END)) return true;
    if (jj_scan_token(LOOP)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_353() {
    if (jj_scan_token(RESTRICT_REFERENCES)) return true;
    if (jj_scan_token(5)) return true;
    return false;
  }

  private boolean jj_3R_359() {
    if (jj_scan_token(FOR)) return true;
    if (jj_3R_400()) return true;
    if (jj_scan_token(IN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(233)) jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    xsp = jj_scanpos;
    if (jj_3R_561()) jj_scanpos = xsp;
    if (jj_scan_token(LOOP)) return true;
    if (jj_3R_562()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_562()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(END)) return true;
    if (jj_scan_token(LOOP)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_576() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_402() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_scan_token(PRAGMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_3R_353()) {
    jj_scanpos = xsp;
    if (jj_3R_354()) {
    jj_scanpos = xsp;
    if (jj_3R_355()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_361() {
    if (jj_scan_token(LOOP)) return true;
    Token xsp;
    if (jj_3R_402()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_402()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(END)) return true;
    if (jj_scan_token(LOOP)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_scan_token(SET)) return true;
    if (jj_scan_token(TRANSACTION)) return true;
    return false;
  }

  private boolean jj_3R_577() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_570() {
    if (jj_scan_token(ELSIF)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(THEN)) return true;
    Token xsp;
    if (jj_3R_578()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_578()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_435() {
    if (jj_scan_token(ELSE)) return true;
    Token xsp;
    if (jj_3R_577()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_577()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_434() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(THEN)) return true;
    Token xsp;
    if (jj_3R_576()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_576()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_3R_108()) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_397() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_399() {
    if (jj_3R_435()) return true;
    return false;
  }

  private boolean jj_3R_398() {
    if (jj_3R_434()) return true;
    return false;
  }

  private boolean jj_3R_357() {
    if (jj_scan_token(CASE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_397()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_398()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_399()) jj_scanpos = xsp;
    if (jj_scan_token(END)) return true;
    if (jj_scan_token(CASE)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_273() {
    Token xsp;
    if (jj_3R_308()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_308()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_274()) return true;
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_3R_274()) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_3R_273()) return true;
    return false;
  }

  private boolean jj_3R_153() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) return true;
    }
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(CASCADE)) return true;
    return false;
  }

  private boolean jj_3R_327() {
    if (jj_3R_202()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_326() {
    if (jj_3R_373()) return true;
    return false;
  }

  private boolean jj_3R_325() {
    if (jj_3R_372()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_396() {
    if (jj_scan_token(LOCK)) return true;
    if (jj_scan_token(TABLE)) return true;
    return false;
  }

  private boolean jj_3R_324() {
    if (jj_3R_371()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_272() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(148)) {
    jj_scanpos = xsp;
    if (jj_3R_307()) return true;
    }
    return false;
  }

  private boolean jj_3R_323() {
    if (jj_3R_370()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_322() {
    if (jj_3R_369()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_321() {
    if (jj_3R_368()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_320() {
    if (jj_3R_367()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_319() {
    if (jj_3R_366()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3_64() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_318() {
    if (jj_3R_365()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_317() {
    if (jj_3R_364()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_316() {
    if (jj_3R_363()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_scan_token(291)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(235)) {
    jj_scanpos = xsp;
    if (jj_scan_token(242)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_scan_token(162)) {
    jj_scanpos = xsp;
    if (jj_scan_token(312)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_113() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(5)) jj_scanpos = xsp;
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  private boolean jj_3R_315() {
    if (jj_3R_362()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_314() {
    if (jj_3R_361()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_313() {
    if (jj_3R_360()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_312() {
    if (jj_3R_359()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_271() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(179)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_311() {
    if (jj_3R_358()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3_63() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_310() {
    if (jj_3R_357()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_3R_116()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_3R_356()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_395() {
    if (jj_scan_token(SET)) return true;
    if (jj_scan_token(TRANSACTION)) return true;
    return false;
  }

  private boolean jj_3R_274() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_309()) {
    jj_scanpos = xsp;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) {
    jj_scanpos = xsp;
    if (jj_3R_311()) {
    jj_scanpos = xsp;
    if (jj_3R_312()) {
    jj_scanpos = xsp;
    if (jj_3R_313()) {
    jj_scanpos = xsp;
    if (jj_3R_314()) {
    jj_scanpos = xsp;
    if (jj_3R_315()) {
    jj_scanpos = xsp;
    if (jj_3R_316()) {
    jj_scanpos = xsp;
    if (jj_3R_317()) {
    jj_scanpos = xsp;
    if (jj_3R_318()) {
    jj_scanpos = xsp;
    if (jj_3R_319()) {
    jj_scanpos = xsp;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) {
    jj_scanpos = xsp;
    if (jj_3R_322()) {
    jj_scanpos = xsp;
    if (jj_3R_323()) {
    jj_scanpos = xsp;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) {
    jj_scanpos = xsp;
    if (jj_3R_326()) {
    jj_scanpos = xsp;
    if (jj_3R_327()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_62() {
    if (jj_scan_token(AUTHID)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) return true;
    }
    return false;
  }

  private boolean jj_3R_270() {
    if (jj_scan_token(REPLACE)) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_scan_token(WRAPPED)) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(DROP)) return true;
    return false;
  }

  private boolean jj_3R_356() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(244)) {
    jj_scanpos = xsp;
    if (jj_scan_token(291)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(235)) {
    jj_scanpos = xsp;
    if (jj_scan_token(242)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_3R_395()) {
    jj_scanpos = xsp;
    if (jj_3R_396()) {
    jj_scanpos = xsp;
    if (jj_scan_token(162)) {
    jj_scanpos = xsp;
    if (jj_scan_token(312)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_252()) return true;
    return false;
  }

  private boolean jj_3R_305() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(6)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(167)) return true;
    }
    return false;
  }

  private boolean jj_3R_269() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) return true;
    }
    return false;
  }

  private boolean jj_3R_439() {
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_3R_129()) return true;
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_scan_token(ALTER)) return true;
    if (jj_scan_token(TYPE)) return true;
    if (jj_3R_112()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_269()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_270()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_271()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_272()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_61() {
    if (jj_3R_129()) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_3R_222()) return true;
    return false;
  }

  private boolean jj_3R_147() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_223()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_3R_222()) return true;
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_3R_303()) return true;
    return false;
  }

  private boolean jj_3R_145() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(179)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_scan_token(6)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_267()) {
    jj_scanpos = xsp;
    if (jj_3_61()) {
    jj_scanpos = xsp;
    if (jj_3R_268()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_266() {
    if (jj_3R_303()) return true;
    return false;
  }

  private boolean jj_3_60() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_220() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_60()) {
    jj_scanpos = xsp;
    if (jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_554() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(5)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_220()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_221()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_527() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_3R_213()) return true;
    return false;
  }

  private boolean jj_3_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    if (jj_3R_127()) return true;
    if (jj_scan_token(OF)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    if (jj_scan_token(OPAQUE)) return true;
    if (jj_scan_token(VARYING)) return true;
    if (jj_scan_token(24)) return true;
    return false;
  }

  private boolean jj_3_59() {
    if (jj_scan_token(EXTERNAL)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LANGUAGE)) return true;
    if (jj_scan_token(JAVA)) return true;
    if (jj_scan_token(USING)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    if (jj_scan_token(OBJECT)) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(UNDER)) return true;
    if (jj_3R_134()) return true;
    return false;
  }

  private boolean jj_3R_142() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3_56()) {
    jj_scanpos = xsp;
    if (jj_3_57()) {
    jj_scanpos = xsp;
    if (jj_3_58()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_552() {
    return false;
  }

  private boolean jj_3R_553() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_526() {
    if (jj_3R_302()) return true;
    return false;
  }

  private boolean jj_3_55() {
    if (jj_scan_token(AUTHID)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) return true;
    }
    return false;
  }

  private boolean jj_3_54() {
    if (jj_scan_token(OID)) return true;
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_555() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_scan_token(OR)) return true;
    if (jj_scan_token(REPLACE)) return true;
    return false;
  }

  private boolean jj_3R_525() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_scan_token(CREATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_96() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_141()) jj_scanpos = xsp;
    if (jj_scan_token(TYPE)) return true;
    if (jj_3R_134()) return true;
    xsp = jj_scanpos;
    if (jj_3_54()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_55()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_142()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_59()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_143()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_145()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_146()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_147()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_252() {
    return false;
  }

  private boolean jj_3R_497() {
    if (jj_3R_160()) return true;
    if (jj_scan_token(BEGIN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_525()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_526()) jj_scanpos = xsp;
    if (jj_scan_token(END)) return true;
    xsp = jj_scanpos;
    if (jj_3R_527()) jj_scanpos = xsp;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_544() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_scan_token(OTHERS)) return true;
    if (jj_scan_token(THEN)) return true;
    Token xsp;
    if (jj_3R_555()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_555()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_496() {
    if (jj_3R_107()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_3R_112()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_553()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(THEN)) return true;
    if (jj_3R_554()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_554()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_476() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_496()) {
    jj_scanpos = xsp;
    if (jj_3R_497()) return true;
    }
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(EXCEPTION)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_34()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_544()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_52() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    return false;
  }

  private boolean jj_3_33() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_111()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_209() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(159)) {
    jj_scanpos = xsp;
    if (jj_scan_token(199)) return true;
    }
    return false;
  }

  private boolean jj_3R_208() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(179)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(203)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) return true;
    }
    }
    return false;
  }

  private boolean jj_3_53() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_128() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_208()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_209()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(161)) {
    jj_scanpos = xsp;
    if (jj_scan_token(256)) return true;
    }
    }
    if (jj_3R_162()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(94)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(205)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(209)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(231)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_476()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_430() {
    if (jj_scan_token(TO)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(310)) {
    jj_scanpos = xsp;
    if (jj_scan_token(170)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(243)) return true;
    }
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3_33()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_455() {
    if (jj_scan_token(LOCAL)) return true;
    return false;
  }

  private boolean jj_3R_429() {
    if (jj_scan_token(WITH)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_455()) jj_scanpos = xsp;
    if (jj_scan_token(TIME)) return true;
    if (jj_scan_token(ZONE)) return true;
    return false;
  }

  private boolean jj_3R_388() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_429()) {
    jj_scanpos = xsp;
    if (jj_3R_430()) return true;
    }
    return false;
  }

  private boolean jj_3_32() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_111()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_387() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(310)) {
    jj_scanpos = xsp;
    if (jj_scan_token(170)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(243)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_386() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_scan_token(6)) return true;
    return false;
  }

  private boolean jj_3R_385() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(OR)) return true;
    if (jj_scan_token(REPLACE)) return true;
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_224()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_225()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_548() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_151() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(176)) jj_scanpos = xsp;
    if (jj_scan_token(FORCE)) return true;
    return false;
  }

  private boolean jj_3R_547() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_scan_token(CREATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_150()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_151()) jj_scanpos = xsp;
    if (jj_scan_token(VIEW)) return true;
    if (jj_3R_134()) return true;
    xsp = jj_scanpos;
    if (jj_3R_152()) jj_scanpos = xsp;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_153()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    return false;
  }

  private boolean jj_3_27() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_111()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_345() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(146)) {
    jj_scanpos = xsp;
    if (jj_scan_token(269)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_385()) {
    jj_scanpos = xsp;
    if (jj_3R_386()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_387()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_32()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_388()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_3R_108()) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_scan_token(GLOBAL)) return true;
    if (jj_scan_token(TEMPORARY)) return true;
    return false;
  }

  private boolean jj_3R_438() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_437() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) return true;
    }
    return false;
  }

  private boolean jj_3_51() {
    if (jj_scan_token(ON)) return true;
    if (jj_scan_token(COMMIT)) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_scan_token(TO)) return true;
    if (jj_scan_token(SECOND)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_27()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_scan_token(CREATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_148()) jj_scanpos = xsp;
    if (jj_scan_token(TABLE)) return true;
    if (jj_3R_134()) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_scan_token(TO)) return true;
    if (jj_scan_token(MONTH)) return true;
    return false;
  }

  private boolean jj_3_29() {
    if (jj_scan_token(WITH)) return true;
    if (jj_scan_token(TIME)) return true;
    if (jj_scan_token(ZONE)) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_scan_token(WITH)) return true;
    if (jj_scan_token(LOCAL)) return true;
    if (jj_scan_token(TIME)) return true;
    if (jj_scan_token(ZONE)) return true;
    return false;
  }

  private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3_31()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_scan_token(CHARACTER)) return true;
    if (jj_scan_token(SET)) return true;
    if (jj_3R_251()) return true;
    return false;
  }

  private boolean jj_3R_538() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(221)) return true;
    }
    if (jj_scan_token(5)) return true;
    if (jj_3R_108()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_547()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_539() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(199)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) return true;
    }
    if (jj_scan_token(BY)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_108()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_548()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_394() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  private boolean jj_3R_393() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_392() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_433()) return true;
    return false;
  }

  private boolean jj_3R_464() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_382() {
    if (jj_scan_token(5)) return true;
    if (jj_scan_token(PARTITION)) return true;
    if (jj_3R_108()) return true;
    if (jj_scan_token(BY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_3R_538()) return true;
    }
    if (jj_scan_token(7)) return true;
    xsp = jj_scanpos;
    if (jj_3R_539()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(EXCEPTION)) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_111()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_392()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_393()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_394()) jj_scanpos = xsp;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_463() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_418() {
    if (jj_3R_112()) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_439()) return true;
    return false;
  }

  private boolean jj_3R_417() {
    if (jj_scan_token(INTERFACE)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(6)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_438()) jj_scanpos = xsp;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_416() {
    if (jj_scan_token(EXCEPTION_INIT)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(6)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_437()) jj_scanpos = xsp;
    if (jj_3R_111()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_436() {
    if (jj_scan_token(6)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_463()) {
    jj_scanpos = xsp;
    if (jj_3R_464()) return true;
    }
    return false;
  }

  private boolean jj_3R_415() {
    if (jj_scan_token(RESTRICT_REFERENCES)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    if (jj_3R_436()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_436()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_scan_token(SELF)) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_scan_token(RESULT)) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_scan_token(DOUBLE)) return true;
    if (jj_scan_token(PRECISION)) return true;
    return false;
  }

  private boolean jj_3R_414() {
    if (jj_scan_token(TIMESTAMP)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_342()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3_25() {
    if (jj_scan_token(INTERVAL)) return true;
    if (jj_scan_token(DAY)) return true;
    return false;
  }

  private boolean jj_3_24() {
    if (jj_scan_token(INTERVAL)) return true;
    if (jj_scan_token(YEAR)) return true;
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_scan_token(REF)) return true;
    if (jj_scan_token(CURSOR)) return true;
    return false;
  }

  private boolean jj_3R_376() {
    if (jj_scan_token(PRAGMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_3R_414()) {
    jj_scanpos = xsp;
    if (jj_3R_415()) {
    jj_scanpos = xsp;
    if (jj_3R_416()) {
    jj_scanpos = xsp;
    if (jj_3R_417()) {
    jj_scanpos = xsp;
    if (jj_3R_418()) return true;
    }
    }
    }
    }
    }
    }
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_scan_token(LONG)) return true;
    if (jj_scan_token(RAW)) return true;
    return false;
  }

  private boolean jj_3R_172() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(314)) {
    jj_scanpos = xsp;
    if (jj_3_23()) {
    jj_scanpos = xsp;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(300)) {
    jj_scanpos = xsp;
    if (jj_scan_token(301)) {
    jj_scanpos = xsp;
    if (jj_scan_token(222)) {
    jj_scanpos = xsp;
    if (jj_scan_token(238)) {
    jj_scanpos = xsp;
    if (jj_scan_token(302)) {
    jj_scanpos = xsp;
    if (jj_scan_token(303)) {
    jj_scanpos = xsp;
    if (jj_scan_token(292)) {
    jj_scanpos = xsp;
    if (jj_scan_token(293)) {
    jj_scanpos = xsp;
    if (jj_scan_token(308)) {
    jj_scanpos = xsp;
    if (jj_scan_token(309)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_3R_166()) return true;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_498() {
    if (jj_scan_token(USING)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(394)) {
    jj_scanpos = xsp;
    if (jj_scan_token(395)) return true;
    }
    return false;
  }

  private boolean jj_3R_110() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(184)) {
    jj_scanpos = xsp;
    if (jj_scan_token(185)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(186)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) {
    jj_scanpos = xsp;
    if (jj_scan_token(188)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(295)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(297)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(171)) {
    jj_scanpos = xsp;
    if (jj_scan_token(172)) {
    jj_scanpos = xsp;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(298)) {
    jj_scanpos = xsp;
    if (jj_scan_token(210)) {
    jj_scanpos = xsp;
    if (jj_scan_token(211)) {
    jj_scanpos = xsp;
    if (jj_scan_token(212)) {
    jj_scanpos = xsp;
    if (jj_scan_token(223)) {
    jj_scanpos = xsp;
    if (jj_scan_token(299)) {
    jj_scanpos = xsp;
    if (jj_scan_token(250)) {
    jj_scanpos = xsp;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(306)) {
    jj_scanpos = xsp;
    if (jj_scan_token(307)) {
    jj_scanpos = xsp;
    if (jj_scan_token(264)) {
    jj_scanpos = xsp;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_scan_token(268)) {
    jj_scanpos = xsp;
    if (jj_scan_token(269)) {
    jj_scanpos = xsp;
    if (jj_3R_174()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3_26()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_175()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(VARYING)) return true;
    if (jj_scan_token(ARRAY)) return true;
    return false;
  }

  private boolean jj_3_50() {
    if (jj_3R_126()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    return false;
  }

  private boolean jj_3R_389() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_50()) jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    xsp = jj_scanpos;
    if (jj_3R_498()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_481() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_389()) return true;
    return false;
  }

  private boolean jj_3R_346() {
    if (jj_3R_389()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_481()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_127() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(265)) {
    jj_scanpos = xsp;
    if (jj_scan_token(304)) {
    jj_scanpos = xsp;
    if (jj_3R_207()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3_22()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_3R_346()) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_scan_token(11)) return true;
    return false;
  }

  private boolean jj_3R_352() {
    if (jj_scan_token(CC_ELSE)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_scan_token(5)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_295()) jj_scanpos = xsp;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(3)) return true;
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_351() {
    if (jj_scan_token(CC_ELSIF)) return true;
    if (jj_3R_297()) return true;
    if (jj_scan_token(CC_THEN)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_126()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_304()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(CC_IF)) return true;
    if (jj_3R_297()) return true;
    if (jj_scan_token(CC_THEN)) return true;
    if (jj_3R_204()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_351()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_352()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CC_END)) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(11)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(278)) {
    jj_scanpos = xsp;
    if (jj_scan_token(240)) return true;
    }
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_scan_token(2)) return true;
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_scan_token(REF)) return true;
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_scan_token(3)) return true;
    return false;
  }

  private boolean jj_3R_262() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) jj_scanpos = xsp;
    if (jj_3R_112()) return true;
    xsp = jj_scanpos;
    if (jj_3R_300()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_301()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    }
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_3R_299()) return true;
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_3R_126()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_49()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_204() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_scan_token(21)) return true;
    if (jj_3R_126()) return true;
    if (jj_scan_token(22)) return true;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_scan_token(_DEFAULT)) return true;
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_scan_token(UNSIGNED_NUMERIC_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_289() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_scan_token(9)) return true;
    if (jj_scan_token(10)) return true;
    return false;
  }

  private boolean jj_3R_242() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) return true;
    }
    if (jj_3R_289()) return true;
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3R_241() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_286()) jj_scanpos = xsp;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_scan_token(CONSTANT)) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_3R_240()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) jj_scanpos = xsp;
    if (jj_3R_204()) return true;
    xsp = jj_scanpos;
    if (jj_3R_241()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_242()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_scan_token(A)) return true;
    if (jj_scan_token(SET)) return true;
    return false;
  }

  private boolean jj_3R_120() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_scan_token(389)) return true;
    }
    return false;
  }

  private boolean jj_3R_524() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_424()) return true;
    return false;
  }

  private boolean jj_3R_381() {
    if (jj_3R_424()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_524()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_344() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_scan_token(5)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_381()) jj_scanpos = xsp;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_239() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(277)) {
    jj_scanpos = xsp;
    if (jj_scan_token(290)) {
    jj_scanpos = xsp;
    if (jj_scan_token(371)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(315)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(338)) {
    jj_scanpos = xsp;
    if (jj_scan_token(339)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(382)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(340)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(316)) {
    jj_scanpos = xsp;
    if (jj_scan_token(306)) {
    jj_scanpos = xsp;
    if (jj_scan_token(307)) {
    jj_scanpos = xsp;
    if (jj_scan_token(388)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(343)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(383)) {
    jj_scanpos = xsp;
    if (jj_scan_token(394)) {
    jj_scanpos = xsp;
    if (jj_scan_token(314)) {
    jj_scanpos = xsp;
    if (jj_scan_token(370)) {
    jj_scanpos = xsp;
    if (jj_scan_token(369)) {
    jj_scanpos = xsp;
    if (jj_scan_token(308)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(341)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(364)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(372)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(342)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(399)) {
    jj_scanpos = xsp;
    if (jj_scan_token(344)) {
    jj_scanpos = xsp;
    if (jj_scan_token(295)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(345)) {
    jj_scanpos = xsp;
    if (jj_scan_token(374)) {
    jj_scanpos = xsp;
    if (jj_scan_token(294)) {
    jj_scanpos = xsp;
    if (jj_scan_token(346)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(389)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(347)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(375)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(134)) {
    jj_scanpos = xsp;
    if (jj_scan_token(139)) {
    jj_scanpos = xsp;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(137)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(146)) {
    jj_scanpos = xsp;
    if (jj_scan_token(148)) {
    jj_scanpos = xsp;
    if (jj_scan_token(150)) {
    jj_scanpos = xsp;
    if (jj_scan_token(151)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(392)) {
    jj_scanpos = xsp;
    if (jj_scan_token(386)) {
    jj_scanpos = xsp;
    if (jj_scan_token(366)) {
    jj_scanpos = xsp;
    if (jj_scan_token(152)) {
    jj_scanpos = xsp;
    if (jj_scan_token(361)) {
    jj_scanpos = xsp;
    if (jj_scan_token(154)) {
    jj_scanpos = xsp;
    if (jj_scan_token(311)) {
    jj_scanpos = xsp;
    if (jj_scan_token(348)) {
    jj_scanpos = xsp;
    if (jj_scan_token(349)) {
    jj_scanpos = xsp;
    if (jj_scan_token(159)) {
    jj_scanpos = xsp;
    if (jj_scan_token(160)) {
    jj_scanpos = xsp;
    if (jj_scan_token(368)) {
    jj_scanpos = xsp;
    if (jj_scan_token(161)) {
    jj_scanpos = xsp;
    if (jj_scan_token(162)) {
    jj_scanpos = xsp;
    if (jj_scan_token(163)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(166)) {
    jj_scanpos = xsp;
    if (jj_scan_token(167)) {
    jj_scanpos = xsp;
    if (jj_scan_token(170)) {
    jj_scanpos = xsp;
    if (jj_scan_token(390)) {
    jj_scanpos = xsp;
    if (jj_scan_token(362)) {
    jj_scanpos = xsp;
    if (jj_scan_token(171)) {
    jj_scanpos = xsp;
    if (jj_scan_token(300)) {
    jj_scanpos = xsp;
    if (jj_scan_token(395)) {
    jj_scanpos = xsp;
    if (jj_scan_token(309)) {
    jj_scanpos = xsp;
    if (jj_scan_token(350)) {
    jj_scanpos = xsp;
    if (jj_scan_token(173)) {
    jj_scanpos = xsp;
    if (jj_scan_token(176)) {
    jj_scanpos = xsp;
    if (jj_scan_token(351)) {
    jj_scanpos = xsp;
    if (jj_scan_token(298)) {
    jj_scanpos = xsp;
    if (jj_scan_token(301)) {
    jj_scanpos = xsp;
    if (jj_scan_token(189)) {
    jj_scanpos = xsp;
    if (jj_scan_token(192)) {
    jj_scanpos = xsp;
    if (jj_scan_token(320)) {
    jj_scanpos = xsp;
    if (jj_scan_token(194)) {
    jj_scanpos = xsp;
    if (jj_scan_token(195)) {
    jj_scanpos = xsp;
    if (jj_scan_token(200)) {
    jj_scanpos = xsp;
    if (jj_scan_token(201)) {
    jj_scanpos = xsp;
    if (jj_scan_token(203)) {
    jj_scanpos = xsp;
    if (jj_scan_token(204)) {
    jj_scanpos = xsp;
    if (jj_scan_token(365)) {
    jj_scanpos = xsp;
    if (jj_scan_token(321)) {
    jj_scanpos = xsp;
    if (jj_scan_token(206)) {
    jj_scanpos = xsp;
    if (jj_scan_token(296)) {
    jj_scanpos = xsp;
    if (jj_scan_token(214)) {
    jj_scanpos = xsp;
    if (jj_scan_token(376)) {
    jj_scanpos = xsp;
    if (jj_scan_token(218)) {
    jj_scanpos = xsp;
    if (jj_scan_token(377)) {
    jj_scanpos = xsp;
    if (jj_scan_token(221)) {
    jj_scanpos = xsp;
    if (jj_scan_token(223)) {
    jj_scanpos = xsp;
    if (jj_scan_token(224)) {
    jj_scanpos = xsp;
    if (jj_scan_token(225)) {
    jj_scanpos = xsp;
    if (jj_scan_token(227)) {
    jj_scanpos = xsp;
    if (jj_scan_token(378)) {
    jj_scanpos = xsp;
    if (jj_scan_token(230)) {
    jj_scanpos = xsp;
    if (jj_scan_token(232)) {
    jj_scanpos = xsp;
    if (jj_scan_token(233)) {
    jj_scanpos = xsp;
    if (jj_scan_token(387)) {
    jj_scanpos = xsp;
    if (jj_scan_token(235)) {
    jj_scanpos = xsp;
    if (jj_scan_token(236)) {
    jj_scanpos = xsp;
    if (jj_scan_token(238)) {
    jj_scanpos = xsp;
    if (jj_scan_token(239)) {
    jj_scanpos = xsp;
    if (jj_scan_token(237)) {
    jj_scanpos = xsp;
    if (jj_scan_token(241)) {
    jj_scanpos = xsp;
    if (jj_scan_token(242)) {
    jj_scanpos = xsp;
    if (jj_scan_token(352)) {
    jj_scanpos = xsp;
    if (jj_scan_token(243)) {
    jj_scanpos = xsp;
    if (jj_scan_token(245)) {
    jj_scanpos = xsp;
    if (jj_scan_token(353)) {
    jj_scanpos = xsp;
    if (jj_scan_token(400)) {
    jj_scanpos = xsp;
    if (jj_scan_token(247)) {
    jj_scanpos = xsp;
    if (jj_scan_token(354)) {
    jj_scanpos = xsp;
    if (jj_scan_token(251)) {
    jj_scanpos = xsp;
    if (jj_scan_token(355)) {
    jj_scanpos = xsp;
    if (jj_scan_token(356)) {
    jj_scanpos = xsp;
    if (jj_scan_token(256)) {
    jj_scanpos = xsp;
    if (jj_scan_token(357)) {
    jj_scanpos = xsp;
    if (jj_scan_token(363)) {
    jj_scanpos = xsp;
    if (jj_scan_token(391)) {
    jj_scanpos = xsp;
    if (jj_scan_token(259)) {
    jj_scanpos = xsp;
    if (jj_scan_token(258)) {
    jj_scanpos = xsp;
    if (jj_scan_token(260)) {
    jj_scanpos = xsp;
    if (jj_scan_token(358)) {
    jj_scanpos = xsp;
    if (jj_scan_token(367)) {
    jj_scanpos = xsp;
    if (jj_scan_token(266)) {
    jj_scanpos = xsp;
    if (jj_scan_token(268)) {
    jj_scanpos = xsp;
    if (jj_scan_token(269)) {
    jj_scanpos = xsp;
    if (jj_scan_token(271)) {
    jj_scanpos = xsp;
    if (jj_scan_token(273)) {
    jj_scanpos = xsp;
    if (jj_scan_token(272)) {
    jj_scanpos = xsp;
    if (jj_scan_token(270)) {
    jj_scanpos = xsp;
    if (jj_scan_token(393)) {
    jj_scanpos = xsp;
    if (jj_scan_token(275)) {
    jj_scanpos = xsp;
    if (jj_scan_token(384)) {
    jj_scanpos = xsp;
    if (jj_scan_token(385)) {
    jj_scanpos = xsp;
    if (jj_scan_token(359)) {
    jj_scanpos = xsp;
    if (jj_scan_token(379)) {
    jj_scanpos = xsp;
    if (jj_scan_token(280)) {
    jj_scanpos = xsp;
    if (jj_scan_token(303)) {
    jj_scanpos = xsp;
    if (jj_scan_token(282)) {
    jj_scanpos = xsp;
    if (jj_scan_token(304)) {
    jj_scanpos = xsp;
    if (jj_scan_token(380)) {
    jj_scanpos = xsp;
    if (jj_scan_token(305)) {
    jj_scanpos = xsp;
    if (jj_scan_token(381)) {
    jj_scanpos = xsp;
    if (jj_scan_token(310)) {
    jj_scanpos = xsp;
    if (jj_scan_token(287)) {
    jj_scanpos = xsp;
    if (jj_scan_token(313)) {
    jj_scanpos = xsp;
    if (jj_scan_token(288)) {
    jj_scanpos = xsp;
    if (jj_scan_token(360)) {
    jj_scanpos = xsp;
    if (jj_scan_token(264)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_16() {
    if (jj_scan_token(NOCOPY)) return true;
    return false;
  }

  private boolean jj_3R_280() {
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_343() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(277)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) return true;
    }
    return false;
  }

  private boolean jj_3R_495() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_279() {
    if (jj_scan_token(RETURN)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_scan_token(PROCEDURE)) return true;
    if (jj_3R_134()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_280()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_scan_token(IN)) return true;
    if (jj_scan_token(OUT)) return true;
    return false;
  }

  private boolean jj_3R_278() {
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_543() {
    if (jj_scan_token(3)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_scan_token(FUNCTION)) return true;
    if (jj_3R_134()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_278()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_279()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_542() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_494() {
    if (jj_3R_302()) return true;
    return false;
  }

  private boolean jj_3R_162() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) return true;
    }
    return false;
  }

  private boolean jj_3_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(202)) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_16()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_545() {
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_521() {
    if (jj_scan_token(3)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_523() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_543()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_420() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_419() {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_379() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_419()) {
    jj_scanpos = xsp;
    if (jj_3R_420()) return true;
    }
    return false;
  }

  private boolean jj_3R_342() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_556() {
    if (jj_scan_token(9)) return true;
    if (jj_scan_token(10)) return true;
    return false;
  }

  private boolean jj_3R_493() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_546() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_556()) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) return true;
    }
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_scan_token(135)) return true;
    }
    return false;
  }

  private boolean jj_3R_522() {
    if (jj_scan_token(3)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_541() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_scan_token(USING)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_521()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_424() {
    if (jj_3R_108()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(8)) {
    jj_scanpos = xsp;
    if (jj_3R_545()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_546()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_540() {
    if (jj_scan_token(3)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_160()) return true;
    if (jj_scan_token(BEGIN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_493()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_494()) jj_scanpos = xsp;
    if (jj_scan_token(END)) return true;
    xsp = jj_scanpos;
    if (jj_3R_495()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_108()) return true;
    if (jj_scan_token(3)) return true;
    return false;
  }

  private boolean jj_3R_294() {
    if (jj_3R_345()) return true;
    return false;
  }

  private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_3R_344()) return true;
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_scan_token(RELIES_ON)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_522()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_523()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_338() {
    if (jj_3R_382()) return true;
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_3R_343()) return true;
    return false;
  }

  private boolean jj_3R_291() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_384() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(199)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_541()) jj_scanpos = xsp;
    if (jj_scan_token(BY)) return true;
    if (jj_scan_token(5)) return true;
    if (jj_3R_108()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_542()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_238() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_285()) return true;
    }
    return false;
  }

  private boolean jj_3R_383() {
    if (jj_scan_token(USING)) return true;
    if (jj_3R_108()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_540()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_340() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_383()) {
    jj_scanpos = xsp;
    if (jj_3R_384()) return true;
    }
    return false;
  }

  private boolean jj_3R_290() {
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_250() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_290()) {
    jj_scanpos = xsp;
    if (jj_scan_token(413)) {
    jj_scanpos = xsp;
    if (jj_3R_291()) {
    jj_scanpos = xsp;
    if (jj_3R_292()) {
    jj_scanpos = xsp;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_428() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_427() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_426() {
    if (jj_scan_token(SESSIONTIMEZONE)) return true;
    return false;
  }

  private boolean jj_3R_425() {
    if (jj_scan_token(DBTIMEZONE)) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_scan_token(AGGREGATE)) return true;
    if (jj_scan_token(USING)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_scan_token(RESULT_CACHE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_341()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_scan_token(TIME)) return true;
    if (jj_scan_token(ZONE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_425()) {
    jj_scanpos = xsp;
    if (jj_3R_426()) {
    jj_scanpos = xsp;
    if (jj_3R_427()) {
    jj_scanpos = xsp;
    if (jj_3R_428()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_scan_token(PARALLEL_ENABLE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_338()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_339()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_283() {
    if (jj_scan_token(PIPELINED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_340()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_3R_256()) return true;
    return false;
  }

  private boolean jj_3R_254() {
    if (jj_scan_token(LOCAL)) return true;
    return false;
  }

  private boolean jj_3R_236() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_281()) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3R_283()) {
    jj_scanpos = xsp;
    if (jj_3R_284()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_281() {
    if (jj_scan_token(AUTHID)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) return true;
    }
    return false;
  }

  private boolean jj_3R_164() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_236()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_237()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_238()) jj_scanpos = xsp;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_scan_token(OR)) return true;
    if (jj_scan_token(REPLACE)) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(AT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) return true;
    }
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_3R_213()) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(2)) return true;
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_scan_token(CREATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_233()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_scan_token(3)) return true;
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_102() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_161()) jj_scanpos = xsp;
    if (jj_3R_162()) return true;
    xsp = jj_scanpos;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) return true;
    }
    return false;
  }

  private boolean jj_3R_119() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_48() {
    Token xsp;
    if (jj_scan_token(5)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(5)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(WITH)) return true;
    return false;
  }

  private boolean jj_3_47() {
    if (jj_scan_token(WITH)) return true;
    return false;
  }

  private boolean jj_3_46() {
    Token xsp;
    if (jj_scan_token(5)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(5)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_scan_token(6)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_480() {
    if (jj_scan_token(CC_ERROR)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(CC_END)) return true;
    return false;
  }

  private boolean jj_3_44() {
    if (jj_3R_123()) return true;
    return false;
  }

  private boolean jj_3R_479() {
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_454() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_479()) {
    jj_scanpos = xsp;
    if (jj_3R_480()) return true;
    }
    return false;
  }

  private boolean jj_3_43() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_202()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_253()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3_42() {
    if (jj_3R_121()) return true;
    return false;
  }

  private boolean jj_3R_423() {
    if (jj_scan_token(CC_ELSE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_454()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_41() {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_252()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_478() {
    if (jj_scan_token(CC_ERROR)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(CC_END)) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_scan_token(WITH)) return true;
    if (jj_3R_252()) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_scan_token(5)) return true;
    if (jj_3R_252()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_scan_token(SELECT)) return true;
    if (jj_3R_252()) return true;
    return false;
  }

  private boolean jj_3R_477() {
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_453() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_477()) {
    jj_scanpos = xsp;
    if (jj_3R_478()) return true;
    }
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_3R_251()) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_3R_123()) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_422() {
    if (jj_scan_token(CC_ELSIF)) return true;
    if (jj_3R_297()) return true;
    if (jj_scan_token(CC_THEN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_453()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_3R_121()) return true;
    return false;
  }

  private boolean jj_3R_452() {
    if (jj_scan_token(CC_ERROR)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(CC_END)) return true;
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_3R_250()) return true;
    return false;
  }

  private boolean jj_3R_451() {
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_421() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_451()) {
    jj_scanpos = xsp;
    if (jj_3R_452()) return true;
    }
    return false;
  }

  private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3R_249() {
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3R_380() {
    if (jj_scan_token(CC_IF)) return true;
    if (jj_3R_297()) return true;
    if (jj_scan_token(CC_THEN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_421()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_422()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_423()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CC_END)) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3R_179() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_40()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_336() {
    if (jj_3R_380()) return true;
    return false;
  }

  private boolean jj_3R_160() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_232()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_335() {
    if (jj_3R_379()) return true;
    return false;
  }

  private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(218)) return true;
    }
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_scan_token(NEW_DOT)) return true;
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(278)) {
    jj_scanpos = xsp;
    if (jj_scan_token(258)) return true;
    }
    if (jj_3R_104()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_3R_378()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    }
    return false;
  }

  private boolean jj_3R_333() {
    if (jj_3R_377()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_264() {
    if (jj_3R_302()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_331() {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_3R_376()) return true;
    return false;
  }

  private boolean jj_3R_519() {
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_3R_239()) return true;
    return false;
  }

  private boolean jj_3R_518() {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_433()) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_490() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_518()) {
    jj_scanpos = xsp;
    if (jj_3R_519()) return true;
    }
    return false;
  }

  private boolean jj_3R_277() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_330()) {
    jj_scanpos = xsp;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) {
    jj_scanpos = xsp;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_333()) {
    jj_scanpos = xsp;
    if (jj_3R_334()) {
    jj_scanpos = xsp;
    if (jj_3R_335()) {
    jj_scanpos = xsp;
    if (jj_3R_336()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(BEGIN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_263()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_264()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_462() {
    if (jj_3R_490()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) {
    jj_scanpos = xsp;
    if (jj_scan_token(416)) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(144)) {
    jj_scanpos = xsp;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(168)) {
    jj_scanpos = xsp;
    if (jj_scan_token(172)) {
    jj_scanpos = xsp;
    if (jj_scan_token(175)) {
    jj_scanpos = xsp;
    if (jj_scan_token(178)) {
    jj_scanpos = xsp;
    if (jj_scan_token(182)) {
    jj_scanpos = xsp;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(184)) {
    jj_scanpos = xsp;
    if (jj_scan_token(185)) {
    jj_scanpos = xsp;
    if (jj_scan_token(186)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) {
    jj_scanpos = xsp;
    if (jj_scan_token(188)) {
    jj_scanpos = xsp;
    if (jj_scan_token(190)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) {
    jj_scanpos = xsp;
    if (jj_scan_token(202)) {
    jj_scanpos = xsp;
    if (jj_scan_token(210)) {
    jj_scanpos = xsp;
    if (jj_scan_token(211)) {
    jj_scanpos = xsp;
    if (jj_scan_token(212)) {
    jj_scanpos = xsp;
    if (jj_scan_token(213)) {
    jj_scanpos = xsp;
    if (jj_scan_token(215)) {
    jj_scanpos = xsp;
    if (jj_scan_token(217)) {
    jj_scanpos = xsp;
    if (jj_scan_token(216)) {
    jj_scanpos = xsp;
    if (jj_scan_token(220)) {
    jj_scanpos = xsp;
    if (jj_scan_token(222)) {
    jj_scanpos = xsp;
    if (jj_scan_token(226)) {
    jj_scanpos = xsp;
    if (jj_scan_token(240)) {
    jj_scanpos = xsp;
    if (jj_scan_token(246)) {
    jj_scanpos = xsp;
    if (jj_scan_token(250)) {
    jj_scanpos = xsp;
    if (jj_scan_token(253)) {
    jj_scanpos = xsp;
    if (jj_scan_token(254)) {
    jj_scanpos = xsp;
    if (jj_scan_token(257)) {
    jj_scanpos = xsp;
    if (jj_scan_token(261)) {
    jj_scanpos = xsp;
    if (jj_scan_token(262)) {
    jj_scanpos = xsp;
    if (jj_scan_token(263)) {
    jj_scanpos = xsp;
    if (jj_scan_token(276)) {
    jj_scanpos = xsp;
    if (jj_scan_token(278)) {
    jj_scanpos = xsp;
    if (jj_scan_token(279)) {
    jj_scanpos = xsp;
    if (jj_scan_token(292)) {
    jj_scanpos = xsp;
    if (jj_scan_token(293)) {
    jj_scanpos = xsp;
    if (jj_scan_token(297)) {
    jj_scanpos = xsp;
    if (jj_scan_token(299)) {
    jj_scanpos = xsp;
    if (jj_scan_token(302)) {
    jj_scanpos = xsp;
    if (jj_scan_token(286)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_489() {
    if (jj_scan_token(17)) return true;
    return false;
  }

  private boolean jj_3R_488() {
    if (jj_scan_token(16)) return true;
    return false;
  }

  private boolean jj_3R_461() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_488()) {
    jj_scanpos = xsp;
    if (jj_3R_489()) return true;
    }
    if (jj_3R_433()) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_scan_token(OR)) return true;
    if (jj_scan_token(REPLACE)) return true;
    return false;
  }

  private boolean jj_3R_140() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    if (jj_3R_160()) return true;
    xsp = jj_scanpos;
    if (jj_3R_216()) jj_scanpos = xsp;
    if (jj_scan_token(END)) return true;
    xsp = jj_scanpos;
    if (jj_3R_217()) jj_scanpos = xsp;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_433() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_461()) {
    jj_scanpos = xsp;
    if (jj_3R_462()) return true;
    }
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_3R_213()) return true;
    return false;
  }

  private boolean jj_3R_531() {
    if (jj_scan_token(MOD)) return true;
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_scan_token(CREATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_215()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_530() {
    if (jj_scan_token(1)) return true;
    return false;
  }

  private boolean jj_3R_529() {
    if (jj_scan_token(20)) return true;
    return false;
  }

  private boolean jj_3R_528() {
    if (jj_scan_token(19)) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_499() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_528()) {
    jj_scanpos = xsp;
    if (jj_3R_529()) {
    jj_scanpos = xsp;
    if (jj_3R_530()) {
    jj_scanpos = xsp;
    if (jj_3R_531()) return true;
    }
    }
    }
    if (jj_3R_433()) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_3R_239()) return true;
    return false;
  }

  private boolean jj_3R_95() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(204)) {
    jj_scanpos = xsp;
    if (jj_scan_token(278)) return true;
    }
    if (jj_scan_token(BODY)) return true;
    if (jj_3R_134()) return true;
    xsp = jj_scanpos;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) return true;
    }
    return false;
  }

  private boolean jj_3R_482() {
    if (jj_3R_433()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_499()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    if (jj_3R_160()) return true;
    if (jj_scan_token(END)) return true;
    xsp = jj_scanpos;
    if (jj_3R_214()) jj_scanpos = xsp;
    if (jj_scan_token(4)) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_scan_token(OR)) return true;
    if (jj_scan_token(REPLACE)) return true;
    return false;
  }

  private boolean jj_3R_126() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) {
    jj_scanpos = xsp;
    if (jj_scan_token(416)) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(168)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) {
    jj_scanpos = xsp;
    if (jj_scan_token(217)) {
    jj_scanpos = xsp;
    if (jj_scan_token(222)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(302)) {
    jj_scanpos = xsp;
    if (jj_scan_token(252)) {
    jj_scanpos = xsp;
    if (jj_scan_token(253)) {
    jj_scanpos = xsp;
    if (jj_scan_token(254)) {
    jj_scanpos = xsp;
    if (jj_scan_token(263)) {
    jj_scanpos = xsp;
    if (jj_scan_token(278)) {
    jj_scanpos = xsp;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(297)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_3R_213()) return true;
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_scan_token(18)) return true;
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(AUTHID)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) return true;
    }
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_scan_token(CREATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_3R_117()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_257()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_94() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_133()) jj_scanpos = xsp;
    if (jj_scan_token(PACKAGE)) return true;
    if (jj_3R_134()) return true;
    xsp = jj_scanpos;
    if (jj_3R_135()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) return true;
    }
    return false;
  }

  private boolean jj_3R_502() {
    if (jj_scan_token(18)) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_scan_token(DECLARE)) return true;
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_501() {
    if (jj_scan_token(17)) return true;
    return false;
  }

  private boolean jj_3R_500() {
    if (jj_scan_token(16)) return true;
    return false;
  }

  private boolean jj_3R_483() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_500()) {
    jj_scanpos = xsp;
    if (jj_3R_501()) {
    jj_scanpos = xsp;
    if (jj_3R_502()) return true;
    }
    }
    if (jj_3R_482()) return true;
    return false;
  }

  private boolean jj_3R_411() {
    if (jj_3R_302()) return true;
    return false;
  }

  private boolean jj_3R_456() {
    if (jj_3R_482()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_483()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_410() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_517() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_516() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_7() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_100()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_101()) jj_scanpos = xsp;
    if (jj_scan_token(BEGIN)) return true;
    return false;
  }

  private boolean jj_3R_409() {
    if (jj_scan_token(DECLARE)) return true;
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_487() {
    if (jj_scan_token(ESCAPE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_516()) {
    jj_scanpos = xsp;
    if (jj_3R_517()) return true;
    }
    return false;
  }

  private boolean jj_3R_370() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_409()) jj_scanpos = xsp;
    if (jj_scan_token(BEGIN)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_410()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_411()) jj_scanpos = xsp;
    if (jj_scan_token(END)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_537() {
    if (jj_scan_token(ALL)) return true;
    return false;
  }

  private boolean jj_3R_536() {
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3R_515() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_536()) {
    jj_scanpos = xsp;
    if (jj_3R_537()) return true;
    }
    return false;
  }

  private boolean jj_3R_514() {
    if (jj_scan_token(UNION)) return true;
    return false;
  }

  private boolean jj_3R_513() {
    if (jj_scan_token(INTERSECT)) return true;
    return false;
  }

  private boolean jj_3R_512() {
    if (jj_scan_token(EXCEPT)) return true;
    return false;
  }

  private boolean jj_3R_535() {
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3R_486() {
    if (jj_scan_token(MULTISET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_512()) {
    jj_scanpos = xsp;
    if (jj_3R_513()) {
    jj_scanpos = xsp;
    if (jj_3R_514()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_515()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_534() {
    if (jj_scan_token(SUBMULTISET)) return true;
    return false;
  }

  private boolean jj_3R_533() {
    if (jj_scan_token(MEMBER)) return true;
    return false;
  }

  private boolean jj_3R_511() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_533()) {
    jj_scanpos = xsp;
    if (jj_3R_534()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_535()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_510() {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3R_509() {
    if (jj_scan_token(LIKE)) return true;
    return false;
  }

  private boolean jj_3R_508() {
    if (jj_scan_token(BETWEEN)) return true;
    return false;
  }

  private boolean jj_3R_507() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_532() {
    if (jj_scan_token(15)) return true;
    return false;
  }

  private boolean jj_3R_506() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3R_505() {
    if (jj_scan_token(10)) return true;
    return false;
  }

  private boolean jj_3R_504() {
    if (jj_scan_token(15)) return true;
    return false;
  }

  private boolean jj_3R_485() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_506()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_507()) {
    jj_scanpos = xsp;
    if (jj_3R_508()) {
    jj_scanpos = xsp;
    if (jj_3R_509()) {
    jj_scanpos = xsp;
    if (jj_3R_510()) {
    jj_scanpos = xsp;
    if (jj_3R_511()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_503() {
    if (jj_scan_token(14)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_532()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_484() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_503()) {
    jj_scanpos = xsp;
    if (jj_3R_504()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_505()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_457() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_484()) {
    jj_scanpos = xsp;
    if (jj_3R_485()) {
    jj_scanpos = xsp;
    if (jj_3R_486()) return true;
    }
    }
    if (jj_3R_456()) return true;
    xsp = jj_scanpos;
    if (jj_3R_487()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_431() {
    if (jj_3R_456()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_457()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_460() {
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_459() {
    if (jj_scan_token(13)) return true;
    if (jj_scan_token(10)) return true;
    return false;
  }

  private boolean jj_3R_458() {
    if (jj_scan_token(10)) return true;
    return false;
  }

  private boolean jj_3R_432() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_458()) {
    jj_scanpos = xsp;
    if (jj_3R_459()) {
    jj_scanpos = xsp;
    if (jj_3R_460()) return true;
    }
    }
    if (jj_3R_431()) return true;
    return false;
  }

  private boolean jj_3R_390() {
    if (jj_3R_431()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_432()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_391() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_390()) return true;
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_3R_390()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_391()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_99()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_98()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_348() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_347()) return true;
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_3R_347()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_348()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(3)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(AT)) return true;
    if (jj_scan_token(TIME)) return true;
    if (jj_scan_token(ZONE)) return true;
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_123() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(383)) {
    jj_scanpos = xsp;
    if (jj_scan_token(384)) return true;
    }
    if (jj_scan_token(5)) return true;
    if (jj_3R_202()) return true;
    xsp = jj_scanpos;
    if (jj_3R_203()) jj_scanpos = xsp;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_204()) return true;
    if (jj_scan_token(7)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_205()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_3R_198()) return true;
    return false;
  }

  private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(392)) {
    jj_scanpos = xsp;
    if (jj_scan_token(393)) {
    jj_scanpos = xsp;
    if (jj_scan_token(388)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_scan_token(TRIM)) return true;
    if (jj_scan_token(5)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_196()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_197()) jj_scanpos = xsp;
    if (jj_scan_token(FROM)) return true;
    if (jj_3R_198()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_3R_239()) return true;
    return false;
  }

  private boolean jj_3R_108() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(408)) {
    jj_scanpos = xsp;
    if (jj_scan_token(416)) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(133)) {
    jj_scanpos = xsp;
    if (jj_scan_token(135)) {
    jj_scanpos = xsp;
    if (jj_scan_token(136)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(144)) {
    jj_scanpos = xsp;
    if (jj_scan_token(145)) {
    jj_scanpos = xsp;
    if (jj_scan_token(147)) {
    jj_scanpos = xsp;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(153)) {
    jj_scanpos = xsp;
    if (jj_scan_token(155)) {
    jj_scanpos = xsp;
    if (jj_scan_token(156)) {
    jj_scanpos = xsp;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(164)) {
    jj_scanpos = xsp;
    if (jj_scan_token(168)) {
    jj_scanpos = xsp;
    if (jj_scan_token(169)) {
    jj_scanpos = xsp;
    if (jj_scan_token(172)) {
    jj_scanpos = xsp;
    if (jj_scan_token(175)) {
    jj_scanpos = xsp;
    if (jj_scan_token(178)) {
    jj_scanpos = xsp;
    if (jj_scan_token(179)) {
    jj_scanpos = xsp;
    if (jj_scan_token(180)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) {
    jj_scanpos = xsp;
    if (jj_scan_token(182)) {
    jj_scanpos = xsp;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(188)) {
    jj_scanpos = xsp;
    if (jj_scan_token(190)) {
    jj_scanpos = xsp;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(193)) {
    jj_scanpos = xsp;
    if (jj_scan_token(184)) {
    jj_scanpos = xsp;
    if (jj_scan_token(185)) {
    jj_scanpos = xsp;
    if (jj_scan_token(186)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) {
    jj_scanpos = xsp;
    if (jj_scan_token(197)) {
    jj_scanpos = xsp;
    if (jj_scan_token(198)) {
    jj_scanpos = xsp;
    if (jj_scan_token(199)) {
    jj_scanpos = xsp;
    if (jj_scan_token(202)) {
    jj_scanpos = xsp;
    if (jj_scan_token(207)) {
    jj_scanpos = xsp;
    if (jj_scan_token(210)) {
    jj_scanpos = xsp;
    if (jj_scan_token(211)) {
    jj_scanpos = xsp;
    if (jj_scan_token(212)) {
    jj_scanpos = xsp;
    if (jj_scan_token(215)) {
    jj_scanpos = xsp;
    if (jj_scan_token(217)) {
    jj_scanpos = xsp;
    if (jj_scan_token(216)) {
    jj_scanpos = xsp;
    if (jj_scan_token(219)) {
    jj_scanpos = xsp;
    if (jj_scan_token(220)) {
    jj_scanpos = xsp;
    if (jj_scan_token(222)) {
    jj_scanpos = xsp;
    if (jj_scan_token(226)) {
    jj_scanpos = xsp;
    if (jj_scan_token(240)) {
    jj_scanpos = xsp;
    if (jj_scan_token(244)) {
    jj_scanpos = xsp;
    if (jj_scan_token(246)) {
    jj_scanpos = xsp;
    if (jj_scan_token(249)) {
    jj_scanpos = xsp;
    if (jj_scan_token(250)) {
    jj_scanpos = xsp;
    if (jj_scan_token(252)) {
    jj_scanpos = xsp;
    if (jj_scan_token(253)) {
    jj_scanpos = xsp;
    if (jj_scan_token(254)) {
    jj_scanpos = xsp;
    if (jj_scan_token(255)) {
    jj_scanpos = xsp;
    if (jj_scan_token(257)) {
    jj_scanpos = xsp;
    if (jj_scan_token(261)) {
    jj_scanpos = xsp;
    if (jj_scan_token(262)) {
    jj_scanpos = xsp;
    if (jj_scan_token(263)) {
    jj_scanpos = xsp;
    if (jj_scan_token(265)) {
    jj_scanpos = xsp;
    if (jj_scan_token(267)) {
    jj_scanpos = xsp;
    if (jj_scan_token(274)) {
    jj_scanpos = xsp;
    if (jj_scan_token(276)) {
    jj_scanpos = xsp;
    if (jj_scan_token(278)) {
    jj_scanpos = xsp;
    if (jj_scan_token(279)) {
    jj_scanpos = xsp;
    if (jj_scan_token(291)) {
    jj_scanpos = xsp;
    if (jj_scan_token(292)) {
    jj_scanpos = xsp;
    if (jj_scan_token(293)) {
    jj_scanpos = xsp;
    if (jj_scan_token(297)) {
    jj_scanpos = xsp;
    if (jj_scan_token(299)) {
    jj_scanpos = xsp;
    if (jj_scan_token(302)) {
    jj_scanpos = xsp;
    if (jj_scan_token(312)) {
    jj_scanpos = xsp;
    if (jj_scan_token(286)) {
    jj_scanpos = xsp;
    if (jj_scan_token(420)) {
    jj_scanpos = xsp;
    if (jj_scan_token(417)) {
    jj_scanpos = xsp;
    if (jj_scan_token(418)) {
    jj_scanpos = xsp;
    if (jj_scan_token(419)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_3R_202()) return true;
    if (jj_scan_token(THEN)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_scan_token(CASE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_199()) jj_scanpos = xsp;
    if (jj_3R_200()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_200()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_201()) jj_scanpos = xsp;
    if (jj_scan_token(END)) return true;
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_3R_117()) return true;
    if (jj_scan_token(9)) return true;
    if (jj_scan_token(10)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_350() {
    if (jj_scan_token(CC_ELSE)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_349() {
    if (jj_scan_token(CC_ELSIF)) return true;
    if (jj_3R_297()) return true;
    if (jj_scan_token(CC_THEN)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_298() {
    if (jj_scan_token(CC_IF)) return true;
    if (jj_3R_297()) return true;
    if (jj_scan_token(CC_THEN)) return true;
    if (jj_3R_202()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_349()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_350()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CC_END)) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_3R_117()) return true;
    if (jj_scan_token(9)) return true;
    if (jj_scan_token(10)) return true;
    return false;
  }

  private boolean jj_3R_260() {
    if (jj_3R_298()) return true;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_3R_297()) return true;
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_3R_296()) return true;
    return false;
  }

  private boolean jj_3R_202() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_258()) {
    jj_scanpos = xsp;
    if (jj_3R_259()) {
    jj_scanpos = xsp;
    if (jj_3R_260()) return true;
    }
    }
    return false;
  }

  /** Generated Token Manager. */
  public PLSQLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[403];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static private int[] jj_la1_8;
  static private int[] jj_la1_9;
  static private int[] jj_la1_10;
  static private int[] jj_la1_11;
  static private int[] jj_la1_12;
  static private int[] jj_la1_13;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
      jj_la1_init_6();
      jj_la1_init_7();
      jj_la1_init_8();
      jj_la1_init_9();
      jj_la1_init_10();
      jj_la1_init_11();
      jj_la1_init_12();
      jj_la1_init_13();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xc,0x0,0xc,0x2,0xc,0x0,0x230020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x230020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x8,0x0,0x8,0x0,0x0,0x40,0x0,0x0,0x8,0x40,0x8,0x0,0x0,0x0,0x0,0x230020,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x100,0x200,0x200,0x0,0x20,0x0,0x20,0x0,0x40,0x0,0x0,0x0,0x200,0x200,0x4,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x230020,0x230020,0x0,0x0,0x10,0x30020,0x230020,0x200000,0x30020,0x0,0x0,0x0,0x230020,0x230020,0x230020,0x230020,0x0,0x0,0x1000,0x230020,0x0,0x230020,0x0,0x230020,0x0,0x0,0x0,0x1000,0x30020,0x0,0x30020,0x0,0x0,0x0,0x0,0x0,0x30020,0x40,0x0,0x0,0x0,0x40,0x0,0x230020,0x0,0x230020,0x0,0x230020,0x0,0x20,0x20,0x0,0x0,0x0,0x40,0x40,0x0,0x20,0x0,0x0,0x0,0x40,0x20,0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x20,0x0,0x20,0x0,0x30020,0x0,0x0,0x30020,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x20,0x0,0x0,0x8,0x0,0x0,0x2400,0x2400,0xc000,0x8000,0xc000,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,0x0,0x0,0x70000,0x70000,0x40000,0x180002,0x180002,0x30000,0x30020,0x20,0x20,0x20,0x40,0x0,0x0,0x20,0x30020,0x0,0x2c,0x0,0x0,0x0,0x808,0x8,0x30020,0x40,0x800000,0x0,0x0,0x0,0x40,0x30000,0x30000,0x40,0x0,0x0,0x40,0x0,0x0,0x40,0x0,0x0,0x40,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x20,0x12,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x230020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x12,0x0,0x12,0x12,0x40,0x40,0x0,0x20,0x40,0x80,0x0,0x0,0x20,0x40,0x80,0x0,0x0,0x40,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x30000,0x30000,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x230020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1004000,0x0,0x1004000,0x0,0x0,0x0,0xa9721c38,0x0,0x0,0x0,0x0,0x30,0x400000,0x40000,0xfefffff8,0x40000,0x0,0x0,0x0,0x40000,0xa9721c38,0x0,0x1000000,0xfefffff8,0x40000,0x0,0x0,0xfefffff8,0xfefffff8,0xfefffff8,0x0,0xfefffff8,0xfefffff8,0x0,0xfefffff8,0xfefffff8,0x0,0x0,0x400000,0x30,0x0,0x0,0x0,0x0,0x0,0xfefffff8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x1000,0x40000,0xa9721c38,0x0,0xfefffff8,0xfffffff8,0x40000,0x441000,0x0,0x0,0xbc721c38,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfefffff8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa8721c38,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x14000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa9721c38,0xa9721c38,0x0,0x0,0x0,0xa9721c38,0xa9721c38,0x0,0xa8721c38,0x0,0x0,0x0,0xa9721c38,0xa9721c38,0xa9721c38,0xa9721c38,0x0,0x0,0x0,0xa9721c38,0x0,0xa9721c38,0x0,0xa9721c38,0x0,0x0,0x0,0x0,0xa8721c38,0x0,0xa8721c38,0xa8721c38,0x0,0xa8721c38,0x0,0xa8721c38,0xa8721c38,0x0,0x0,0x0,0x20000000,0x0,0x0,0xa9721c38,0x0,0xa9721c38,0x0,0xa9721c38,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbc721c38,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa8721c38,0x0,0x0,0xa8721c38,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa8721c38,0x0,0x100000,0x0,0x0,0x8000,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x2000,0x2000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa8721c38,0xa8721c38,0xa8721c38,0xa8721c38,0x0,0x0,0xa8721c38,0x0,0xa8721c38,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0xa8721c38,0x0,0x40000,0x0,0x0,0xfefffff8,0x0,0x0,0x0,0x0,0xa8721ff8,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0xa9721c38,0x0,0xfefffff8,0xfffffff8,0x40000,0x0,0x0,0x30,0x40000,0x40000,0x0,0x0,0x0,0x40000,0x0,0x40000,0x0,0xfefffff8,0xfefffff8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x4000,0x0,0x0,0x800,0x0,0x800,0x0,0x0,0x0,0x200000,0x200000,0x0,0x0,0x0,0x200000,0x200000,0x800,0x30,0x40000,0xfefffff8,0x0,0xfefffff8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfefffff8,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x4000,0x0,0xfefffff8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0xa9721c38,0x0,0x0,0xfefffff8,0x0,0x0,0xfefffff8,0x0,0x4000,0x0,0x4000,0xfefffff8,0x4000,0x0,0x4000,0x420de000,0xa0701c30,0xfefffff8,0xa8721c38,0xbcf21ff8,0x14420000,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x12042e00,0x10000800,0x12042e00,0x0,0x2600,0x2000000,0x936b8fa3,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0xbfffffff,0x0,0x0,0x40000,0x0,0x0,0x936b8fa3,0x0,0x0,0xbfffffff,0x0,0x0,0x248000,0xbfffffff,0xbfffffff,0xbfffffff,0x0,0xbfffffff,0xbfffffff,0x0,0xbfffffff,0xbfffffff,0x0,0x40000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x40,0xbfffffff,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x936b8fa3,0x0,0xbfffffff,0xbfffffff,0x0,0x40000000,0x0,0x0,0x85eb8fad,0x8000000,0x8000000,0x48000,0x0,0x0,0x0,0x0,0x0,0xbfffffff,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x816b8fa1,0x0,0x0,0x0,0x0,0x4,0x0,0x4,0x0,0x480000c,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x1000000,0x1000000,0x0,0x1000000,0x0,0x0,0x0,0x936b8fa3,0x936b8fa3,0x0,0x10000800,0x0,0x836b8fa3,0x936b8fa3,0x0,0x816b8fa3,0x0,0x0,0x0,0x936b8fa3,0x936b8fa3,0x936b8fa3,0x936b8fa3,0x0,0x0,0x0,0x936b8fa3,0x0,0x936b8fa3,0x0,0x936b8fa3,0x0,0x0,0x0,0x0,0x816b8fa3,0x0,0x816b8fa3,0x816b8fa1,0x0,0x816b8fa1,0x0,0x816b8fa1,0x816b8fa3,0x0,0x0,0x0,0x0,0x0,0x0,0x936b8fa3,0x0,0x936b8fa3,0x0,0x936b8fa3,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x85eb8fad,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x816b8fa3,0x0,0x0,0x816b8fa3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x816b8fa3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x816b8fa3,0x816b8fa3,0x816b8fa3,0x816b8fa3,0x0,0x0,0x816b8fa1,0x0,0x816b8fa3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x816b8fa3,0x0,0x0,0x0,0x0,0xbfffffff,0x0,0x0,0x0,0x0,0x816b8fa1,0x0,0x0,0x0,0x40,0x0,0x40,0x0,0x0,0x10000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x936b8fa3,0x0,0xbfffffff,0xbfffffff,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbfffffff,0xbfffffff,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0xbfffffff,0x0,0xbfffffff,0x0,0x0,0x0,0x0,0x20000,0x0,0x20000,0x0,0x0,0x1,0x1,0xbfffffff,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x10000000,0x0,0x10040400,0x0,0x10000000,0x0,0x10040400,0x0,0xbfffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0x2000000,0x0,0x0,0x936b8fa3,0x0,0x0,0xbfffffff,0x0,0x240000,0xbfffffff,0x0,0x40400,0x0,0x40400,0xbfffffff,0x40400,0x0,0x40400,0x3c843054,0x816b8fa1,0xbfffffff,0x816b8fa1,0x95fbcfad,0x490000c,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x8800a004,0x0,0x8800a004,0x0,0x8000a004,0x0,0x3bbfab48,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffff7f,0x0,0x0,0x0,0x0,0x0,0x3bbfab48,0x400,0x0,0x7fffff7f,0x0,0x0,0x8200000,0x7fffff7f,0x7fffff7f,0x7fffff7f,0x0,0x7fffff7f,0x7fffff7f,0x0,0x7fffff7f,0x7fffff7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffff7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bbfab48,0x400,0x7fffff7f,0x7fffff7f,0x0,0x0,0x0,0x0,0x1a6f8b48,0x0,0x0,0x8200000,0x0,0x0,0x0,0x8000000,0x0,0x7fffff7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a2f8b48,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bbfab48,0x3bbfab48,0x0,0x2000,0x0,0x3bbfab48,0x3bbfab48,0x0,0x1a2f8b48,0x0,0x10,0x0,0x3bbfab48,0x3bbfab48,0x3bbfab48,0x3bbfab48,0x0,0x0,0x0,0x3bbfab48,0x0,0x3bbfab48,0x0,0x3bbfab48,0x20,0x10,0x0,0x0,0x1a2f8b48,0x0,0x1a2f8b48,0x1a2f8b48,0x0,0x1a2f8b48,0x0,0x1a2f8b48,0x1a2f8b48,0x0,0x0,0x800000,0x0,0x0,0x0,0x3bbfab48,0x0,0x3bbfab48,0x0,0x3bbfab48,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a6f8b48,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a2f8b48,0x0,0x0,0x1a2f8b48,0x0,0x10,0x0,0x100,0x0,0x0,0x0,0x1a2f8b48,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x200,0x1,0x1,0x4000000,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x1a2f8b48,0x1a2f8b48,0x1a2f8b48,0x1a2f8b48,0x0,0x80000,0x1a2f8b48,0x0,0x1a2f8b48,0x0,0x0,0x80000,0x80000,0x0,0x0,0x0,0x1a2f8b48,0x0,0x0,0x0,0x0,0x7fffff7f,0x0,0x0,0x0,0x0,0x1a2f8b48,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bbfab48,0x400,0x7fffff7f,0x7fffff7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffff7f,0x7fffff7f,0x0,0x200000,0x0,0x0,0x200000,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x200008,0x200008,0x0,0x0,0x0,0x200000,0x200000,0x4,0x0,0x0,0x7fffff7f,0x0,0x7fffff7f,0x0,0x200000,0x0,0x200000,0x0,0x0,0x0,0x2000000,0x2000800,0x0,0x0,0x7fffff7f,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x80000004,0x0,0x0,0x0,0x80000004,0x0,0x7fffff7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x3bbfab48,0x0,0x0,0x7fffff7f,0x0,0x8000000,0x7fffff7f,0x0,0x80000004,0x0,0x80000004,0x7fffff7f,0x80000004,0x0,0x80000004,0xc4c05015,0x1a2f8b48,0x7fffff7f,0x1a2f8b48,0x1b6feb6a,0x400000,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x10002000,0x10002000,0x10002000,0x0,0x0,0x0,0xd5d47a6d,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0xfffffbef,0x200000,0x0,0x0,0x0,0x200000,0xd5d47a6d,0x0,0x0,0xfffffbef,0x200000,0x0,0x80004000,0xfffffbef,0xfffffbef,0xfffffbef,0x0,0xfffffbef,0xfffffbef,0x0,0xfffffbef,0xfffffbef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffffbef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0xd5d47a6d,0x0,0xfffffbef,0xfffffbef,0x200000,0x200000,0x80,0x80,0xe5d4da4d,0x0,0x0,0x80004000,0x0,0x0,0x0,0x0,0x0,0xfffffbef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5d45a4d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20008000,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x8,0x8,0x0,0x8,0x0,0x0,0x0,0xd5d47a6d,0xd5d47a6d,0x0,0x10002000,0x0,0xc5d45a6d,0xd5d47a6d,0x0,0xc5d45a4d,0x0,0x0,0x0,0xd5d47a6d,0xd5d47a6d,0xd5d47a6d,0xd5d47a6d,0x0,0x0,0x0,0xd5d47a6d,0x0,0xd5d47a6d,0x0,0xd5d47a6d,0x0,0x0,0x200,0x0,0xc5d45a4d,0x0,0xc5d45a4d,0xc5d45a4d,0x0,0xc5d45a4d,0x0,0xc5d45a4d,0xc5d45a4d,0x0,0x0,0x0,0x0,0x0,0x4000000,0xd5d47a6d,0x0,0xd5d47a6d,0x0,0xd5d47a6d,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0xe5d4da4d,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0xc5d45a4d,0x0,0x0,0xc5d45a4d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5d45a4d,0x0,0x0,0x0,0x0,0x0,0x200000,0x200000,0x2000080,0x0,0x0,0x0,0x0,0x0,0x0,0x2000080,0x20000,0x0,0x0,0x2000080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5d45a4d,0xc5d45a4d,0xc5d45a4d,0xc5d45a4d,0x0,0x40000,0xc5d45a4d,0x0,0xc5d45a4d,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0xc5d45a4d,0x0,0x0,0x0,0x0,0xfffffbef,0x0,0x0,0x0,0x0,0xc5d55a4d,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x0,0x4000,0x0,0x4000,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0xd5d47a6d,0x0,0xfffffbef,0xfffffbef,0x200000,0x0,0x0,0x0,0x200000,0x200000,0x0,0x0,0x0,0x200000,0x0,0x200000,0x0,0xfffffbef,0xfffffbef,0x0,0x80004000,0x0,0x0,0x4000,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x84004000,0x84004000,0x0,0x0,0x0,0x80004000,0x80004000,0x0,0x0,0x200000,0xfffffbef,0x0,0xfffffbef,0x0,0x4000,0x0,0x4000,0x400,0x0,0x400,0x0,0x0,0x100000,0x100000,0xfffffbef,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x2000,0x0,0x2000,0x0,0x2000,0x0,0x2000,0x0,0xfffffbef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd5d47a6d,0x0,0x0,0xfffffbef,0x0,0x0,0xfffffbef,0x0,0x0,0x0,0x0,0xfffffbef,0x0,0x0,0x0,0x322aa192,0x85d45a4d,0xfffffbef,0xc5d45a4d,0xe5d5da4d,0x20048008,0x0,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x4,0x4,0x4,0x0,0x0,0x0,0x20296def,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffdbfff,0x0,0x0,0x0,0x0,0x0,0x20296def,0x0,0x0,0xfffdbfff,0x0,0x0,0x80002,0xfffdbfff,0xfffdbfff,0xfffdbfff,0x0,0xfffdbfff,0xfffdbfff,0x0,0xfffdbfff,0xfffdbfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffdbfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20296def,0x0,0xfffdbfff,0xfffdbfff,0x0,0x0,0x0,0x0,0x3f813def,0x0,0x0,0x80002,0x0,0x0,0x0,0x0,0x0,0xfffdbfff,0x80000,0x280000,0x0,0x0,0x0,0x0,0x0,0x0,0x20012def,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f801800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x420,0x420,0x0,0x420,0x0,0x0,0x0,0x20296def,0x20296def,0x0,0x4,0x0,0x20296def,0x20296def,0x0,0x20296def,0x0,0x0,0x0,0x20296def,0x20296def,0x20296def,0x20296def,0x0,0x0,0x0,0x20296def,0x0,0x20296def,0x0,0x20296def,0x0,0x0,0x0,0x0,0x20296def,0x0,0x20296def,0x20012def,0x0,0x20012def,0x0,0x20012def,0x20296def,0x0,0x0,0x0,0x0,0x0,0x0,0x20296def,0x0,0x20296def,0x0,0x20296def,0x0,0x0,0x0,0x80000,0x0,0x1f000000,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x3f813def,0x0,0x80000,0x280000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20296def,0x0,0x0,0x20296def,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20216def,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80002,0x0,0x0,0x0,0x80000,0x2,0x80000000,0x2,0x0,0x0,0x0,0x80002,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x20296def,0x20296def,0x20212def,0x20216def,0x0,0x200000,0x20012def,0x0,0x20296def,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x20296def,0x0,0x0,0x0,0x0,0xfffdbfff,0x0,0x0,0x0,0x0,0x20012def,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x280000,0x0,0x10000,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x80000,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x20296def,0x0,0xfffdbfff,0xfffdbfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffdbfff,0xfffdbfff,0x0,0x80002,0x0,0x0,0x280000,0x80000,0x200000,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x80002,0x80002,0x0,0x0,0x0,0x80002,0x80002,0x80,0x0,0x0,0xfffdbfff,0x0,0xfffdbfff,0x0,0x280000,0x80000,0x200000,0x80000,0x80000,0x80000,0x0,0x0,0x0,0x0,0xfffdbfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffdbfff,0x2000,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20296def,0x0,0x0,0xfffdbfff,0x0,0x0,0xfffdbfff,0x0,0x0,0x0,0x0,0xfffdbfff,0x0,0x0,0x0,0x80ba0210,0x20012cef,0xfffdbfff,0x20012def,0x7fc5bdef,0x5f801c40,0x0,};
   }
   private static void jj_la1_init_6() {
      jj_la1_6 = new int[] {0x5001000,0x0,0x5000000,0x0,0x1000000,0x0,0xf6415b1d,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0xffdcdfff,0x0,0x40,0x0,0x1000,0x0,0xf6415b1d,0x0,0x0,0xffdcdfff,0x0,0x200000,0x4000880,0xfffcdfff,0xfffcdfff,0xfffcdfff,0x0,0xfffcdfff,0xfffcdfff,0x0,0xfffcdfff,0xfffcdfff,0x40,0x0,0x22000,0x0,0x0,0x0,0x0,0x0,0x80,0xffdcdfff,0x0,0x80,0x80,0x0,0x0,0x0,0x0,0x22000,0x0,0x0,0xf6415b1d,0x0,0xffdcdfff,0xfffcdfff,0x0,0x22000,0x400,0x0,0xe65c5b1d,0x0,0x0,0x4000880,0x0,0x0,0x0,0x4000000,0x0,0xffdcdfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6405b1d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0xc01c0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0xf6415b1d,0xf6415b1d,0x0,0x0,0x0,0xf6415b1d,0xf6415b1d,0x0,0xe6405b1d,0x0,0x0,0x0,0xf6415b1d,0xf6415b1d,0xf6415b1d,0xf6415b1d,0x0,0x0,0x0,0xf6415b1d,0x0,0xf6415b1d,0x0,0xf6415b1d,0x0,0x0,0x0,0x0,0xe6405b1d,0x0,0xe6405b1d,0xe6405b1d,0x0,0xe6405b1d,0x0,0xe6405b1d,0xe6405b1d,0x0,0x0,0x0,0x0,0x0,0x0,0xf6415b1d,0x0,0xf6415b1d,0x0,0xf6415b1d,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe65c5b1d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6405b1d,0x0,0x0,0xe6405b1d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6405b1d,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6405b1d,0xe6405b1d,0xe6405b1d,0xe6405b1d,0x0,0x0,0xe6405b1d,0x0,0xe6405b1d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6405b1d,0x0,0x0,0x0,0x0,0xffdcdfff,0x0,0x0,0x0,0x0,0xe6405b1d,0x20000000,0x0,0x20000000,0x80,0x0,0x80,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x10,0x10,0x0,0x800,0x0,0x800,0x80,0x80,0x0,0x0,0x2000,0x20000,0x0,0x0,0x0,0xf6415b1d,0x0,0xffdcdfff,0xfffcdfff,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffcdfff,0xfffcdfff,0x0,0x880,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x880,0x880,0x0,0x0,0x0,0x880,0x880,0x0,0x0,0x0,0xffdcdfff,0x0,0xffdcdfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdcdfff,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0xffdcdfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf6415b1d,0x0,0x0,0xfffcdfff,0x200000,0x4000000,0xffdcdfff,0x0,0x0,0x40,0x0,0xffdcdfff,0x0,0x0,0x0,0x488080e2,0xa4405b0d,0xffdcdfff,0xe6405b1d,0xf7fc5f1d,0xc01c0000,0x0,};
   }
   private static void jj_la1_init_7() {
      jj_la1_7 = new int[] {0x80940c00,0x140800,0x80940c00,0x0,0x80800400,0x0,0x78befb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfefffb4f,0x0,0x0,0x0,0x0,0x0,0x78befb4b,0x0,0x0,0xfefffb4f,0x0,0x0,0x0,0xfefffb4f,0xfefffb4f,0xfefffb4f,0x0,0xfefffb4f,0xfefffb4f,0x0,0xfefffb4f,0xfefffb4f,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0xfefffb4f,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x80,0x0,0x0,0x78befb4b,0x0,0xfefffb4f,0xfefffb4f,0x0,0x80,0x0,0x0,0x7caefb4b,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0xfefffb4f,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x78aefb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x4004002,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x80000,0x0,0x80000,0x0,0x0,0x0,0x78befb4b,0x78befb4b,0x0,0x940800,0x0,0x78befb4b,0x78befb4b,0x0,0x78befb4b,0x0,0x0,0x0,0x78befb4b,0x78befb4b,0x78befb4b,0x78befb4b,0x0,0x200,0x0,0x78befb4b,0x0,0x78befb4b,0x0,0x78befb4b,0x0,0x0,0x0,0x0,0x78befb4b,0x20000,0x78befb4b,0x78aefb4b,0x0,0x78aefb4b,0x0,0x78aefb4b,0x78befb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x78befb4b,0x0,0x78befb4b,0x0,0x78befb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x7caefb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x78befb4b,0x0,0x0,0x78befb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78befb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78befb4b,0x78befb4b,0x78befb4b,0x78befb4b,0x0,0x0,0x78aefb4b,0x0,0x78befb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78befb4b,0x0,0x0,0x0,0x0,0xfefffb4f,0x0,0x0,0x0,0x0,0x78aefb4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x78befb4b,0x0,0xfefffb4f,0xfefffb4f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfefffb4f,0xfefffb4f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfefffb4f,0x0,0xfefffb4f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfefffb4f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x410,0x0,0x0,0x0,0x410,0x0,0xfefffb4f,0x0,0x0,0x0,0x0,0x200,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78befb4b,0x0,0x0,0xfefffb4f,0x0,0x0,0xfefffb4f,0x0,0x410,0x0,0x410,0xfefffb4f,0x410,0x0,0x410,0x87900430,0x8aefb4b,0xfefffb4f,0x78aefb4b,0x6ceffb4f,0x489d003,0x0,};
   }
   private static void jj_la1_init_8() {
      jj_la1_8 = new int[] {0x500000,0x0,0x0,0x0,0x0,0x0,0xc56bf59d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5ffffff,0x0,0x0,0x0,0x400000,0x0,0xc56bf59d,0x0,0x0,0xc5ffffff,0x0,0x0,0x1,0xc5ffffff,0xc5ffffff,0xc5ffffff,0x0,0xc5ffffff,0xc5ffffff,0x0,0xc5ffffff,0xc5ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0xc5ffffff,0x0,0x4000000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc56bf59d,0x0,0xc5ffffff,0xc5ffffff,0x0,0x0,0x0,0x0,0x856bf59d,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0xc5ffffff,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x856bf59d,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x100,0x3000,0x0,0x0,0x0,0x0,0x40000,0x2000,0x0,0x0,0x0,0x0,0x0,0x40000,0x40000,0x0,0xc56bf59d,0xc56bf59d,0x10000000,0x0,0x0,0xc56bf59d,0xc56bf59d,0x0,0x856bf59d,0x10000000,0x0,0x0,0xc56bf59d,0xc56bf59d,0xc56bf59d,0xc56bf59d,0x0,0x0,0x0,0xc56bf59d,0x0,0xc56bf59d,0x0,0xc56bf59d,0x0,0x0,0x8000000,0x0,0x8d6bf59d,0x0,0x856bf59d,0x856bf59d,0x10000000,0x856bf59d,0x10000000,0x856bf59d,0x856bf59d,0x0,0x4000000,0x0,0x0,0x0,0x0,0xc56bf59d,0x0,0xc56bf59d,0x0,0xc56bf59d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x856bf79d,0x400004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x856bf59d,0x0,0x0,0x856bf59d,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x856bf59d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x856bf59d,0x856bf59d,0x856bf59d,0x856bf59d,0x0,0x202000,0x856bf59d,0x0,0x856bf59d,0x1000,0x0,0x202000,0x200000,0x0,0x0,0x0,0x856bf59d,0x0,0x0,0x0,0x4000000,0xc5ffffff,0x0,0x0,0x0,0x0,0x856bf59d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0xc56bf59d,0x0,0xc5ffffff,0xc5ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x1000000,0x0,0xc5ffffff,0xc5ffffff,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0xc5ffffff,0x0,0xc5ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0xc56bf59d,0x0,0x0,0xc5ffffff,0x0,0x0,0xc5ffffff,0x0,0x0,0x0,0x0,0xc5ffffff,0x0,0x0,0x0,0x2a140a40,0x852bf51d,0xc5ffffff,0x856bf59d,0xc5fbf5ff,0x3f200,0x0,};
   }
   private static void jj_la1_init_9() {
      jj_la1_9 = new int[] {0x100000b,0x1000008,0x100000b,0x0,0x3,0x0,0x1ffff7cd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffffffd,0x0,0x0,0x0,0x0,0x0,0x1ffff7cd,0x0,0x0,0x1ffffffd,0x0,0x0,0x0,0x1ffffffd,0x1ffffffd,0x1ffffffd,0x0,0x1ffffffd,0x1ffffffd,0x0,0x1ffffffd,0x1ffffffd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffffffd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff7cd,0x0,0x1ffffffd,0x1ffffffd,0x0,0x0,0x0,0x0,0x1efffff5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffffffd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1efff7c5,0x0,0x0,0x30000,0x0,0x0,0x0,0x4000000,0x30f030,0x43cfef0,0x0,0x0,0x0,0x0,0x4000000,0x5000000,0x0,0x0,0x400000,0x400000,0x800000,0x400000,0x1000000,0x1000000,0x0,0x1ffff7cd,0x1ffff7cd,0x0,0x1000008,0x0,0x1ffff7c5,0x1ffff7cd,0x0,0x1ffff7c5,0x0,0x0,0x0,0x1ffff7cd,0x1ffff7cd,0x1ffff7cd,0x1ffff7cd,0x0,0x0,0x0,0x1ffff7cd,0x0,0x1ffff7cd,0x0,0x1ffff7cd,0x0,0x0,0x0,0x0,0x1ffff7c5,0x0,0x1ffff7c5,0x1efff7c5,0x0,0x1efff7c5,0x0,0x1efff7c5,0x1ffff7c5,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff7cd,0x0,0x1ffff7cd,0x0,0x1ffff7cd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x0,0x0,0x1efffff5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x1ffff7c5,0x0,0x0,0x1ffff7c5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff7c5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff7c5,0x1ffff7c5,0x1ffff7c5,0x1ffff7c5,0x0,0x0,0x1efff7c5,0x0,0x1ffff7c5,0x800000,0x0,0x0,0x0,0x4,0x0,0x0,0x1ffff7c5,0x0,0x0,0x0,0x0,0x1ffffffd,0x0,0x0,0x0,0x0,0x1efff7c5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff7cd,0x0,0x1ffffffd,0x1ffffffd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffffffd,0x1ffffffd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffffffd,0x0,0x1ffffffd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffffffd,0x0,0x0,0x0,0x0,0x0,0x0,0x38000000,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x1ffffffd,0x0,0x0,0x80000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x38000000,0x0,0x1ffff7cd,0x38000000,0x0,0x3ffffffd,0x38000000,0x0,0x1ffffffd,0x18000000,0x0,0x0,0x0,0x1ffffffd,0x0,0x0,0x0,0x1000038,0x1effb5c5,0x1ffffffd,0x1efff7c5,0x1efffff5,0x7fdfff0,0x0,};
   }
   private static void jj_la1_init_10() {
      jj_la1_10 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0213,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0003,0x0,0x0,0x0,0x0,0x0,0xfffc0213,0x0,0x0,0xfffc0003,0x0,0x0,0x10,0xfffc0013,0xfffc0213,0xfffc0213,0x80,0xfffc0213,0xfffc0213,0x40,0xfffc0213,0xfffc0213,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0213,0x0,0xfffc0003,0xfffc0013,0x0,0x0,0x0,0x0,0xfffc0013,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0xfffc0003,0x80,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0213,0xfffc0213,0x0,0x0,0x0,0xfffc0213,0xfffc0213,0x0,0xfffc0013,0x0,0x0,0x0,0xfffc0213,0xfffc0213,0xfffc0213,0xfffc0213,0x0,0x0,0x0,0xfffc0213,0x0,0xfffc0213,0x0,0xfffc0213,0x0,0x0,0x0,0x0,0xfffc0013,0x0,0xfffc0013,0xfffc0003,0x0,0xfffc0003,0x0,0xfffc0003,0xfffc0013,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0213,0x80,0xfffc0213,0x40,0xfffc0213,0x210,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0013,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0013,0x80,0x40,0xfffc0013,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0003,0xfffc0003,0xfffc0003,0xfffc0003,0x0,0x0,0xfffc0003,0x0,0xfffc0013,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0013,0x0,0x0,0x0,0x0,0xfffc0003,0x0,0x0,0x0,0x0,0xfffc0003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0213,0x0,0xfffc0003,0xfffc0013,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0003,0xfffc0003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0003,0x0,0xfffc0003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc0003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb31c0000,0x0,0x0,0x0,0xb31c0000,0x400000,0xfffc0003,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x0,0x0,0xa00000,0x0,0x4000000,0xfffc0213,0x0,0x4000000,0xfffc0003,0x0,0x0,0xfffc0003,0x0,0xb31c0000,0x0,0xb31c0000,0xfffc0003,0x831c0000,0x30000000,0xb31c0000,0xc,0xfffc0003,0xfffc0003,0xfffc0003,0xfffc0003,0x0,0x0,};
   }
   private static void jj_la1_init_11() {
      jj_la1_11 = new int[] {0x3ff80000,0x0,0x3ff80000,0x0,0x3ff80000,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x100,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0xffdfffff,0x100,0x0,0x0,0xffdfffff,0xffdfffff,0xffdfffff,0x0,0xffdfffff,0xffdfffff,0x0,0xffdfffff,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0xffdfffff,0xffdfffff,0x0,0x100,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0xffdfffff,0x0,0x0,0x0,0xffdfffff,0xffdfffff,0x0,0xffdfffff,0x0,0x0,0x0,0xffdfffff,0xffdfffff,0xffdfffff,0xffdfffff,0x0,0x0,0x0,0xffdfffff,0x0,0xffdfffff,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0xffdfffff,0xffdfffff,0x0,0xffdfffff,0x0,0xffdfffff,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0xffdfffff,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2600,0x0,0x0,0x0,0x0,0x2600,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0xffdfffff,0xffdfffff,0xffdfffff,0x0,0x0,0xffdfffff,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0xffdfffff,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0xffdfffff,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xce,0x0,0x0,0x0,0xce,0x0,0xffdfffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0xffdfffff,0x0,0x10,0xffdfffff,0x0,0x0,0xffdfffff,0x0,0xce,0x0,0xce,0xffdfffff,0x80,0x4e,0xce,0x0,0xffdfffff,0xffdfffff,0xffdfffff,0xffdfffff,0x0,0x0,};
   }
   private static void jj_la1_init_12() {
      jj_la1_12 = new int[] {0x1000000,0x0,0x1000000,0x0,0x1000000,0x0,0x63018fff,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x63018fff,0x0,0x0,0x1018fff,0x0,0x0,0x1000000,0x1018fff,0x1018fff,0x1018fff,0x0,0x1018fff,0x1018fff,0x0,0x1018fff,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x63018fff,0x0,0x1018fff,0x1018fff,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x63018fff,0x63018fff,0x0,0x0,0x0,0x63018fff,0x63018fff,0x0,0x63018fff,0x0,0x0,0x1000000,0x63018fff,0x63018fff,0x63018fff,0x63018fff,0x1000000,0x0,0x0,0x63018fff,0x1000000,0x63018fff,0x1000000,0x63018fff,0x0,0x0,0x0,0x0,0x63018fff,0x0,0x63018fff,0x1018fff,0x0,0x1018fff,0x0,0x1018fff,0x63018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x63018fff,0x0,0x63018fff,0x0,0x63018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x41000000,0x41000000,0x0,0x41000000,0x0,0x0,0x0,0x0,0x0,0x63018fff,0x0,0x0,0x63018fff,0x0,0x0,0x60000000,0x0,0x0,0x310,0x310,0x63018fff,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x0,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0xc0,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x63018fff,0x63018fff,0x63018fff,0x63018fff,0x0,0x62000000,0x1018fff,0x0,0x63018fff,0x0,0x0,0x62000000,0x0,0x20,0x0,0x0,0x63018fff,0x0,0x0,0xc00,0x0,0x41018fff,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x63018fff,0x0,0x1018fff,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x41000000,0x41000000,0x0,0x0,0x0,0x0,0x0,0x1018fff,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x41018fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x2000,0x2000,0x6000,0x1000,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x63018fff,0x0,0x0,0x1018fff,0x0,0x1000000,0x1018fff,0x0,0x0,0x0,0x0,0x1018fff,0x0,0x0,0x0,0x0,0x18fff,0x1018fff,0x1018fff,0x1018fff,0x0,0x0,};
   }
   private static void jj_la1_init_13() {
      jj_la1_13 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1f,0x0,0x0,0x0,0x1f,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x1,0x1,0x0,0x1,0x0,0x0,0x0,0x1,0x1,0x1,0x1,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x1,0x0,0x1,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x1,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1f,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x1f,0x1,0x1,0x1e,0xe,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[76];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public PLSQLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public PLSQLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new PLSQLParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 403; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 403; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public PLSQLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PLSQLParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 403; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 403; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public PLSQLParser(PLSQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 403; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(PLSQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 403; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[422];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 403; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
          if ((jj_la1_8[i] & (1<<j)) != 0) {
            la1tokens[256+j] = true;
          }
          if ((jj_la1_9[i] & (1<<j)) != 0) {
            la1tokens[288+j] = true;
          }
          if ((jj_la1_10[i] & (1<<j)) != 0) {
            la1tokens[320+j] = true;
          }
          if ((jj_la1_11[i] & (1<<j)) != 0) {
            la1tokens[352+j] = true;
          }
          if ((jj_la1_12[i] & (1<<j)) != 0) {
            la1tokens[384+j] = true;
          }
          if ((jj_la1_13[i] & (1<<j)) != 0) {
            la1tokens[416+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 422; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 76; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
            case 59: jj_3_60(); break;
            case 60: jj_3_61(); break;
            case 61: jj_3_62(); break;
            case 62: jj_3_63(); break;
            case 63: jj_3_64(); break;
            case 64: jj_3_65(); break;
            case 65: jj_3_66(); break;
            case 66: jj_3_67(); break;
            case 67: jj_3_68(); break;
            case 68: jj_3_69(); break;
            case 69: jj_3_70(); break;
            case 70: jj_3_71(); break;
            case 71: jj_3_72(); break;
            case 72: jj_3_73(); break;
            case 73: jj_3_74(); break;
            case 74: jj_3_75(); break;
            case 75: jj_3_76(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
