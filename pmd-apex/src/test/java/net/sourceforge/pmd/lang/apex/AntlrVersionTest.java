/*
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.apex;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.io.IOException;
import java.util.Deque;
import java.util.LinkedList;

import org.antlr.v4.runtime.RuntimeMetaData;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import com.github.stefanbirkner.systemlambda.SystemLambda;
import io.github.apexdevtools.apexparser.ApexParser;

class AntlrVersionTest {
    /**
     * <p>In PMD, we provide the antlr4-runtime dependency on our own and overwrite the version that would
     * be inherited transitively. This might cause problems for parsers that are not generated by us,
     * like apex-dev-tools:apex-parser. This might be generated with a different version, which results
     * in stderr messages created by {@link org.antlr.v4.runtime.RuntimeMetaData#checkVersion(String, String)}.
     * </p>
     * <p>
     * Sample failure messages are:
     * <pre>
     *     ANTLR Tool version 4.9.1 used for code generation does not match the current runtime version 4.13.2
     *     ANTLR Runtime version 4.9.1 used for parser compilation does not match the current runtime version 4.13.2
     * </pre>
     * </p>
     * <p>
     *     This test serves as a safety guard, in case we update our own antlr dependency to some
     *     incompatible version.
     * </p>
     *
     * @see <a href="https://github.com/pmd/pmd/issues/4678">[apex] Warning messages about ANTLR version mismatch #4678</a>
     */
    @Test
    void antlrVersionIsCompatible() throws IOException {
        ClassReader classReader = new ClassReader(ApexParser.class.getName());
        classReader.accept(new ClassVisitor(Opcodes.ASM9) {
            @Override
            public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
                if ("<clinit>".equals(name)) {
                    return new MethodVisitor(Opcodes.ASM9) {
                        private final Deque<String> versions = new LinkedList<>();

                        @Override
                        public void visitLdcInsn(Object value) {
                            if (value instanceof String) {
                                versions.addLast((String) value);
                                if (versions.size() > 2) {
                                    versions.removeFirst();
                                }
                            }
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
                            if ("org/antlr/v4/runtime/RuntimeMetaData".equals(owner) && "checkVersion".equals(name)) {
                                assertEquals(2, versions.size());
                                String checkResult = executeCheckVersion(versions.getFirst(), versions.getLast());
                                assertEquals("", checkResult, "no incompatibility message expected");
                            }
                        }
                    };
                }
                return null;
            }
        }, 0);
    }

    private String executeCheckVersion(String generatingToolVersion, String compileTimeVersion) {
        try {
            return SystemLambda.tapSystemErr(() -> {
                RuntimeMetaData.checkVersion(generatingToolVersion, compileTimeVersion);
            });
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
