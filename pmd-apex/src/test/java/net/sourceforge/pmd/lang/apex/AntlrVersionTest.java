/*
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */

package net.sourceforge.pmd.lang.apex;

import static org.junit.jupiter.api.Assertions.assertEquals;

import com.github.stefanbirkner.systemlambda.SystemLambda;
import io.github.apexdevtools.apexparser.ApexParser;
import java.io.IOException;
import java.util.Deque;
import java.util.LinkedList;
import org.antlr.v4.runtime.RuntimeMetaData;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

class AntlrVersionTest {
    /**
     * <p>In PMD, we provide the antlr4-runtime dependency on our own and overwrite the version that would
     * be inherited transitively. This might cause problems for parsers that are not generated by us,
     * like apex-dev-tools:apex-parser. This might be generated with a different version, which results
     * in stderr messages created by {@link org.antlr.v4.runtime.RuntimeMetaData#checkVersion(String, String)}.
     * </p>
     * <p>
     * Sample failure messages are:
     * <pre>
     *     ANTLR Tool version 4.9.1 used for code generation does not match the current runtime version 4.13.2
     *     ANTLR Runtime version 4.9.1 used for parser compilation does not match the current runtime version 4.13.2
     * </pre>
     * </p>
     * <p>
     *     This test serves as a safety guard, in case we update our own antlr dependency to some
     *     incompatible version.
     * </p>
     *
     * @see <a href="https://github.com/pmd/pmd/issues/4678">[apex] Warning messages about ANTLR version mismatch #4678</a>
     */
    @Test
    void antlrVersionIsCompatible() throws IOException {
        ClassReader classReader = new ClassReader(ApexParser.class.getName());
        classReader.accept(
                new ClassVisitor(Opcodes.ASM9) {
                    @Override
                    public MethodVisitor visitMethod(
                            int access, String name, String descriptor, String signature, String[] exceptions) {
                        if ("<clinit>".equals(name)) {
                            return new MethodVisitor(Opcodes.ASM9) {
                                private final Deque<String> versions = new LinkedList<>();

                                @Override
                                public void visitLdcInsn(Object value) {
                                    if (value instanceof String) {
                                        versions.addLast((String) value);
                                        if (versions.size() > 2) {
                                            versions.removeFirst();
                                        }
                                    }
                                }

                                @Override
                                public void visitMethodInsn(
                                        int opcode, String owner, String name, String descriptor, boolean isInterface) {
                                    if ("org/antlr/v4/runtime/RuntimeMetaData".equals(owner)
                                            && "checkVersion".equals(name)) {
                                        assertEquals(2, versions.size());
                                        String checkResult =
                                                executeCheckVersion(versions.getFirst(), versions.getLast());
                                        assertEquals("", checkResult, "no incompatibility message expected");
                                    }
                                }
                            };
                        }
                        return null;
                    }
                },
                0);
    }

    private String executeCheckVersion(String generatingToolVersion, String compileTimeVersion) {
        try {
            return SystemLambda.tapSystemErr(() -> {
                RuntimeMetaData.checkVersion(generatingToolVersion, compileTimeVersion);
            });
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
